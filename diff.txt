diff --git a/index.html b/index.html
index 27e4862..05d6b15 100644
--- a/index.html
+++ b/index.html
@@ -128,18 +128,21 @@
                     </div>
                     <button
                         id="share-analysis-btn"
+                        data-testid="share-analysis-btn"
                         class="hidden bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md transition duration-300"
                     >
                         Share
                     </button>
                     <button
                         id="copy-debug-btn"
+                        data-testid="copy-debug-btn"
                         class="hidden bg-yellow-600 hover:bg-yellow-700 text-black font-bold py-2 px-4 rounded-md transition duration-300"
                     >
                         Copy Debug Info
                     </button>
                     <button
                         id="new-analysis-btn"
+                        data-testid="new-analysis-btn"
                         class="hidden bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-300"
                     >
                         Analyze New Streams
@@ -158,18 +161,21 @@
                 <div class="flex flex-col sm:flex-row gap-4 mt-6">
                     <button
                         id="clear-all-btn"
+                        data-testid="clear-all-btn"
                         class="w-full sm:w-auto flex-grow bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition duration-300"
                     >
                         Clear All
                     </button>
                     <button
                         id="add-stream-btn"
+                        data-testid="add-stream-btn"
                         class="w-full sm:w-auto flex-grow bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md transition duration-300"
                     >
                         Add Another Stream
                     </button>
                     <button
                         id="analyze-btn"
+                        data-testid="analyze-btn"
                         class="w-full sm:w-auto flex-grow bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-300"
                     >
                         Analyze & Compare
@@ -271,6 +277,7 @@
                             >
                             <select
                                 id="context-switcher"
+                                data-testid="context-switcher"
                                 class="bg-gray-700 text-white rounded-md border-gray-600 p-2"
                             ></select>
                         </div>
diff --git a/js/app/app.js b/js/app/app.js
deleted file mode 100644
index 52d01f7..0000000
--- a/js/app/app.js
+++ /dev/null
@@ -1,187 +0,0 @@
-import { addStreamInput } from '../ui/components/stream-inputs.js';
-import { copyDebugInfoToClipboard } from '../services/debugService.js';
-import { copyShareUrlToClipboard } from '../services/shareService.js';
-import { saveToHistory } from '../shared/utils/stream-storage.js';
-
-export class Application {
-    /**
-     * @param {object} dom The collected DOM elements.
-     * @param {object} services The injected services and utilities.
-     */
-    constructor(dom, services) {
-        this.dom = dom;
-        this.eventBus = services.eventBus;
-        this.storeActions = services.storeActions;
-        this.stopAllMonitoring = services.stopAllMonitoring;
-        this.storage = services.storage;
-    }
-
-    /**
-     * Attaches core application event listeners.
-     */
-    initializeAppEventListeners() {
-        this.eventBus.subscribe('state:analysis-complete', ({ streams }) => {
-            if (streams.length > 0) {
-                saveToHistory(streams[0]);
-                const defaultTab =
-                    streams.length > 1 ? 'comparison' : 'summary';
-                this.storeActions.setActiveTab(defaultTab);
-            }
-        });
-
-        this.eventBus.subscribe('analysis:error', ({ message, error }) => {
-            this.eventBus.dispatch('ui:show-status', {
-                message,
-                type: 'fail',
-                duration: 8000,
-            });
-            console.error('An analysis error occurred:', error);
-        });
-    }
-
-    /**
-     * Attaches DOM-specific event listeners.
-     */
-    _initializeDOMEventListeners() {
-        this.dom.addStreamBtn.addEventListener('click', () => {
-            addStreamInput();
-        });
-        this.dom.analyzeBtn.addEventListener('click', () =>
-            this._handleAnalysis()
-        );
-        this.dom.newAnalysisBtn.addEventListener('click', () => {
-            this.stopAllMonitoring();
-            this.storeActions.startAnalysis();
-        });
-        this.dom.clearAllBtn.addEventListener('click', () => {
-            this.storeActions.resetStreamInputIds();
-        });
-        this.dom.contextSwitcher.addEventListener('change', (e) => {
-            const target = /** @type {HTMLSelectElement} */ (e.target);
-            this.storeActions.setActiveStreamId(parseInt(target.value, 10));
-        });
-        this.dom.shareAnalysisBtn.addEventListener(
-            'click',
-            copyShareUrlToClipboard
-        );
-        this.dom.copyDebugBtn.addEventListener(
-            'click',
-            copyDebugInfoToClipboard
-        );
-    }
-
-    /**
-     * Triggers the stream analysis process.
-     */
-    _handleAnalysis() {
-        const inputGroups = this.dom.streamInputs.querySelectorAll(
-            '.stream-input-group'
-        );
-        const inputs = Array.from(inputGroups)
-            .map((group) => {
-                const id = parseInt(
-                    /** @type {HTMLElement} */ (group).dataset.id
-                );
-                const urlInput = /** @type {HTMLInputElement} */ (
-                    group.querySelector('.input-url')
-                );
-                const nameInput = /** @type {HTMLInputElement} */ (
-                    group.querySelector('.input-name')
-                );
-                const fileInput = /** @type {HTMLInputElement} */ (
-                    group.querySelector('.input-file')
-                );
-                return {
-                    id,
-                    url: urlInput.value,
-                    name: nameInput.value,
-                    file:
-                        fileInput.files.length > 0 ? fileInput.files[0] : null,
-                };
-            })
-            .filter((input) => input.url || input.file);
-
-        if (inputs.length > 0) {
-            const streamsToSave = inputs
-                .filter((i) => i.url)
-                .map((i) => ({ url: i.url, name: i.name }));
-            this.storage.saveLastUsedStreams(streamsToSave);
-            this.eventBus.dispatch('analysis:request', { inputs });
-        } else {
-            this.eventBus.dispatch('ui:show-status', {
-                message: 'Please provide a stream URL or file to analyze.',
-                type: 'warn',
-            });
-        }
-    }
-
-    /**
-     * Populates input fields from URL parameters or local storage.
-     */
-    _populateInputs() {
-        const urlParams = new URLSearchParams(window.location.search);
-        const streamUrls = urlParams.getAll('url');
-
-        if (streamUrls.length > 0 && streamUrls[0]) {
-            const inputs = streamUrls.map((url, index) => ({
-                id: index,
-                url: url,
-                file: null,
-            }));
-            this.eventBus.dispatch('analysis:request', { inputs });
-        } else {
-            this._populateLastUsedStreams();
-        }
-    }
-
-    _populateLastUsedStreams() {
-        const lastUsed = this.storage.getLastUsedStreams();
-        if (lastUsed && lastUsed.length > 0) {
-            this.storeActions.setStreamInputsFromData(lastUsed);
-            const allStoredStreams = [
-                ...this.storage.getHistory(),
-                ...this.storage.getPresets(),
-            ];
-
-            Promise.resolve().then(() => {
-                const inputGroups = this.dom.streamInputs.querySelectorAll(
-                    '.stream-input-group'
-                );
-                inputGroups.forEach((group, index) => {
-                    if (!lastUsed[index]) return;
-
-                    const urlInput = /** @type {HTMLInputElement} */ (
-                        group.querySelector('.input-url')
-                    );
-                    const nameInput = /** @type {HTMLInputElement} */ (
-                        group.querySelector('.input-name')
-                    );
-
-                    if (urlInput) {
-                        const lastUsedUrl = lastUsed[index].url || '';
-                        urlInput.value = lastUsedUrl;
-
-                        const storedItem = allStoredStreams.find(
-                            (s) => s.url === lastUsedUrl
-                        );
-                        if (storedItem) {
-                            nameInput.value = storedItem.name;
-                        }
-
-                        urlInput.dispatchEvent(
-                            new Event('input', { bubbles: true })
-                        );
-                    }
-                });
-            });
-        }
-    }
-
-    /**
-     * Starts the application by attaching event listeners and populating initial data.
-     */
-    start() {
-        this._initializeDOMEventListeners();
-        this._populateInputs();
-    }
-}
diff --git a/js/app/consent-manager.js b/js/app/consent-manager.js
deleted file mode 100644
index 8e91706..0000000
--- a/js/app/consent-manager.js
+++ /dev/null
@@ -1,111 +0,0 @@
-/**
- * @typedef {object} OnChangePayload
- * @property {string[]} acceptedCategories
- * @property {string[]} rejectedCategories
- * @property {object} SCRIPT
- */
-
-/**
- * Initializes the CookieConsent.js library with categories for analytics and error reporting.
- * It handles the conditional loading of tracking scripts based on user consent and the application's hostname.
- *
- * This function relies on loader functions (`loadGoogleAnalytics`, `loadSentry`, `loadClarity`)
- * being globally available, as defined in `index.html`.
- */
-export function initializeConsentManager() {
-    /** @type {any} */
-    const CookieConsent = window.CookieConsent;
-
-    if (!CookieConsent) {
-        console.error('CookieConsent library not found.');
-        return;
-    }
-
-    CookieConsent.run({
-        // The language configuration is mandatory.
-        language: {
-            default: 'en',
-            translations: {
-                en: {
-                    consentModal: {
-                        title: 'This website uses cookies',
-                        description:
-                            'We use cookies and similar tracking technologies to understand how you use our tool and to improve your experience. This includes analytics to measure usage and error reporting to help us find and fix bugs.',
-                        acceptAllBtn: 'Accept all',
-                        acceptNecessaryBtn: 'Reject all',
-                        showPreferencesBtn: 'Manage preferences',
-                    },
-                    preferencesModal: {
-                        title: 'Manage consent preferences',
-                        acceptAllBtn: 'Accept all',
-                        acceptNecessaryBtn: 'Reject all',
-                        savePreferencesBtn: 'Save preferences',
-                        sections: [
-                            {
-                                title: 'Cookie Usage',
-                                description:
-                                    'This tool uses cookies to enhance functionality and to analyze site performance. You can choose whether to allow non-essential cookies below.',
-                            },
-                            {
-                                title: 'Strictly Necessary Cookies',
-                                description:
-                                    'These cookies are essential for the website to function and cannot be switched off in our systems. They do not store any personally identifiable information.',
-                                linkedCategory: 'necessary',
-                                readOnly: true,
-                            },
-                            {
-                                title: 'Performance & Analytics Cookies',
-                                description:
-                                    'These cookies allow us to count visits and traffic sources so we can measure and improve the performance of our site. This helps us understand which features are most popular and how users move around the site.',
-                                linkedCategory: 'analytics',
-                            },
-                            {
-                                title: 'Error Reporting Cookies',
-                                description:
-                                    'These cookies help us detect and fix bugs by reporting errors that occur during your session. This data is used to improve the stability and reliability of the application.',
-                                linkedCategory: 'error_reporting',
-                            },
-                        ],
-                    },
-                },
-            },
-        },
-
-        categories: {
-            necessary: {
-                enabled: true,
-                readOnly: true,
-            },
-            analytics: {
-                enabled: false,
-                autoClear: {
-                    cookies: [{ name: /^_ga/ }],
-                },
-            },
-            error_reporting: {
-                enabled: false,
-            },
-        },
-
-        /**
-         * This callback function is executed whenever the user's consent choices change.
-         * @param {OnChangePayload} payload
-         */
-        onChange: ({ acceptedCategories }) => {
-            // Only run tracking scripts on the production domain
-            if (window.location.hostname !== 'stream-analyzer.herruzo.dev') {
-                return;
-            }
-
-            if (acceptedCategories.includes('analytics')) {
-                // These functions are defined globally in index.html
-                window.loadGoogleAnalytics();
-                window.loadClarity();
-            }
-
-            if (acceptedCategories.includes('error_reporting')) {
-                window.loadSentry();
-            }
-        },
-    });
-}
diff --git a/js/app/event-bus.js b/js/app/event-bus.js
deleted file mode 100644
index ca60494..0000000
--- a/js/app/event-bus.js
+++ /dev/null
@@ -1,43 +0,0 @@
-/**
- * A simple publish-subscribe event bus.
- * Enables decoupled communication between different parts of the application.
- */
-class EventBus {
-    constructor() {
-        this.listeners = {};
-    }
-
-    /**
-     * Subscribes a callback to an event.
-     * @param {string} eventName The name of the event to subscribe to.
-     * @param {Function} callback The function to call when the event is dispatched.
-     * @returns {() => void} A function to unsubscribe.
-     */
-    subscribe(eventName, callback) {
-        if (!this.listeners[eventName]) {
-            this.listeners[eventName] = [];
-        }
-        this.listeners[eventName].push(callback);
-
-        // Return an unsubscribe function
-        return () => {
-            this.listeners[eventName] = this.listeners[eventName].filter(
-                (listener) => listener !== callback
-            );
-        };
-    }
-
-    /**
-     * Dispatches an event, calling all subscribed callbacks.
-     * @param {string} eventName The name of the event to dispatch.
-     * @param {*} data The data to pass to the event listeners.
-     */
-    dispatch(eventName, data) {
-        if (!this.listeners[eventName]) {
-            return;
-        }
-        this.listeners[eventName].forEach((callback) => callback(data));
-    }
-}
-
-export const eventBus = new EventBus();
diff --git a/js/app/lru-cache.js b/js/app/lru-cache.js
deleted file mode 100644
index 82b542c..0000000
--- a/js/app/lru-cache.js
+++ /dev/null
@@ -1,91 +0,0 @@
-/**
- * A simple, memory-efficient LRU (Least Recently Used) cache implementation.
- * It uses a Map to maintain insertion order for O(1) access, insertion, and deletion.
- * When the cache exceeds its maximum size, the least recently used item (the first item
- * in the map's insertion order) is evicted.
- */
-export class LRUCache {
-    /**
-     * @param {number} maxSize The maximum number of items to store in the cache.
-     */
-    constructor(maxSize = 100) {
-        if (maxSize < 1) {
-            throw new Error('LRUCache maxSize must be at least 1.');
-        }
-        this.maxSize = maxSize;
-        this.cache = new Map();
-    }
-
-    /**
-     * Retrieves an item from the cache and marks it as recently used.
-     * @param {any} key The key of the item to retrieve.
-     * @returns {any | undefined} The cached value or undefined if not found.
-     */
-    get(key) {
-        if (!this.cache.has(key)) {
-            return undefined;
-        }
-
-        const value = this.cache.get(key);
-        // By deleting and setting the key again, we move it to the end of the
-        // map's insertion order, marking it as the most recently used.
-        this.cache.delete(key);
-        this.cache.set(key, value);
-        return value;
-    }
-
-    /**
-     * Adds an item to the cache, evicting the least recently used item if necessary.
-     * @param {any} key The key of the item to add.
-     * @param {any} value The value of the item to add.
-     */
-    set(key, value) {
-        // If the key already exists, delete it to ensure it's moved to the end.
-        if (this.cache.has(key)) {
-            this.cache.delete(key);
-        }
-
-        // Check for eviction before adding the new item.
-        if (this.cache.size >= this.maxSize) {
-            // Get the first key in the map, which is the least recently used.
-            const leastRecentlyUsedKey = this.cache.keys().next().value;
-            this.cache.delete(leastRecentlyUsedKey);
-        }
-
-        this.cache.set(key, value);
-    }
-
-    /**
-     * Checks if an item exists in the cache.
-     * @param {any} key The key to check.
-     * @returns {boolean}
-     */
-    has(key) {
-        return this.cache.has(key);
-    }
-
-    /**
-     * Executes a provided function once for each key/value pair in the cache.
-     * @param {(value: any, key: any, map: Map<any, any>) => void} callback
-     */
-    forEach(callback) {
-        this.cache.forEach(callback);
-    }
-
-    /**
-     * Clears all items from the cache.
-     */
-    clear() {
-        this.cache.clear();
-    }
-
-    /**
-     * Creates a new LRUCache instance with a shallow copy of the current cache's contents.
-     * @returns {LRUCache}
-     */
-    clone() {
-        const newCache = new LRUCache(this.maxSize);
-        newCache.cache = new Map(this.cache);
-        return newCache;
-    }
-}
diff --git a/js/app/main.js b/js/app/main.js
deleted file mode 100644
index b0bd035..0000000
--- a/js/app/main.js
+++ /dev/null
@@ -1,127 +0,0 @@
-import { Application } from './app.js';
-import { setupGlobalTooltipListener } from '../ui/components/tooltip.js';
-import { initializeTabs } from '../ui/tabs.js';
-import { initializeModalComponent } from '../ui/components/modal.js';
-import {
-    initializeLiveStreamMonitor,
-    stopAllMonitoring,
-} from '../services/primaryStreamMonitorService.js';
-import { initializeUiController } from '../ui/ui-controller.js';
-import { initializeViewManager } from '../ui/view-manager.js';
-import { initializeToastManager } from '../ui/components/toast.js';
-import { initializeLiveUpdateProcessor } from '../services/liveUpdateProcessor.js';
-import { useStore, storeActions, useSegmentCacheStore } from './store.js';
-import { initializeHlsVariantPoller } from '../services/hlsVariantPollerService.js';
-import { initializeCmafService } from '../services/cmafService.js';
-import { initializeRenderer, renderApp } from '../ui/mainRenderer.js';
-import { initializeLoader } from '../ui/components/loader.js';
-import { initializeConsentManager } from './consent-manager.js';
-import { eventBus } from './event-bus.js';
-import {
-    saveLastUsedStreams,
-    getLastUsedStreams,
-    getHistory,
-    getPresets,
-} from '../shared/utils/stream-storage.js';
-
-// Side-effect driven imports for services that primarily listen to the event bus
-import '../services/streamService.js';
-import '../services/segmentService.js';
-
-/**
- * The main entry point for the application.
- * This function orchestrates the setup and startup of all application components.
- */
-async function startApp() {
-    // --- DOM ELEMENT COLLECTION (Single Source of Truth) ---
-    const dom = {
-        mainHeader: document.getElementById('main-header'),
-        headerTitleGroup: document.getElementById('header-title-group'),
-        headerUrlDisplay: document.getElementById('header-url-display'),
-        streamInputs: document.getElementById('stream-inputs'),
-        addStreamBtn: document.getElementById('add-stream-btn'),
-        analyzeBtn: document.getElementById('analyze-btn'),
-        clearAllBtn: document.getElementById('clear-all-btn'),
-        toastContainer: document.getElementById('toast-container'),
-        results: document.getElementById('results'),
-        inputSection: document.getElementById('input-section'),
-        newAnalysisBtn: document.getElementById('new-analysis-btn'),
-        shareAnalysisBtn: document.getElementById('share-analysis-btn'),
-        copyDebugBtn: document.getElementById('copy-debug-btn'),
-        tabs: document.getElementById('tabs'),
-        contextSwitcherWrapper: document.getElementById(
-            'context-switcher-wrapper'
-        ),
-        contextSwitcher: document.getElementById('context-switcher'),
-        tabContents: {
-            comparison: document.getElementById('tab-comparison'),
-            summary: document.getElementById('tab-summary'),
-            'integrators-report': document.getElementById(
-                'tab-integrators-report'
-            ),
-            'timeline-visuals': document.getElementById('tab-timeline-visuals'),
-            features: document.getElementById('tab-features'),
-            compliance: document.getElementById('tab-compliance'),
-            explorer: document.getElementById('tab-explorer'),
-            'interactive-segment': document.getElementById(
-                'tab-interactive-segment'
-            ),
-            'interactive-manifest': document.getElementById(
-                'tab-interactive-manifest'
-            ),
-            updates: document.getElementById('tab-updates'),
-            'parser-coverage': document.getElementById('tab-parser-coverage'),
-        },
-        segmentModal: document.getElementById('segment-modal'),
-        modalTitle: document.getElementById('modal-title'),
-        modalSegmentUrl: document.getElementById('modal-segment-url'),
-        modalContentArea: document.getElementById('modal-content-area'),
-        closeModalBtn: document.getElementById('close-modal-btn'),
-        globalTooltip: document.getElementById('global-tooltip'),
-        globalLoader: document.getElementById('global-loader'),
-        loaderMessage: document.getElementById('loader-message'),
-    };
-
-    // --- DEPENDENCY INJECTION & INITIALIZATION ---
-
-    // 1. Construct all modules
-    const app = new Application(dom, {
-        eventBus,
-        storeActions,
-        stopAllMonitoring,
-        storage: {
-            saveLastUsedStreams,
-            getLastUsedStreams,
-            getHistory,
-            getPresets,
-        },
-    });
-
-    // 2. Initialize modules (wiring and event listeners)
-    initializeConsentManager();
-    app.initializeAppEventListeners(); // Initialize app-level listeners
-    initializeRenderer(dom);
-    initializeToastManager(dom);
-    initializeLoader(dom);
-    initializeViewManager();
-    initializeLiveUpdateProcessor();
-    initializeTabs(dom);
-    initializeModalComponent(dom);
-    initializeUiController(dom);
-    setupGlobalTooltipListener(dom);
-    initializeLiveStreamMonitor();
-    initializeHlsVariantPoller();
-    initializeCmafService();
-
-    // 3. Start the main application logic
-    app.start();
-
-    // --- MAIN RENDER LOOP ---
-    useStore.subscribe(renderApp);
-    useSegmentCacheStore.subscribe(renderApp); // Ensure UI updates on cache changes
-
-    // Initial render based on default state
-    renderApp();
-}
-
-document.addEventListener('DOMContentLoaded', startApp);
diff --git a/js/app/store.js b/js/app/store.js
deleted file mode 100644
index d27b3ad..0000000
--- a/js/app/store.js
+++ /dev/null
@@ -1,303 +0,0 @@
-import { createStore } from 'zustand/vanilla';
-import { LRUCache } from './lru-cache.js';
-import { eventBus } from './event-bus.js';
-// --- Type Definitions ---
-/** @typedef {import('./types.ts').Stream} Stream */
-/** @typedef {import('./types.ts').DecodedSample} DecodedSample */
-
-/**
- * @typedef {object} ModalState
- * @property {boolean} isModalOpen
- * @property {string} modalTitle
- * @property {string} modalUrl
- * @property {{ type: string; data: any; } | null} modalContent
- */
-
-/**
- * @typedef {object} AnalysisState
- * @property {Stream[]} streams
- * @property {number | null} activeStreamId
- * @property {string | null} activeSegmentUrl
- * @property {number} streamIdCounter
- * @property {number[]} streamInputIds
- * @property {string[]} segmentsForCompare
- * @property {Map<string, DecodedSample>} decodedSamples
- * @property {number} interactiveManifestCurrentPage
- * @property {number} interactiveSegmentCurrentPage
- * @property {'input' | 'results'} viewState
- * @property {string} activeTab
- * @property {ModalState} modalState
- * @property {boolean} isCmafSummaryExpanded
- */
-
-/**
- * @typedef {object} AnalysisActions
- * @property {() => void} startAnalysis
- * @property {(streams: Stream[]) => void} completeAnalysis
- * @property {(streamId: number) => void} setActiveStreamId
- * @property {(url: string) => void} setActiveSegmentUrl
- * @property {() => void} addStreamInputId
- * @property {(id: number) => void} removeStreamInputId
- * @property {() => void} resetStreamInputIds
- * @property {(data: object[]) => void} setStreamInputsFromData
- * @property {(url: string) => void} addSegmentToCompare
- * @property {(url: string) => void} removeSegmentFromCompare
- * @property {() => void} clearSegmentsToCompare
- * @property {(streamId: number, updatedStreamData: Partial<Stream>) => void} updateStream
- * @property {(isPolling: boolean) => void} setAllLiveStreamsPolling
- * @property {(streamId: number, direction: number) => void} navigateManifestUpdate
- * @property {(page: number) => void} setInteractiveManifestPage
- * @property {(page: number) => void} setInteractiveSegmentPage
- * @property {(view: 'input' | 'results') => void} setViewState
- * @property {(tabName: string) => void} setActiveTab
- * @property {(modalState: Partial<ModalState>) => void} setModalState
- * @property {() => void} toggleCmafSummary
- */
-
-// --- Segment Cache Store (New) ---
-
-const SEGMENT_CACHE_SIZE = 200;
-
-/**
- * @typedef {object} SegmentCacheState
- * @property {LRUCache} cache
- */
-
-/**
- * @typedef {object} SegmentCacheActions
- * @property {(url: string, entry: any) => void} set
- * @property {(url: string) => any} get
- * @property {() => void} clear
- */
-
-/**
- * A dedicated store for managing the segment cache.
- * @type {import('zustand/vanilla').StoreApi<SegmentCacheState & SegmentCacheActions>}
- */
-export const useSegmentCacheStore = createStore((set, get) => ({
-    cache: new LRUCache(SEGMENT_CACHE_SIZE),
-    set: (url, entry) => {
-        const currentCache = get().cache;
-        currentCache.set(url, entry);
-        // Create a new object reference to trigger Zustand's shallow comparison
-        set({ cache: currentCache.clone() });
-    },
-    get: (url) => get().cache.get(url),
-    clear: () => set({ cache: new LRUCache(SEGMENT_CACHE_SIZE) }),
-}));
-
-// --- Main Analysis Store Definition ---
-
-/**
- * Creates the initial state for the main analysis store.
- * @returns {AnalysisState}
- */
-const createInitialState = () => ({
-    streams: [],
-    activeStreamId: null,
-    activeSegmentUrl: null,
-    streamIdCounter: 1,
-    streamInputIds: [0],
-    segmentsForCompare: [],
-    decodedSamples: new Map(),
-    interactiveManifestCurrentPage: 1,
-    interactiveSegmentCurrentPage: 1,
-    viewState: 'input',
-    activeTab: 'summary',
-    modalState: {
-        isModalOpen: false,
-        modalTitle: '',
-        modalUrl: '',
-        modalContent: null,
-    },
-    isCmafSummaryExpanded: false,
-});
-
-/**
- * The main application state store, powered by Zustand.
- * @type {import('zustand/vanilla').StoreApi<AnalysisState & AnalysisActions>}
- */
-const store = createStore((set, get) => ({
-    ...createInitialState(),
-
-    // --- Actions ---
-    startAnalysis: () => {
-        useSegmentCacheStore.getState().clear(); // Also clear segment cache on new analysis
-        set(createInitialState());
-    },
-
-    completeAnalysis: (streams) => {
-        const defaultTab = streams.length > 1 ? 'comparison' : 'summary';
-        set({
-            streams: streams,
-            activeStreamId: streams[0]?.id ?? null,
-            viewState: 'results',
-            activeTab: defaultTab,
-        });
-        eventBus.dispatch('state:analysis-complete', { streams });
-    },
-
-    setActiveStreamId: (streamId) => set({ activeStreamId: streamId }),
-    setActiveSegmentUrl: (url) =>
-        set({ activeSegmentUrl: url, interactiveSegmentCurrentPage: 1 }),
-
-    addStreamInputId: () => {
-        set((state) => ({
-            streamInputIds: [...state.streamInputIds, state.streamIdCounter],
-            streamIdCounter: state.streamIdCounter + 1,
-        }));
-    },
-
-    removeStreamInputId: (id) => {
-        set((state) => ({
-            streamInputIds: state.streamInputIds.filter((i) => i !== id),
-        }));
-    },
-
-    resetStreamInputIds: () => {
-        get().startAnalysis();
-    },
-
-    setStreamInputsFromData: (data) => {
-        const newIds = Array.from({ length: data.length }, (_, i) => i);
-        set({
-            streamInputIds: newIds,
-            streamIdCounter: data.length,
-        });
-    },
-
-    addSegmentToCompare: (url) => {
-        const { segmentsForCompare } = get();
-        if (
-            segmentsForCompare.length < 2 &&
-            !segmentsForCompare.includes(url)
-        ) {
-            set({ segmentsForCompare: [...segmentsForCompare, url] });
-            eventBus.dispatch('state:compare-list-changed', {
-                count: get().segmentsForCompare.length,
-            });
-        }
-    },
-
-    removeSegmentFromCompare: (url) => {
-        set((state) => ({
-            segmentsForCompare: state.segmentsForCompare.filter(
-                (u) => u !== url
-            ),
-        }));
-        eventBus.dispatch('state:compare-list-changed', {
-            count: get().segmentsForCompare.length,
-        });
-    },
-
-    clearSegmentsToCompare: () => {
-        set({ segmentsForCompare: [] });
-        eventBus.dispatch('state:compare-list-changed', { count: 0 });
-    },
-
-    updateStream: (streamId, updatedStreamData) => {
-        set((state) => ({
-            streams: state.streams.map((s) =>
-                s.id === streamId ? { ...s, ...updatedStreamData } : s
-            ),
-        }));
-        eventBus.dispatch('state:stream-updated', { streamId });
-    },
-
-    setAllLiveStreamsPolling: (isPolling) => {
-        set((state) => ({
-            streams: state.streams.map((s) =>
-                s.manifest?.type === 'dynamic' ? { ...s, isPolling } : s
-            ),
-        }));
-        // Notify the monitor service to react to the global state change immediately.
-        eventBus.dispatch('state:stream-updated');
-    },
-
-    navigateManifestUpdate: (streamId, direction) => {
-        set((state) => {
-            const streamIndex = state.streams.findIndex(
-                (s) => s.id === streamId
-            );
-            if (streamIndex === -1) return {};
-
-            const stream = state.streams[streamIndex];
-            if (stream.manifestUpdates.length === 0) return {};
-
-            let newIndex = stream.activeManifestUpdateIndex + direction;
-            newIndex = Math.max(
-                0,
-                Math.min(newIndex, stream.manifestUpdates.length - 1)
-            );
-
-            if (newIndex === stream.activeManifestUpdateIndex) return {};
-
-            const newStreams = [...state.streams];
-            const updatedStream = {
-                ...stream,
-                activeManifestUpdateIndex: newIndex,
-            };
-
-            if (newIndex === 0) {
-                updatedStream.manifestUpdates[0].hasNewIssues = false;
-            }
-
-            newStreams[streamIndex] = updatedStream;
-
-            return { streams: newStreams };
-        });
-    },
-
-    setInteractiveManifestPage: (page) =>
-        set({ interactiveManifestCurrentPage: page }),
-    setInteractiveSegmentPage: (page) =>
-        set({ interactiveSegmentCurrentPage: page }),
-
-    setViewState: (view) => set({ viewState: view }),
-
-    setActiveTab: (tabName) => set({ activeTab: tabName }),
-
-    setModalState: (newModalState) => {
-        set((state) => ({
-            modalState: { ...state.modalState, ...newModalState },
-        }));
-    },
-
-    toggleCmafSummary: () => {
-        set((state) => ({
-            isCmafSummaryExpanded: !state.isCmafSummaryExpanded,
-        }));
-    },
-}));
-
-// --- Exporting Store and Actions ---
-
-export const useStore = store;
-export const storeActions = {
-    startAnalysis: () => store.getState().startAnalysis(),
-    completeAnalysis: (streams) => store.getState().completeAnalysis(streams),
-    setActiveStreamId: (id) => store.getState().setActiveStreamId(id),
-    setActiveSegmentUrl: (url) => store.getState().setActiveSegmentUrl(url),
-    addStreamInputId: () => store.getState().addStreamInputId(),
-    removeStreamInputId: (id) => store.getState().removeStreamInputId(id),
-    resetStreamInputIds: () => store.getState().resetStreamInputIds(),
-    setStreamInputsFromData: (data) =>
-        store.getState().setStreamInputsFromData(data),
-    addSegmentToCompare: (url) => store.getState().addSegmentToCompare(url),
-    removeSegmentFromCompare: (url) =>
-        store.getState().removeSegmentFromCompare(url),
-    clearSegmentsToCompare: () => store.getState().clearSegmentsToCompare(),
-    updateStream: (id, data) => store.getState().updateStream(id, data),
-    setAllLiveStreamsPolling: (isPolling) =>
-        store.getState().setAllLiveStreamsPolling(isPolling),
-    navigateManifestUpdate: (id, dir) =>
-        store.getState().navigateManifestUpdate(id, dir),
-    setInteractiveManifestPage: (page) =>
-        store.getState().setInteractiveManifestPage(page),
-    setInteractiveSegmentPage: (page) =>
-        store.getState().setInteractiveSegmentPage(page),
-    setViewState: (view) => store.getState().setViewState(view),
-    setActiveTab: (tabName) => store.getState().setActiveTab(tabName),
-    setModalState: (state) => store.getState().setModalState(state),
-    toggleCmafSummary: () => store.getState().toggleCmafSummary(),
-};
diff --git a/js/app/types.ts b/js/app/types.ts
deleted file mode 100644
index 7dbbd56..0000000
--- a/js/app/types.ts
+++ /dev/null
@@ -1,516 +0,0 @@
-export interface Label {
-    id: string;
-    lang: string | null;
-    text: string;
-}
-
-export interface Descriptor {
-    schemeIdUri: string;
-    value: string | null;
-    id: string | null;
-}
-
-export interface AudioChannelConfiguration {
-    schemeIdUri: string;
-    value: string | null;
-}
-
-export interface URLType {
-    sourceURL: string | null;
-    range: string | null;
-}
-
-export interface FailoverContent {
-    valid: boolean;
-    fcs: { t: number; d: number }[];
-}
-
-export interface SubRepresentation {
-    level: number | null;
-    dependencyLevel: string | null;
-    bandwidth: number | null;
-    contentComponent: string[] | null;
-    codecs: string;
-    mimeType: string | null;
-    profiles: string | null;
-    width: number | null;
-    height: number | null;
-    serializedManifest: object;
-}
-
-export interface Resync {
-    type: number;
-    dT: number | null;
-    dImax: number | null;
-    dImin: number | null;
-    marker: boolean;
-}
-
-export interface OutputProtection {
-    schemeIdUri: string;
-    value: string | null;
-    robustness: string | null;
-}
-
-export interface ModelPair {
-    bufferTime: number;
-    bandwidth: number;
-}
-
-export interface ExtendedBandwidth {
-    vbr: boolean;
-    modelPairs: ModelPair[];
-}
-
-export interface Representation {
-    id: string;
-    codecs: string;
-    bandwidth: number;
-    width: number;
-    height: number;
-    frameRate: string | null;
-    sar: string | null;
-    mimeType: string | null;
-    profiles: string | null;
-    qualityRanking: number | null;
-    selectionPriority: number;
-    codingDependency: boolean | null;
-    scanType: 'progressive' | 'interlaced' | 'unknown' | null;
-    dependencyId: string | null;
-    associationId: string | null;
-    associationType: string | null;
-    segmentProfiles: string | null;
-    mediaStreamStructureId: string | null;
-    maximumSAPPeriod: number | null;
-    startWithSAP: number | null;
-    maxPlayoutRate: number | null;
-    tag: string | null;
-    eptDelta: number | null;
-    pdDelta: number | null;
-    representationIndex: URLType | null;
-    failoverContent: FailoverContent | null;
-    audioChannelConfigurations: AudioChannelConfiguration[];
-    framePackings: Descriptor[];
-    ratings: Descriptor[];
-    viewpoints: Descriptor[];
-    accessibility: Descriptor[];
-    labels: Label[];
-    groupLabels: Label[];
-    subRepresentations: SubRepresentation[];
-    resyncs: Resync[];
-    outputProtection: OutputProtection | null;
-    extendedBandwidth: ExtendedBandwidth | null;
-    videoRange?: string;
-    stableVariantId: string | null;
-    pathwayId: string | null;
-    supplementalCodecs: string | null;
-    reqVideoLayout: string | null;
-    serializedManifest: object;
-}
-
-export interface ContentProtection {
-    schemeIdUri: string;
-    system: string;
-    defaultKid: string | null;
-    robustness: string | null;
-}
-
-export interface ContentComponent {
-    id: string | null;
-    lang: string | null;
-    contentType: string | null;
-    par: string | null;
-    tag: string | null;
-    accessibility: Descriptor[];
-    roles: Descriptor[];
-    ratings: Descriptor[];
-    viewpoints: Descriptor[];
-    serializedManifest: object;
-}
-
-export interface AdaptationSet {
-    id: string;
-    contentType: string;
-    lang: string;
-    mimeType: string;
-    profiles: string | null;
-    group: number | null;
-    bitstreamSwitching: boolean | null;
-    segmentAlignment: boolean;
-    maxWidth: number | null;
-    maxHeight: number | null;
-    maxFrameRate: string | null;
-    representations: Representation[];
-    contentProtection: ContentProtection[];
-    framePackings: Descriptor[];
-    ratings: Descriptor[];
-    viewpoints: Descriptor[];
-    accessibility: Descriptor[];
-    labels: Label[];
-    groupLabels: Label[];
-    roles: Descriptor[];
-    contentComponents: ContentComponent[];
-    resyncs: Resync[];
-    outputProtection: OutputProtection | null;
-    stableRenditionId: string | null;
-    bitDepth: number | null;
-    sampleRate: number | null;
-    channels: string | null;
-    assocLanguage: string | null;
-    characteristics: string[] | null;
-    forced: boolean;
-    serializedManifest: object;
-}
-
-export interface Event {
-    startTime: number;
-    duration: number;
-    message: string;
-    messageData: string | null;
-    type: string;
-    cue: string | null;
-    scte35?: object;
-}
-
-export interface EventStream {
-    schemeIdUri: string;
-    value: string | null;
-    timescale: number;
-    presentationTimeOffset: number;
-    events: Event[];
-}
-
-export interface AssetIdentifier {
-    schemeIdUri: string;
-    value: string | null;
-}
-
-export interface Subset {
-    contains: string[];
-    id: string | null;
-}
-
-export interface Preselection {
-    id: string;
-    preselectionComponents: string[];
-    lang: string | null;
-    order: 'undefined' | 'time-ordered' | 'fully-ordered';
-    accessibility: Descriptor[];
-    roles: Descriptor[];
-    ratings: Descriptor[];
-    viewpoints: Descriptor[];
-    serializedManifest: object;
-}
-
-export interface Latency {
-    min: number | null;
-    max: number | null;
-    target: number | null;
-    referenceId: number | null;
-}
-
-export interface PlaybackRate {
-    min: number | null;
-    max: number | null;
-}
-
-export interface ServiceDescription {
-    id: string;
-    scopes: Descriptor[];
-    latencies: Latency[];
-    playbackRates: PlaybackRate[];
-    serializedManifest: object;
-}
-
-export interface Period {
-    id: string;
-    start: number;
-    duration: number;
-    bitstreamSwitching: boolean | null;
-    assetIdentifier: AssetIdentifier | null;
-    adaptationSets: AdaptationSet[];
-    subsets: Subset[];
-    preselections: Preselection[];
-    serviceDescriptions: ServiceDescription[];
-    eventStreams: EventStream[];
-    events: Event[];
-    serializedManifest: object;
-}
-
-export interface ProgramInformation {
-    title: string | null;
-    source: string | null;
-    copyright: string | null;
-    lang: string | null;
-    moreInformationURL: string | null;
-}
-
-export interface Metrics {
-    metrics: string;
-    ranges: object[];
-    reportings: Descriptor[];
-}
-
-export interface VideoTrackSummary {
-    id: string;
-    profiles: string | null;
-    bitrateRange: string;
-    resolutions: string[];
-    codecs: string[];
-    scanType: string | null;
-    videoRange: string | null;
-    roles: string[];
-}
-
-export interface AudioTrackSummary {
-    id: string;
-    lang: string | null;
-    codecs: string[];
-    channels: string | null;
-    isDefault: boolean;
-    isForced: boolean;
-    roles: string[];
-}
-
-export interface TextTrackSummary {
-    id: string;
-    lang: string | null;
-    codecsOrMimeTypes: string[];
-    isDefault: boolean;
-    isForced: boolean;
-    roles: string[];
-}
-
-export interface PeriodSummary {
-    id: string;
-    start: number;
-    duration: number | null;
-    videoTracks: AdaptationSet[];
-    audioTracks: AdaptationSet[];
-    textTracks: AdaptationSet[];
-}
-
-export interface ManifestSummary {
-    general: {
-        protocol: 'DASH' | 'HLS';
-        streamType: 'Live / Dynamic' | 'VOD / Static';
-        streamTypeColor: 'text-red-400' | 'text-blue-400';
-        duration: number | null;
-        segmentFormat: string;
-        title: string | null;
-        locations: string[];
-        segmenting: string;
-    };
-    dash: {
-        profiles: string;
-        minBufferTime: number | null;
-        timeShiftBufferDepth: number | null;
-        minimumUpdatePeriod: number | null;
-        availabilityStartTime: Date | null;
-        publishTime: Date | null;
-    } | null;
-    hls: {
-        version: number;
-        targetDuration: number | null;
-        iFramePlaylists: number;
-        mediaPlaylistDetails: {
-            segmentCount: number;
-            averageSegmentDuration: number | null;
-            hasDiscontinuity: boolean;
-            isIFrameOnly: boolean;
-        } | null;
-    } | null;
-    lowLatency: {
-        isLowLatency: boolean;
-        partTargetDuration: number | null;
-        partHoldBack: number | null;
-        canBlockReload: boolean;
-        targetLatency: number | null;
-        minLatency: number | null;
-        maxLatency: number | null;
-    } | null;
-    content: {
-        totalPeriods: number;
-        totalVideoTracks: number;
-        totalAudioTracks: number;
-        totalTextTracks: number;
-        mediaPlaylists: number;
-        periods: PeriodSummary[];
-    };
-    videoTracks: VideoTrackSummary[];
-    audioTracks: AudioTrackSummary[];
-    textTracks: TextTrackSummary[];
-    security: {
-        isEncrypted: boolean;
-        systems: string[];
-        kids: string[];
-    } | null;
-}
-
-export interface InitializationSet {
-    id: string;
-    inAllPeriods: boolean;
-    contentType: string | null;
-    initialization: string | null;
-    codecs: string | null;
-    serializedManifest: object;
-}
-
-export interface Manifest {
-    id: string | null;
-    type: 'static' | 'dynamic';
-    profiles: string;
-    minBufferTime: number;
-    publishTime: Date | null;
-    availabilityStartTime: Date | null;
-    timeShiftBufferDepth: number | null;
-    minimumUpdatePeriod: number | null;
-    duration: number | null;
-    maxSegmentDuration: number | null;
-    maxSubsegmentDuration: number | null;
-    programInformations: ProgramInformation[];
-    metrics: Metrics[];
-    locations: string[];
-    patchLocations: string[];
-    serviceDescriptions: ServiceDescription[];
-    initializationSets: InitializationSet[];
-    segmentFormat: 'isobmff' | 'ts' | 'unknown';
-    events: Event[];
-    periods: Period[];
-    serializedManifest: Element | object;
-    summary: ManifestSummary | null;
-    serverControl: object | null;
-    hlsDefinedVariables?: Map<string, { value: string; source: string }>;
-    tags?: any[];
-    isMaster?: boolean;
-    variants?: any[];
-    segments?: any[];
-    preloadHints?: any[];
-    renditionReports?: any[];
-    partInf?: any;
-}
-
-export type MediaPlaylist = {
-    manifest: Manifest;
-    rawManifest: string;
-    lastFetched: Date;
-};
-
-export interface FeatureAnalysisResult {
-    used: boolean;
-    details: string;
-}
-
-export interface FeatureAnalysisState {
-    results: Map<string, FeatureAnalysisResult>;
-    manifestCount: number;
-}
-
-export interface HlsVariantState {
-    segments: object[];
-    freshSegmentUrls: Set<string>;
-    isLoading: boolean;
-    isPolling: boolean;
-    isExpanded: boolean;
-    displayMode: 'all' | 'last10';
-    error: string | null;
-}
-
-export interface DashRepresentationState {
-    segments: object[];
-    freshSegmentUrls: Set<string>;
-}
-
-export interface ComplianceResult {
-    id: string;
-    text: string;
-    status: 'pass' | 'fail' | 'warn' | 'info';
-    details: string;
-    isoRef: string;
-    category: string;
-    location: { startLine?: number; endLine?: number; path?: string };
-}
-
-export interface ManifestUpdate {
-    timestamp: string;
-    diffHtml: string;
-    rawManifest: string;
-    complianceResults: ComplianceResult[];
-    hasNewIssues: boolean;
-    serializedManifest: object;
-}
-
-export interface DecodedNalUnit {
-    type: string;
-    size: number;
-}
-
-export interface DecodedH264Sample {
-    format: 'H.264';
-    frameType: 'key' | 'delta';
-    duration: number;
-    timestamp: number;
-    nalUnits: DecodedNalUnit[];
-}
-
-export interface DecodedAacFrame {
-    format: 'AAC';
-    objectType: string;
-    samplingFrequency: number;
-    channelCount: number;
-    frameLength: number;
-}
-
-export type DecodedSample = DecodedH264Sample | DecodedAacFrame;
-
-export interface Stream {
-    id: number;
-    name: string;
-    originalUrl: string;
-    baseUrl: string;
-    protocol: 'dash' | 'hls' | 'unknown';
-    isPolling: boolean;
-    manifest: Manifest | null;
-    rawManifest: string;
-    steeringInfo: object | null;
-    manifestUpdates: ManifestUpdate[];
-    activeManifestUpdateIndex: number;
-    mediaPlaylists: Map<string, MediaPlaylist>;
-    activeMediaPlaylistUrl: string | null;
-    featureAnalysis: FeatureAnalysisState;
-    hlsVariantState: Map<string, HlsVariantState>;
-    dashRepresentationState: Map<string, DashRepresentationState>;
-    hlsDefinedVariables?: Map<string, { value: string; source: string }>;
-    semanticData: Map<string, any>;
-    coverageReport?: CoverageFinding[];
-}
-
-export type SerializedStream = Omit<
-    Stream,
-    | 'mediaPlaylists'
-    | 'featureAnalysis'
-    | 'hlsVariantState'
-    | 'dashRepresentationState'
-    | 'hlsDefinedVariables'
-    | 'semanticData'
-> & {
-    mediaPlaylists: [string, MediaPlaylist][];
-    featureAnalysis: {
-        results: [string, FeatureAnalysisResult][];
-        manifestCount: number;
-    };
-    hlsVariantState: [string, HlsVariantState][];
-    dashRepresentationState: [string, DashRepresentationState][];
-    hlsDefinedVariables: [string, { value: string; source: string }][];
-    semanticData: [string, any][];
-    coverageReport: CoverageFinding[];
-};
-
-export interface CoverageFinding {
-    status: 'unparsed' | 'drift';
-    pathOrLine: string;
-    type: 'element' | 'attribute' | 'tag' | 'property';
-    name: string;
-    details: string;
-    lineNumber?: number;
-}
diff --git a/js/data/example-streams.js b/js/data/example-streams.js
deleted file mode 100644
index ec176b6..0000000
--- a/js/data/example-streams.js
+++ /dev/null
@@ -1,224 +0,0 @@
-/**
- * A curated list of public DASH & HLS streams for testing and demonstration purposes.
- * @typedef {'dash' | 'hls'} Protocol
- * @typedef {'vod' | 'live'} StreamType
- * @typedef {object} ExampleStream
- * @property {string} name
- * @property {string} url
- * @property {Protocol} protocol
- * @property {StreamType} type
- * @property {string} source - The original source of the stream.
- */
-
-/** @type {ExampleStream[]} */
-export const exampleStreams = [
-    // --- DASH VOD (Source: dashif.org) ---
-    {
-        name: '[DASH-IF] Big Buck Bunny, onDemand',
-        url: 'https://dash.akamaized.net/akamai/bbb_30fps/bbb_30fps.mpd',
-        protocol: 'dash',
-        type: 'vod',
-        source: 'dashif.org',
-    },
-    {
-        name: '[DASH-IF] SegmentBase, onDemand',
-        url: 'https://dash.akamaized.net/dash264/TestCases/1a/sony/SNE_DASH_SD_CASE1A_REVISED.mpd',
-        protocol: 'dash',
-        type: 'vod',
-        source: 'dashif.org',
-    },
-    {
-        name: '[DASH-IF] Multi-period, 2 periods',
-        url: 'https://dash.akamaized.net/dash264/TestCases/5a/nomor/1.mpd',
-        protocol: 'dash',
-        type: 'vod',
-        source: 'dashif.org',
-    },
-    {
-        name: '[DASH-IF] Envivio, SegmentTemplate/Number',
-        url: 'https://dash.akamaized.net/envivio/EnvivioDash3/manifest.mpd',
-        protocol: 'dash',
-        type: 'vod',
-        source: 'dashif.org',
-    },
-    {
-        name: '[Axinom] H.264, CMAF, Clear',
-        url: 'https://media.axprod.net/TestVectors/v7-Clear/Manifest.mpd',
-        protocol: 'dash',
-        type: 'vod',
-        source: 'Axinom',
-    },
-    {
-        name: '[Axinom] Multi-key, Widevine/PlayReady DRM',
-        url: 'https://media.axprod.net/TestVectors/v7-MultiDRM-MultiKey/Manifest.mpd',
-        protocol: 'dash',
-        type: 'vod',
-        source: 'Axinom',
-    },
-    // --- DASH Live (Source: dashif.org) ---
-    {
-        name: '[DASH-IF] Live Sim (SegmentTemplate)',
-        url: 'https://livesim.dashif.org/livesim/testpic_2s/Manifest.mpd',
-        protocol: 'dash',
-        type: 'live',
-        source: 'dashif.org',
-    },
-    {
-        name: '[DASH-IF] Live Sim (SegmentTimeline)',
-        url: 'https://livesim.dashif.org/livesim/segtimeline_1/testpic_2s/Manifest.mpd',
-        protocol: 'dash',
-        type: 'live',
-        source: 'dashif.org',
-    },
-    {
-        name: '[DASH-IF] Live Sim (SCTE-35 Events)',
-        url: 'https://livesim.dashif.org/livesim/scte35_2/testpic_2s/Manifest.mpd',
-        protocol: 'dash',
-        type: 'live',
-        source: 'dashif.org',
-    },
-    {
-        name: '[DASH-IF] Live Sim (Low-Latency Chunked)',
-        url: 'https://livesim.dashif.org/livesim-chunked/testpic_2s/Manifest.mpd',
-        protocol: 'dash',
-        type: 'live',
-        source: 'dashif.org',
-    },
-    {
-        name: '[AWS] Live w/ Ad Breaks',
-        url: 'https://d2qohgpffhaffh.cloudfront.net/HLS/vanlife/withad/sdr_wide/master.mpd',
-        protocol: 'dash',
-        type: 'live',
-        source: 'AWS',
-    },
-    {
-        name: '[Unified Streaming] Live w/ SCTE-35 markers',
-        url: 'https://demo.unified-streaming.com/k8s/live/scte35.isml/.mpd',
-        protocol: 'dash',
-        type: 'live',
-        source: 'Unified Streaming',
-    },
-
-    // --- HLS VOD ---
-    {
-        name: '[HLS.js] Big Buck Bunny, Adaptive',
-        url: 'https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8',
-        protocol: 'hls',
-        type: 'vod',
-        source: 'hls.js',
-    },
-    {
-        name: '[HLS.js] Big Buck Bunny, 480p',
-        url: 'https://test-streams.mux.dev/x36xhzz/url_6/193039199_mp4_h264_aac_hq_7.m3u8',
-        protocol: 'hls',
-        type: 'vod',
-        source: 'hls.js',
-    },
-    {
-        name: '[HLS.js] fMP4, Multiple Audio Tracks',
-        url: 'https://storage.googleapis.com/shaka-demo-assets/angel-one-hls/hls.m3u8',
-        protocol: 'hls',
-        type: 'vod',
-        source: 'hls.js',
-    },
-    {
-        name: '[HLS.js] AES-128 Encrypted',
-        url: 'https://playertest.longtailvideo.com/adaptive/oceans_aes/oceans_aes.m3u8',
-        protocol: 'hls',
-        type: 'vod',
-        source: 'hls.js',
-    },
-    {
-        name: '[HLS.js] AES-128 Encrypted, TS main with AAC',
-        url: 'https://playertest.longtailvideo.com/adaptive/aes-with-tracks/master.m3u8',
-        protocol: 'hls',
-        type: 'vod',
-        source: 'hls.js',
-    },
-    {
-        name: '[HLS.js] Ad-insertion in Event Stream',
-        url: 'https://test-streams.mux.dev/dai-discontinuity-deltatre/manifest.m3u8',
-        protocol: 'hls',
-        type: 'vod',
-        source: 'hls.js',
-    },
-    {
-        name: '[HLS.js] Subtitles/Captions',
-        url: 'https://playertest.longtailvideo.com/adaptive/captions/playlist.m3u8',
-        protocol: 'hls',
-        type: 'vod',
-        source: 'hls.js',
-    },
-    {
-        name: '[HLS.js] ARTE China, ABR',
-        url: 'https://test-streams.mux.dev/test_001/stream.m3u8',
-        protocol: 'hls',
-        type: 'vod',
-        source: 'hls.js',
-    },
-    {
-        name: '[HLS.js] MP3 VOD',
-        url: 'https://playertest.longtailvideo.com/adaptive/vod-with-mp3/manifest.m3u8',
-        protocol: 'hls',
-        type: 'vod',
-        source: 'hls.js',
-    },
-    {
-        name: '[HLS.js] DK Turntable, PTS shifted',
-        url: 'https://test-streams.mux.dev/pts_shift/master.m3u8',
-        protocol: 'hls',
-        type: 'vod',
-        source: 'hls.js',
-    },
-    {
-        name: '[Apple] Bip-Bop, Advanced HEVC+AVC',
-        url: 'https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_adv_example_hevc/master.m3u8',
-        protocol: 'hls',
-        type: 'vod',
-        source: 'Apple',
-    },
-    {
-        name: '[JW Player] FDR, CDN packaged',
-        url: 'https://cdn.jwplayer.com/manifests/pZxWPRg4.m3u8',
-        protocol: 'hls',
-        type: 'vod',
-        source: 'JW Player',
-    },
-    {
-        name: '[Bitmovin] fMP4',
-        url: 'https://bitdash-a.akamaihd.net/content/MI201109210084_1/m3u8s-fmp4/f08e80da-bf1d-4e3d-8899-f0f6155f6efa.m3u8',
-        protocol: 'hls',
-        type: 'vod',
-        source: 'Bitmovin',
-    },
-    {
-        name: '[Shaka] Angel One, Widevine DRM (fMP4)',
-        url: 'https://storage.googleapis.com/shaka-demo-assets/angel-one-widevine-hls/hls.m3u8',
-        protocol: 'hls',
-        type: 'vod',
-        source: 'Shaka',
-    },
-    {
-        name: "[Wowza] Elephant's Dream, Alt Audio + VTT",
-        url: 'https://playertest.longtailvideo.com/adaptive/elephants_dream_v4/index.m3u8',
-        protocol: 'hls',
-        type: 'vod',
-        source: 'Wowza',
-    },
-
-    // --- HLS Live ---
-    {
-        name: '[Mux] Low-Latency HLS (fMP4)',
-        url: 'https://stream.mux.com/v69RSHhFelSm4701snP22dYz2jICy4E4FUyk02rW4gxRM.m3u8',
-        protocol: 'hls',
-        type: 'live',
-        source: 'Mux',
-    },
-    {
-        name: '[Unified Streaming] Tears of Steel',
-        url: 'https://demo.unified-streaming.com/k8s/features/stable/video/tears-of-steel/tears-of-steel.ism/.m3u8',
-        protocol: 'hls',
-        type: 'live',
-        source: 'Unified Streaming',
-    },
-];
diff --git a/js/domain/cmaf/profile-validator.js b/js/domain/cmaf/profile-validator.js
deleted file mode 100644
index 97d04d6..0000000
--- a/js/domain/cmaf/profile-validator.js
+++ /dev/null
@@ -1,156 +0,0 @@
-/**
- * @typedef {import('./rules.js').CmafRuleResult} CmafRuleResult
- */
-
-const findBox = (boxes, type) => {
-    for (const box of boxes) {
-        if (box.type === type) return box;
-        if (box.children?.length > 0) {
-            const found = findBox(box.children, type);
-            if (found) return found;
-        }
-    }
-    return null;
-};
-
-/**
- * Validates constraints for the 'cmf2' structural brand.
- * @param {object} initData - The parsed initialization segment data.
- * @returns {CmafRuleResult | null}
- */
-function validateCmf2(initData) {
-    const trak = findBox(initData.boxes, 'trak');
-    const vmhd = findBox(initData.boxes, 'vmhd');
-    const isVideo = !!vmhd;
-
-    // Rule only applies to video tracks.
-    if (!isVideo) {
-        return null;
-    }
-
-    const elst = findBox(trak.children, 'elst');
-    const pass = !elst;
-
-    return {
-        id: 'CMAF-PROFILE-CMF2-ELST',
-        text: "'cmf2' Profile: Video tracks must not contain an Edit List ('elst') box",
-        isoRef: 'Clause 7.7.2',
-        status: pass ? 'pass' : 'fail',
-        details: pass
-            ? 'OK: No Edit List box found in video track.'
-            : 'FAIL: An Edit List (`elst`) box was found, which is prohibited for video tracks under the `cmf2` profile.',
-    };
-}
-
-/**
- * Validates constraints for the 'caac' (AAC Core) media profile.
- * @param {object} initData - The parsed initialization segment data.
- * @returns {CmafRuleResult | null}
- */
-function validateCaac(initData) {
-    const esds = findBox(initData.boxes, 'esds');
-    if (!esds) {
-        return {
-            id: 'CMAF-PROFILE-CAAC-ESDS',
-            text: "'caac' Profile: An 'esds' box must be present in the sample entry",
-            isoRef: 'Clause 10.3.4.2.2',
-            status: 'fail',
-            details:
-                'FAIL: The AudioSampleEntry for an AAC track must contain an Elementary Stream Descriptor (esds) box.',
-        };
-    }
-
-    const audioObjectType = esds.details?.decoded_audio_object_type?.value;
-    const channelConfig = esds.details?.decoded_channel_configuration?.value;
-
-    const channelCount = parseInt(channelConfig?.match(/\d+/)?.[0] || '0', 10);
-
-    const aotPass =
-        audioObjectType &&
-        (audioObjectType.includes('AAC LC') || audioObjectType.includes('SBR'));
-    const channelPass = channelCount > 0 && channelCount <= 2;
-
-    const details = [];
-    if (!aotPass)
-        details.push(
-            `Invalid AudioObjectType: found ${audioObjectType}. Expected AAC-LC or HE-AAC.`
-        );
-    if (!channelPass)
-        details.push(
-            `Invalid channel configuration: found ${channelCount} channels, max is 2.`
-        );
-
-    const pass = aotPass && channelPass;
-
-    return {
-        id: 'CMAF-PROFILE-CAAC-PARAMS',
-        text: "'caac' Profile: Validate audio parameters (AOT, channels)",
-        isoRef: 'Clause 10.4',
-        status: pass ? 'pass' : 'fail',
-        details: pass
-            ? 'OK: Audio parameters conform to AAC Core profile.'
-            : `FAIL: ${details.join(' ')}`,
-    };
-}
-
-/**
- * Validates constraints for the 'im1t' (IMSC1 Text) media profile.
- * @param {object} initData - The parsed initialization segment data.
- * @returns {CmafRuleResult | null}
- */
-function validateIm1t(initData) {
-    const stpp = findBox(initData.boxes, 'stpp');
-    if (!stpp) return null; // Not a subtitle track
-
-    const mime = findBox(stpp.children, 'mime');
-    if (!mime) {
-        return {
-            id: 'CMAF-PROFILE-IM1T-MIME',
-            text: "'im1t' Profile: A 'mime' box must be present in the 'stpp' sample entry",
-            isoRef: 'Clause 11.3.2',
-            status: 'fail',
-            details:
-                'FAIL: The XMLSubtitleSampleEntry (`stpp`) for an IMSC1 track must contain a MIME Type (`mime`) box.',
-        };
-    }
-
-    const contentType = mime.details?.content_type?.value || '';
-    const pass = contentType.includes('codecs=im1t');
-
-    return {
-        id: 'CMAF-PROFILE-IM1T-CODEC',
-        text: "'im1t' Profile: MIME type must declare 'im1t' codec",
-        isoRef: 'Clause 11.3.3',
-        status: pass ? 'pass' : 'fail',
-        details: pass
-            ? 'OK: `codecs=im1t` found in MIME box.'
-            : `FAIL: Expected 'codecs=im1t' in MIME box, but found '${contentType}'.`,
-    };
-}
-
-/**
- * Orchestrates validation against all declared CMAF profiles.
- * @param {string[]} brands - A list of CMAF-related brands from the ftyp box.
- * @param {object} initData - The parsed initialization segment data.
- * @returns {CmafRuleResult[]} An array of validation results.
- */
-export function validateCmafProfiles(brands, initData) {
-    const results = [];
-
-    if (brands.includes('cmf2')) {
-        const result = validateCmf2(initData);
-        if (result) results.push(result);
-    }
-
-    if (brands.includes('caac')) {
-        const result = validateCaac(initData);
-        if (result) results.push(result);
-    }
-
-    if (brands.includes('im1t')) {
-        const result = validateIm1t(initData);
-        if (result) results.push(result);
-    }
-
-    return results;
-}
diff --git a/js/domain/cmaf/rules.js b/js/domain/cmaf/rules.js
deleted file mode 100644
index 9c08b71..0000000
--- a/js/domain/cmaf/rules.js
+++ /dev/null
@@ -1,256 +0,0 @@
-/**
- * @typedef {object} CmafRuleResult
- * @property {string} id - A unique identifier for the rule.
- * @property {string} text - The human-readable title of the check.
- * @property {string} isoRef - The reference to the ISO/IEC 23000-19:2020(E) standard clause.
- * @property {'pass' | 'fail' | 'warn'} status - The result of the check.
- * @property {string} details - A detailed message about the result.
- */
-
-const findBox = (boxes, type) => {
-    for (const box of boxes) {
-        if (box.type === type) return box;
-        if (box.children?.length > 0) {
-            const found = findBox(box.children, type);
-            if (found) return found;
-        }
-    }
-    return null;
-};
-
-/** @type {Array<(initData: object, mediaData: object) => CmafRuleResult>} */
-export const cmafTrackRules = [
-    // --- CMAF Header Rules (on init segment) ---
-    (initData) => {
-        const mvhd = findBox(initData.boxes, 'mvhd');
-        const pass = mvhd?.details?.duration?.value === 0;
-        return {
-            id: 'CMAF-HEADER-MVHD-DUR',
-            text: 'Movie Header (mvhd) duration must be 0',
-            isoRef: 'Clause 7.5.1',
-            status: pass ? 'pass' : 'fail',
-            details: pass
-                ? 'OK'
-                : `mvhd.duration was ${mvhd?.details?.duration?.value}, expected 0.`,
-        };
-    },
-    (initData) => {
-        const tkhd = findBox(initData.boxes, 'tkhd');
-        const pass = tkhd?.details?.duration?.value === 0;
-        return {
-            id: 'CMAF-HEADER-TKHD-DUR',
-            text: 'Track Header (tkhd) duration must be 0',
-            isoRef: 'Clause 7.5.4',
-            status: pass ? 'pass' : 'fail',
-            details: pass
-                ? 'OK'
-                : `tkhd.duration was ${tkhd?.details?.duration?.value}, expected 0.`,
-        };
-    },
-    (initData) => {
-        const mvex = findBox(initData.boxes, 'mvex');
-        const pass = !!mvex;
-        return {
-            id: 'CMAF-HEADER-MVEX',
-            text: 'Movie Extends (mvex) box must be present',
-            isoRef: 'Clause 7.3.2.1',
-            status: pass ? 'pass' : 'fail',
-            details: pass ? 'OK' : 'mvex box not found in moov.',
-        };
-    },
-    (initData) => {
-        const trex = findBox(initData.boxes, 'trex');
-        const pass = !!trex;
-        return {
-            id: 'CMAF-HEADER-TREX',
-            text: 'Track Extends (trex) box must be present',
-            isoRef: 'Clause 7.5.14',
-            status: pass ? 'pass' : 'fail',
-            details: pass ? 'OK' : 'trex box not found in mvex for the track.',
-        };
-    },
-    // --- CMAF Fragment Rules (on media segment) ---
-    (initData, mediaData) => {
-        const moof = findBox(mediaData.boxes, 'moof');
-        const trafCount = moof?.children?.filter(
-            (c) => c.type === 'traf'
-        ).length;
-        const pass = trafCount === 1;
-        return {
-            id: 'CMAF-FRAG-MOOF-TRAF',
-            text: 'Movie Fragment (moof) must contain exactly one Track Fragment (traf)',
-            isoRef: 'Clause 7.3.2.3.b',
-            status: pass ? 'pass' : 'fail',
-            details: pass ? 'OK' : `Found ${trafCount} traf boxes, expected 1.`,
-        };
-    },
-    (initData, mediaData) => {
-        const tfhd = findBox(mediaData.boxes, 'tfhd');
-        const flags = tfhd?.details?.flags?.value;
-        const baseDataOffsetPresent = flags
-            ? (parseInt(flags, 16) & 0x1) !== 0
-            : false;
-        const defaultBaseIsMoof = flags
-            ? (parseInt(flags, 16) & 0x20000) !== 0
-            : false;
-        const pass = !baseDataOffsetPresent && defaultBaseIsMoof;
-        return {
-            id: 'CMAF-FRAG-TFHD-FLAGS',
-            text: 'Track Fragment Header (tfhd) flags must be set for fragment-relative addressing',
-            isoRef: 'Clause 7.5.16',
-            status: pass ? 'pass' : 'fail',
-            details: pass
-                ? 'OK'
-                : `base-data-offset-present=${baseDataOffsetPresent} (expected false), default-base-is-moof=${defaultBaseIsMoof} (expected true).`,
-        };
-    },
-    (initData, mediaData) => {
-        const traf = findBox(mediaData.boxes, 'traf');
-        const tfdt = traf?.children.find((c) => c.type === 'tfdt');
-        const pass = !!tfdt;
-        return {
-            id: 'CMAF-FRAG-TFDT',
-            text: 'Track Fragment (traf) must contain a Track Fragment Decode Time (tfdt) box',
-            isoRef: 'Clause 7.5.16',
-            status: pass ? 'pass' : 'fail',
-            details: pass ? 'OK' : 'tfdt box not found in traf.',
-        };
-    },
-    (initData, mediaData) => {
-        const trun = findBox(mediaData.boxes, 'trun');
-        const flags = trun?.details?.flags?.value;
-        const dataOffsetPresent = flags
-            ? (parseInt(flags, 16) & 0x1) !== 0
-            : false;
-        const pass = dataOffsetPresent;
-        return {
-            id: 'CMAF-FRAG-TRUN-OFFSET',
-            text: 'Track Run (trun) must have data-offset-present flag set',
-            isoRef: 'Clause 7.5.17',
-            status: pass ? 'pass' : 'fail',
-            details: pass
-                ? 'OK'
-                : 'trun data-offset-present flag was not set to true.',
-        };
-    },
-    // --- CMAF Chunk Rules (Low-Latency) ---
-    (initData, mediaData) => {
-        const moofs = mediaData.boxes.filter((b) => b.type === 'moof');
-        if (moofs.length <= 1) return null; // Rule is for multi-chunk segments
-
-        const firstTfhd = findBox(moofs[0].children, 'tfhd');
-        if (!firstTfhd) return null;
-        const baselineTrackId = firstTfhd.details.track_ID.value;
-
-        for (let i = 1; i < moofs.length; i++) {
-            const currentTfhd = findBox(moofs[i].children, 'tfhd');
-            if (
-                !currentTfhd ||
-                currentTfhd.details.track_ID.value !== baselineTrackId
-            ) {
-                return {
-                    id: 'CMAF-CHUNK-CONSISTENCY',
-                    text: 'All chunks in a segment must belong to the same track',
-                    isoRef: 'Best Practice',
-                    status: 'fail',
-                    details: `FAIL: Chunk ${i + 1} (moof @ offset ${
-                        moofs[i].offset
-                    }) has track_ID ${
-                        currentTfhd?.details.track_ID.value
-                    }, but expected ${baselineTrackId}.`,
-                };
-            }
-        }
-
-        return {
-            id: 'CMAF-CHUNK-CONSISTENCY',
-            text: 'All chunks in a segment must belong to the same track',
-            isoRef: 'Best Practice',
-            status: 'pass',
-            details: 'OK: All chunks have a consistent track_ID.',
-        };
-    },
-    // --- Common Encryption (CENC) Rules ---
-    (initData) => {
-        const schm = findBox(initData.boxes, 'schm');
-        const tenc = findBox(initData.boxes, 'tenc');
-        if (!schm || !tenc) return null; // Rule is not applicable if track is not encrypted
-
-        const isCencScheme = schm.details.scheme_type.value === 'cenc';
-        if (!isCencScheme) return null;
-
-        const ivSize = tenc.details.default_Per_Sample_IV_Size?.value;
-        const pass = ivSize === 8;
-
-        return {
-            id: 'CMAF-CENC-IV-SIZE',
-            text: "For 'cenc' scheme, default_Per_Sample_IV_Size must be 8",
-            isoRef: 'Clause 8.2.3.1',
-            status: pass ? 'pass' : 'fail',
-            details: pass
-                ? `OK: IV size is ${ivSize}.`
-                : `FAIL: default_Per_Sample_IV_Size was ${ivSize}, but CMAF requires 8 for the 'cenc' scheme.`,
-        };
-    },
-    (initData, mediaData) => {
-        const sinf = findBox(initData.boxes, 'sinf');
-        if (!sinf) return null;
-
-        const traf = findBox(mediaData.boxes, 'traf');
-        const saio = findBox(traf?.children || [], 'saio');
-        const saiz = findBox(traf?.children || [], 'saiz');
-        const pass = !!saio && !!saiz;
-
-        return {
-            id: 'CMAF-CENC-AUX-INFO',
-            text: 'Encrypted fragments must contain Sample Auxiliary Information boxes (saio, saiz)',
-            isoRef: 'Clause 8.2.2.1',
-            status: pass ? 'pass' : 'fail',
-            details: pass
-                ? 'OK: Found both saio and saiz boxes in the track fragment.'
-                : `FAIL: Missing required auxiliary info boxes. Found saio: ${!!saio}, Found saiz: ${!!saiz}.`,
-        };
-    },
-    (initData, mediaData) => {
-        const schm = findBox(initData.boxes, 'schm');
-        const senc = findBox(mediaData.boxes, 'senc');
-
-        if (
-            !schm ||
-            schm.details.scheme_type.value !== 'cenc' ||
-            !senc ||
-            !senc.samples
-        ) {
-            return null; // Rule applies only to 'cenc' scheme with parsed senc samples
-        }
-
-        let failingSampleIndex = -1;
-        let failingSubsampleIndex = -1;
-
-        for (let i = 0; i < senc.samples.length; i++) {
-            const sample = senc.samples[i];
-            if (sample.subsamples && sample.subsamples.length > 0) {
-                for (let j = 0; j < sample.subsamples.length; j++) {
-                    const subsample = sample.subsamples[j];
-                    if (subsample.BytesOfProtectedData % 16 !== 0) {
-                        failingSampleIndex = i;
-                        failingSubsampleIndex = j;
-                        break;
-                    }
-                }
-            }
-            if (failingSampleIndex !== -1) break;
-        }
-
-        const pass = failingSampleIndex === -1;
-        return {
-            id: 'CMAF-CENC-SUBSAMPLE-ALIGNMENT',
-            text: "For 'cenc' scheme, BytesOfProtectedData must be a multiple of 16",
-            isoRef: 'Clause 8.2.3.1',
-            status: pass ? 'pass' : 'warn', // Standard says "shall", but often violated. Warn is more practical.
-            details: pass
-                ? 'OK: All subsamples have correctly aligned protected regions.'
-                : `FAIL: At least one subsample has a protected data size not a multiple of 16. First failure at sample ${failingSampleIndex + 1}, subsample ${failingSubsampleIndex + 1}.`,
-        };
-    },
-];
diff --git a/js/domain/cmaf/utils.js b/js/domain/cmaf/utils.js
deleted file mode 100644
index 67119b3..0000000
--- a/js/domain/cmaf/utils.js
+++ /dev/null
@@ -1,72 +0,0 @@
-/**
- * Compares two parsed ISOBMFF box objects for equivalence, ignoring specified fields.
- * @param {import('../../infrastructure/segment/isobmff/parser.js').Box} boxA
- * @param {import('../../infrastructure/segment/isobmff/parser.js').Box} boxB
- * @param {string[]} fieldsToIgnore - A list of field names to ignore during comparison.
- * @param {string[]} childBoxesToIgnore - A list of child box types to ignore during comparison.
- * @returns {{areEqual: boolean, differences: string[]}}
- */
-export function compareBoxes(
-    boxA,
-    boxB,
-    fieldsToIgnore = [],
-    childBoxesToIgnore = []
-) {
-    const differences = [];
-    if (boxA.type !== boxB.type) {
-        differences.push(`Box types differ: ${boxA.type} vs ${boxB.type}`);
-        return { areEqual: false, differences };
-    }
-
-    // Compare sizes if not explicitly ignored
-    if (!fieldsToIgnore.includes('size') && boxA.size !== boxB.size) {
-        differences.push(
-            `${boxA.type}.size: '${boxA.size} bytes' vs '${boxB.size} bytes'`
-        );
-    }
-
-    const allKeys = new Set([
-        ...Object.keys(boxA.details),
-        ...Object.keys(boxB.details),
-    ]);
-
-    for (const key of allKeys) {
-        if (fieldsToIgnore.includes(key) || key === 'size') {
-            continue;
-        }
-        const valA = boxA.details[key]?.value;
-        const valB = boxB.details[key]?.value;
-
-        if (JSON.stringify(valA) !== JSON.stringify(valB)) {
-            differences.push(`${boxA.type}.${key}: '${valA}' vs '${valB}'`);
-        }
-    }
-
-    // Compare children, respecting ignores
-    const childrenA = (boxA.children || []).filter(
-        (c) => !childBoxesToIgnore.includes(c.type)
-    );
-    const childrenB = (boxB.children || []).filter(
-        (c) => !childBoxesToIgnore.includes(c.type)
-    );
-
-    if (childrenA.length !== childrenB.length) {
-        differences.push(
-            `Child box count differs in ${boxA.type}: ${childrenA.length} vs ${childrenB.length}`
-        );
-    } else {
-        for (let i = 0; i < childrenA.length; i++) {
-            const childComparison = compareBoxes(
-                childrenA[i],
-                childrenB[i],
-                fieldsToIgnore,
-                childBoxesToIgnore
-            );
-            if (!childComparison.areEqual) {
-                differences.push(...childComparison.differences);
-            }
-        }
-    }
-
-    return { areEqual: differences.length === 0, differences };
-}
diff --git a/js/domain/cmaf/validator.js b/js/domain/cmaf/validator.js
deleted file mode 100644
index 7300cb7..0000000
--- a/js/domain/cmaf/validator.js
+++ /dev/null
@@ -1,207 +0,0 @@
-import { cmafTrackRules } from './rules.js';
-import { compareBoxes } from './utils.js';
-import { validateCmafProfiles } from './profile-validator.js';
-import { resolveBaseUrl } from '../../infrastructure/manifest/dash/recursive-parser.js';
-import { findInitSegmentUrl } from '../../infrastructure/manifest/dash/segment-parser.js';
-
-// Configuration for CMAF Switching Set validation based on ISO/IEC 23000-19:2020(E), Table 11.
-const SWITCHING_SET_BOX_CHECKS = [
-    { box: 'ftyp', ignore: [] },
-    { box: 'mvhd', ignore: ['creation_time', 'modification_time'] },
-    {
-        box: 'tkhd',
-        ignore: ['creation_time', 'modification_time', 'width', 'height'],
-    },
-    { box: 'trex', ignore: [] },
-    { box: 'elst', ignore: [] },
-    { box: 'mdhd', ignore: ['creation_time', 'modification_time'] },
-    { box: 'mehd', ignore: [] },
-    { box: 'hdlr', ignore: [] },
-    { box: 'vmhd', ignore: [] },
-    { box: 'smhd', ignore: [] },
-    { box: 'sthd', ignore: [] },
-    { box: 'dref', ignore: [] },
-    { box: 'stsd', ignore: ['codingname'], childBoxesToIgnore: ['avcC'] },
-    { box: 'pssh', ignore: [] },
-    { box: 'sinf', ignore: [] },
-    { box: 'tenc', ignore: [] },
-];
-
-/**
- * Performs CMAF conformance checks on a single track using pre-fetched segment data.
- * @param {object} initData - The parsed initialization segment data.
- * @param {object} mediaData - The parsed media segment data.
- * @returns {Array<object>} An array of validation results.
- */
-export function validateCmafTrack(initData, mediaData) {
-    const ftyp = initData?.boxes?.find((b) => b.type === 'ftyp');
-    const cmafBrands = ftyp?.details?.cmafBrands?.value?.split(', ') || [];
-
-    if (!cmafBrands.includes('cmfc')) {
-        return [
-            {
-                id: 'CMAF-BRAND',
-                text: 'CMAF Brand Presence',
-                status: 'fail',
-                details:
-                    'The structural brand "cmfc" was not found in the initialization segment\'s ftyp box. This is not a CMAF track.',
-            },
-        ];
-    }
-
-    const brandResult = {
-        id: 'CMAF-BRAND',
-        text: 'CMAF Brand Presence',
-        status: 'pass',
-        details: `Structural brand "cmfc" found. Detected CMAF brands: ${cmafBrands.join(
-            ', '
-        )}`,
-    };
-
-    const trackRuleResults = cmafTrackRules
-        .map((rule) => rule(initData, mediaData))
-        .filter(Boolean);
-    const profileRuleResults = validateCmafProfiles(cmafBrands, initData);
-
-    return [brandResult, ...trackRuleResults, ...profileRuleResults];
-}
-
-const findBoxRecursive = (boxes, type) => {
-    for (const box of boxes) {
-        if (box.type === type) return box;
-        if (box.children?.length > 0) {
-            const found = findBoxRecursive(box.children, type);
-            if (found) return found;
-        }
-    }
-    return null;
-};
-
-/**
- * Performs CMAF Switching Set validation on a stream.
- * @param {import('../../app/types.js').Stream} stream
- * @param {(url: string) => Promise<object>} segmentFetcher - A function to fetch and parse a segment by URL.
- * @returns {Promise<Array<object>>} A promise that resolves to an array of validation results.
- */
-export async function validateCmafSwitchingSets(stream, segmentFetcher) {
-    const results = [];
-    const manifestElement = stream.manifest.serializedManifest;
-
-    for (const period of stream.manifest.periods) {
-        for (const as of period.adaptationSets) {
-            const setId = as.id || `${as.contentType}-${period.id}`;
-            if (as.representations.length <= 1) {
-                results.push({
-                    id: `SS-VALID-${setId}`,
-                    text: `Switching Set: ${setId}`,
-                    status: 'pass',
-                    details: 'OK (Single Representation)',
-                });
-                continue;
-            }
-
-            try {
-                const initSegmentUrls = as.representations.map((rep) => {
-                    const resolvedBaseUrl = resolveBaseUrl(
-                        stream.baseUrl,
-                        manifestElement,
-                        period.serializedManifest,
-                        as.serializedManifest,
-                        rep.serializedManifest
-                    );
-                    return findInitSegmentUrl(rep, as, period, resolvedBaseUrl);
-                });
-
-                const parsedInitSegments = await Promise.all(
-                    initSegmentUrls.map((url) =>
-                        url ? segmentFetcher(url) : Promise.resolve(null)
-                    )
-                );
-
-                const baseInitData = parsedInitSegments[0];
-                if (!baseInitData) {
-                    throw new Error(
-                        'Could not parse initialization segment for baseline representation.'
-                    );
-                }
-
-                let allSetsMatch = true;
-                const differences = [];
-
-                for (let i = 1; i < parsedInitSegments.length; i++) {
-                    const currentRepId = as.representations[i].id;
-                    const currentInitData = parsedInitSegments[i];
-                    if (!currentInitData) {
-                        allSetsMatch = false;
-                        differences.push(
-                            `[Rep ${currentRepId}]: Failed to parse initialization segment.`
-                        );
-                        continue;
-                    }
-
-                    for (const check of SWITCHING_SET_BOX_CHECKS) {
-                        const boxA = findBoxRecursive(
-                            baseInitData.boxes,
-                            check.box
-                        );
-                        const boxB = findBoxRecursive(
-                            currentInitData.boxes,
-                            check.box
-                        );
-
-                        if (!boxA && !boxB) continue;
-                        if (!boxA || !boxB) {
-                            allSetsMatch = false;
-                            differences.push(
-                                `[Rep ${currentRepId}]: Box '${check.box}' presence mismatch.`
-                            );
-                            continue;
-                        }
-
-                        const comparison = compareBoxes(
-                            boxA,
-                            boxB,
-                            check.ignore,
-                            check.childBoxesToIgnore
-                        );
-                        if (!comparison.areEqual) {
-                            allSetsMatch = false;
-                            differences.push(
-                                ...comparison.differences.map(
-                                    (d) => `[Rep ${currentRepId}] ${d}`
-                                )
-                            );
-                        }
-                    }
-                }
-
-                if (allSetsMatch) {
-                    results.push({
-                        id: `SS-VALID-${setId}`,
-                        text: `Switching Set: ${setId}`,
-                        status: 'pass',
-                        details:
-                            'All tracks have compatible headers according to CMAF Table 11.',
-                    });
-                } else {
-                    results.push({
-                        id: `SS-VALID-${setId}`,
-                        text: `Switching Set: ${setId}`,
-                        status: 'fail',
-                        details: `Inconsistencies found: ${differences.join(
-                            '; '
-                        )}`,
-                    });
-                }
-            } catch (e) {
-                results.push({
-                    id: `SS-VALID-${setId}`,
-                    text: `Switching Set: ${setId}`,
-                    status: 'fail',
-                    details: `Error during validation: ${e.message}`,
-                });
-            }
-        }
-    }
-    return results;
-}
diff --git a/js/domain/compliance/engine.js b/js/domain/compliance/engine.js
deleted file mode 100644
index 29d7562..0000000
--- a/js/domain/compliance/engine.js
+++ /dev/null
@@ -1,402 +0,0 @@
-import { rules as dashRules } from '../../infrastructure/manifest/dash/compliance-rules/index.js';
-import { rules as hlsRules } from '../../infrastructure/manifest/hls/compliance-rules/index.js';
-import {
-    findChildren,
-    getAttr,
-    findChildrenRecursive,
-} from '../../infrastructure/manifest/dash/recursive-parser.js';
-
-/**
- * Runs a set of predefined compliance checks against a manifest.
- * @param {object} manifest - The raw manifest element (DASH) or the manifest IR (HLS).
- * @param {'dash' | 'hls'} protocol - The protocol of the manifest.
- * @param {object} [context={}] - Additional context for the checks, including standardVersion or manifestProfiles.
- * @returns {Array<object>} An array of check result objects, now including location data.
- */
-export function runChecks(manifest, protocol, context = {}) {
-    if (protocol === 'hls') {
-        const manifestIR = manifest; // For HLS, we now pass the IR directly.
-        if (!manifestIR || typeof manifestIR.isMaster !== 'boolean') {
-            return [
-                {
-                    text: 'HLS Playlist must be a valid object',
-                    status: 'fail',
-                    details: 'The HLS parser did not return a valid object.',
-                    isoRef: 'N/A',
-                    category: 'HLS Structure',
-                    location: { startLine: 1, endLine: 1 },
-                },
-            ];
-        }
-
-        const standardVersion = context.standardVersion || 13; // Default to latest
-        const applicableRules = hlsRules.filter(
-            (rule) => rule.version <= standardVersion
-        );
-        const results = [];
-        const isLive = manifestIR.type === 'dynamic';
-        const version = manifestIR.hls?.version || 1;
-        const targetDuration = manifestIR.hls?.targetDuration || null;
-        const hlsContext = {
-            isLive,
-            version,
-            targetDuration,
-            hlsParsed: manifestIR, // Pass IR for context
-            standardVersion, // Pass the selected standard version
-            ...context,
-        };
-
-        const runRule = (rule, element, scopeText = '') => {
-            const result = rule.check(element, hlsContext);
-            if (result !== 'skip') {
-                const status = result ? 'pass' : rule.severity;
-                const location = {
-                    startLine:
-                        element.extinfLineNumber || element.lineNumber || 1,
-                    endLine: element.uriLineNumber || element.lineNumber || 1,
-                };
-                results.push({
-                    id: rule.id,
-                    text: `${rule.text} ${scopeText}`,
-                    status,
-                    details: result ? rule.passDetails : rule.failDetails,
-                    isoRef: rule.isoRef,
-                    category: rule.category,
-                    location,
-                });
-            }
-        };
-
-        const playlistScopes = ['Playlist'];
-        if (manifestIR.isMaster) {
-            playlistScopes.push('MasterPlaylist');
-        } else {
-            playlistScopes.push('MediaPlaylist');
-        }
-        applicableRules
-            .filter((rule) => playlistScopes.includes(rule.scope))
-            .forEach((rule) => {
-                runRule(
-                    /** @type {import('../../infrastructure/manifest/hls/compliance-rules/index.js').HlsRule} */ (
-                        rule
-                    ),
-                    manifestIR
-                );
-            });
-
-        if (!manifestIR.isMaster) {
-            (manifestIR.segments || []).forEach((segment, index) => {
-                applicableRules
-                    .filter((rule) => rule.scope === 'Segment')
-                    .forEach((rule) => {
-                        runRule(
-                            /** @type {import('../../infrastructure/manifest/hls/compliance-rules/index.js').HlsRule} */ (
-                                rule
-                            ),
-                            segment,
-                            `(Segment ${index + 1})`
-                        );
-                    });
-            });
-
-            (manifestIR.tags || [])
-                .filter((t) => t.name === 'EXT-X-KEY')
-                .forEach((keyTag, index) => {
-                    const key = {
-                        ...keyTag.value,
-                        lineNumber: keyTag.lineNumber,
-                    };
-                    applicableRules
-                        .filter((rule) => rule.scope === 'Key')
-                        .forEach((rule) => {
-                            runRule(
-                                /** @type {import('../../infrastructure/manifest/hls/compliance-rules/index.js').HlsRule} */ (
-                                    rule
-                                ),
-                                key,
-                                `(Key ${index + 1}, Method: ${key.METHOD})`
-                            );
-                        });
-                });
-        }
-
-        if (manifestIR.isMaster) {
-            (manifestIR.variants || []).forEach((variant, index) => {
-                applicableRules
-                    .filter((rule) => rule.scope === 'Variant')
-                    .forEach((rule) => {
-                        runRule(
-                            /** @type {import('../../infrastructure/manifest/hls/compliance-rules/index.js').HlsRule} */ (
-                                rule
-                            ),
-                            variant,
-                            `(Variant Stream ${
-                                index + 1
-                            }, BW: ${variant.attributes?.BANDWIDTH || 'N/A'})`
-                        );
-                    });
-            });
-
-            (manifestIR.tags || [])
-                .filter((t) => t.name === 'EXT-X-I-FRAME-STREAM-INF')
-                .forEach((iframeTag, index) => {
-                    const iframeStream = {
-                        ...iframeTag.value,
-                        lineNumber: iframeTag.lineNumber,
-                    };
-                    applicableRules
-                        .filter((rule) => rule.scope === 'IframeVariant')
-                        .forEach((rule) => {
-                            runRule(
-                                /** @type {import('../../infrastructure/manifest/hls/compliance-rules/index.js').HlsRule} */ (
-                                    rule
-                                ),
-                                iframeStream,
-                                `(I-Frame Stream ${index + 1}, BW: ${
-                                    iframeStream?.BANDWIDTH || 'N/A'
-                                })`
-                            );
-                        });
-                });
-
-            const mediaGroups = {};
-            (
-                manifestIR.tags.filter((t) => t.name === 'EXT-X-MEDIA') || []
-            ).forEach((mediaTag) => {
-                const groupId = mediaTag.value['GROUP-ID'];
-                const type = mediaTag.value.TYPE;
-                if (!mediaGroups[type]) mediaGroups[type] = {};
-                if (!mediaGroups[type][groupId])
-                    mediaGroups[type][groupId] = [];
-                mediaGroups[type][groupId].push({
-                    ...mediaTag.value,
-                    lineNumber: mediaTag.lineNumber,
-                });
-            });
-
-            Object.values(mediaGroups).forEach((typeGroups) => {
-                Object.values(typeGroups).forEach((group, index) => {
-                    applicableRules
-                        .filter((rule) => rule.scope === 'MediaGroup')
-                        .forEach((rule) => {
-                            runRule(
-                                /** @type {import('../../infrastructure/manifest/hls/compliance-rules/index.js').HlsRule} */ (
-                                    rule
-                                ),
-                                group,
-                                `(Media Group ${index + 1}, ID: ${
-                                    group[0]?.['GROUP-ID'] || 'N/A'
-                                }, Type: ${group[0]?.TYPE || 'N/A'})`
-                            );
-                        });
-                });
-            });
-        }
-        return results;
-    }
-
-    // DASH logic
-    const mpd = /** @type {object} */ (manifest);
-    const rootPath = 'MPD[0]';
-
-    if (!mpd || typeof mpd[':@'] !== 'object') {
-        const rootCheck = dashRules.find((r) => r.id === 'MPD-1');
-        return [
-            {
-                text: rootCheck.text,
-                status: rootCheck.severity,
-                details: rootCheck.failDetails,
-                isoRef: rootCheck.isoRef,
-                category: rootCheck.category,
-                location: { path: rootPath },
-            },
-        ];
-    }
-
-    // Extract profiles from the manifest
-    const manifestProfilesString = (getAttr(mpd, 'profiles') || '')
-        .toLowerCase()
-        .replace(/urn:mpeg:dash:profile:/g, '')
-        .replace(/:20\d\d/g, ''); // Normalize profile strings
-    const manifestProfiles = new Set(
-        manifestProfilesString
-            .split(',')
-            .map((p) => p.trim())
-            .filter(Boolean)
-    );
-    if (manifestProfiles.size === 0) {
-        manifestProfiles.add('common'); // Fallback to common if no profiles declared
-    }
-
-    const results = [];
-    const isDynamic = getAttr(mpd, 'type') === 'dynamic';
-    const dashContext = { isDynamic, profiles: Array.from(manifestProfiles) }; // Pass manifestProfiles in context as an array
-
-    const getDetails = (detail, element, detailContext) => {
-        return typeof detail === 'function'
-            ? detail(element, detailContext)
-            : detail;
-    };
-
-    dashRules
-        .filter((rule) => {
-            // A rule applies if it's a 'common' rule OR if its profiles array
-            // overlaps with the profiles declared in the manifest.
-            if (rule.profiles.includes('common')) return true;
-            return rule.profiles.some((p) =>
-                manifestProfiles.has(
-                    p
-                        .toLowerCase()
-                        .replace(/urn:mpeg:dash:profile:/g, '')
-                        .replace(/:20\d\d/g, '')
-                )
-            );
-        })
-        .filter((rule) => rule.scope === 'MPD')
-        .forEach((rule) => {
-            const result = rule.check(mpd, dashContext);
-            if (result !== 'skip') {
-                const status = result ? 'pass' : rule.severity;
-                results.push({
-                    id: rule.id,
-                    text: rule.text,
-                    status: status,
-                    details: getDetails(
-                        result ? rule.passDetails : rule.failDetails,
-                        mpd,
-                        dashContext
-                    ),
-                    isoRef: rule.isoRef,
-                    category: rule.category,
-                    location: { path: rootPath },
-                });
-            }
-        });
-
-    findChildren(mpd, 'Period').forEach((period, periodIndex) => {
-        const periodPath = `${rootPath}.Period[${periodIndex}]`;
-        const allRepIdsInPeriod = new Set(
-            findChildrenRecursive(period, 'Representation')
-                .map((r) => getAttr(r, 'id'))
-                .filter(Boolean)
-        );
-        const periodContext = { ...dashContext, allRepIdsInPeriod, period };
-
-        dashRules
-            .filter((rule) => {
-                if (rule.profiles.includes('common')) return true;
-                return rule.profiles.some((p) =>
-                    manifestProfiles.has(
-                        p
-                            .toLowerCase()
-                            .replace(/urn:mpeg:dash:profile:/g, '')
-                            .replace(/:20\d\d/g, '')
-                    )
-                );
-            })
-            .filter((rule) => rule.scope === 'Period')
-            .forEach((rule) => {
-                const result = rule.check(period, periodContext);
-                if (result !== 'skip') {
-                    const status = result ? 'pass' : rule.severity;
-                    results.push({
-                        id: rule.id,
-                        text: `${rule.text} (Period: ${
-                            getAttr(period, 'id') || 'N/A'
-                        })`,
-                        status: status,
-                        details: getDetails(
-                            result ? rule.passDetails : rule.failDetails,
-                            period,
-                            periodContext
-                        ),
-                        isoRef: rule.isoRef,
-                        category: rule.category,
-                        location: { path: periodPath },
-                    });
-                }
-            });
-
-        findChildren(period, 'AdaptationSet').forEach((as, asIndex) => {
-            const asPath = `${periodPath}.AdaptationSet[${asIndex}]`;
-            const asContext = { ...periodContext, adaptationSet: as };
-            dashRules
-                .filter((rule) => {
-                    if (rule.profiles.includes('common')) return true;
-                    return rule.profiles.some((p) =>
-                        manifestProfiles.has(
-                            p
-                                .toLowerCase()
-                                .replace(/urn:mpeg:dash:profile:/g, '')
-                                .replace(/:20\d\d/g, '')
-                        )
-                    );
-                })
-                .filter((rule) => rule.scope === 'AdaptationSet')
-                .forEach((rule) => {
-                    const result = rule.check(as, asContext);
-                    if (result !== 'skip') {
-                        const status = result ? 'pass' : rule.severity;
-                        results.push({
-                            id: rule.id,
-                            text: `${rule.text} (AdaptationSet: ${
-                                getAttr(as, 'id') || 'N/A'
-                            })`,
-                            status: status,
-                            details: getDetails(
-                                result ? rule.passDetails : rule.failDetails,
-                                as,
-                                asContext
-                            ),
-                            isoRef: rule.isoRef,
-                            category: rule.category,
-                            location: { path: asPath },
-                        });
-                    }
-                });
-
-            findChildren(as, 'Representation').forEach((rep, repIndex) => {
-                const repPath = `${asPath}.Representation[${repIndex}]`;
-                const repContext = { ...asContext, representation: rep };
-                dashRules
-                    .filter((rule) => {
-                        if (rule.profiles.includes('common')) return true;
-                        return rule.profiles.some((p) =>
-                            manifestProfiles.has(
-                                p
-                                    .toLowerCase()
-                                    .replace(/urn:mpeg:dash:profile:/g, '')
-                                    .replace(/:20\d\d/g, '')
-                            )
-                        );
-                    })
-                    .filter((rule) => rule.scope === 'Representation')
-                    .forEach((rule) => {
-                        const result = rule.check(rep, repContext);
-                        if (result !== 'skip') {
-                            const status = result ? 'pass' : rule.severity;
-                            results.push({
-                                id: rule.id,
-                                text: `${rule.text} (Representation: ${
-                                    getAttr(rep, 'id') || 'N/A'
-                                })`,
-                                status: status,
-                                details: getDetails(
-                                    result
-                                        ? rule.passDetails
-                                        : rule.failDetails,
-                                    rep,
-                                    repContext
-                                ),
-                                isoRef: rule.isoRef,
-                                category: rule.category,
-                                location: { path: repPath },
-                            });
-                        }
-                    });
-            });
-        });
-    });
-
-    return results;
-}
diff --git a/js/domain/compliance/semantic-analyzer.js b/js/domain/compliance/semantic-analyzer.js
deleted file mode 100644
index e8f889a..0000000
--- a/js/domain/compliance/semantic-analyzer.js
+++ /dev/null
@@ -1,251 +0,0 @@
-import { createTstdModel } from './t-std.js';
-
-const TS_PACKET_SIZE = 188;
-
-/**
- * Analyzes a collection of TS packets for stream-wide semantic compliance.
- * @param {object} parsedTsData - The full parsed segment data from the engine.
- * @returns {Array<object>} An array of compliance check result objects.
- */
-export function analyzeSemantics(parsedTsData) {
-    if (!parsedTsData?.packets || !parsedTsData.summary) {
-        return [];
-    }
-    const { packets, summary } = parsedTsData;
-    const results = [];
-    results.push(...checkPtsFrequency(packets));
-    results.push(...checkPtsAfterDiscontinuity(packets));
-    results.push(...checkPcrFrequency(summary.pcrList, summary.pcrPid));
-    results.push(...checkContinuityCounter(summary.continuityCounters));
-    results.push(...validateTstdBuffers(packets, summary));
-    return results;
-}
-
-/**
- * Validates T-STD buffer models for the segment.
- * @param {object[]} packets
- * @param {object} summary
- * @returns {Array<object>}
- */
-function validateTstdBuffers(packets, summary) {
-    const pmtPid = [...summary.pmtPids][0];
-    if (!pmtPid || !summary.programMap[pmtPid]) {
-        return []; // Cannot perform analysis without a program map
-    }
-
-    const program = summary.programMap[pmtPid];
-    program.pcrPid = summary.pcrPid;
-    const tstd = createTstdModel(program);
-
-    const results = [];
-    let lastPcrValue = null;
-    let lastPcrOffset = null;
-
-    packets.forEach((packet) => {
-        const currentPcr = packet.adaptationField?.pcr;
-
-        // Update transport_rate if we have a new PCR and a previous one to compare with
-        if (currentPcr) {
-            const currentPcrValue = BigInt(currentPcr.value);
-            const currentPcrOffset = packet.offset;
-
-            if (lastPcrValue !== null) {
-                const timeBetween =
-                    Number(currentPcrValue - lastPcrValue) / 27000000.0;
-                const bytesBetween = currentPcrOffset - lastPcrOffset;
-                if (timeBetween > 0) {
-                    tstd.transport_rate = (bytesBetween * 8) / timeBetween;
-                }
-            }
-
-            lastPcrValue = currentPcrValue;
-            lastPcrOffset = currentPcrOffset;
-        }
-
-        const pid = packet.pid;
-        const bufferModel = tstd.buffers[pid];
-
-        if (!bufferModel) return; // Not part of the program we're analyzing
-
-        // --- 1. Calculate Time Delta ---
-        // For all packets (PCR and non-PCR), the time delta for draining is based on the
-        // current transport_rate, which is piecewise constant.
-        const timeDelta = (TS_PACKET_SIZE * 8) / tstd.transport_rate;
-
-        if (timeDelta > 0) {
-            // --- 2. Drain Buffer ---
-            const bytesDrained = (bufferModel.Rxn / 8) * timeDelta;
-            bufferModel.TBn.fullness = Math.max(
-                0,
-                bufferModel.TBn.fullness - bytesDrained
-            );
-        }
-
-        // --- 3. Fill Buffer ---
-        bufferModel.TBn.fullness += TS_PACKET_SIZE;
-
-        // --- 4. Check for Overflow ---
-        if (bufferModel.TBn.fullness > bufferModel.TBn.size) {
-            results.push({
-                id: 'SEMANTIC-TB-OVERFLOW',
-                text: `T-STD Transport Buffer (TBn) overflow on PID ${pid}`,
-                status: 'fail',
-                details: `At packet offset ${packet.offset}, the Transport Buffer for PID ${pid} overflowed. Calculated fullness: ${bufferModel.TBn.fullness.toFixed(0)} bytes, Size: ${bufferModel.TBn.size} bytes. This indicates the transport rate is too high or leak rate is too low.`,
-                isoRef: 'Clause 2.4.2.7',
-                category: 'Semantic & Temporal Rules',
-            });
-            // Reset to prevent repeated errors for the same overflow
-            bufferModel.TBn.fullness = bufferModel.TBn.size;
-        }
-    });
-
-    return results;
-}
-
-/**
- * Checks for compliance with PTS frequency rules (Clause 2.7.4).
- * @param {object[]} packets
- * @returns {Array<object>}
- */
-function checkPtsFrequency(packets) {
-    const pesPacketsWithPtsByPid = {};
-    packets.forEach((packet) => {
-        if (packet.pes?.pts) {
-            if (!pesPacketsWithPtsByPid[packet.pid]) {
-                pesPacketsWithPtsByPid[packet.pid] = [];
-            }
-            pesPacketsWithPtsByPid[packet.pid].push({
-                pts: BigInt(packet.pes.pts.value),
-                offset: packet.offset,
-            });
-        }
-    });
-
-    const results = [];
-    for (const pid in pesPacketsWithPtsByPid) {
-        const pps = pesPacketsWithPtsByPid[pid];
-        for (let i = 1; i < pps.length; i++) {
-            const ptsDiff = Number(pps[i].pts - pps[i - 1].pts);
-            const ptsDiffSeconds = ptsDiff / 90000;
-            if (ptsDiffSeconds > 0.7) {
-                results.push({
-                    id: 'SEMANTIC-PTS-FREQ',
-                    text: `PTS interval exceeds 0.7s for PID ${pid}`,
-                    status: 'fail',
-                    details: `The interval between PTS values at packet offset ${pps[i - 1].offset} and ${pps[i].offset} is ${ptsDiffSeconds.toFixed(3)}s, which violates the maximum allowed 0.7s.`,
-                    isoRef: 'Clause 2.7.4',
-                    category: 'Semantic & Temporal Rules',
-                });
-            }
-        }
-    }
-    return results;
-}
-
-/**
- * Checks for the required presence of a PTS after a discontinuity (Clause 2.7.5).
- * @param {object[]} packets
- * @returns {Array<object>}
- */
-function checkPtsAfterDiscontinuity(packets) {
-    const packetsByPid = {};
-    packets.forEach((p) => {
-        if (!packetsByPid[p.pid]) packetsByPid[p.pid] = [];
-        packetsByPid[p.pid].push(p);
-    });
-
-    const results = [];
-    for (const pid in packetsByPid) {
-        const streamPackets = packetsByPid[pid];
-        for (let i = 0; i < streamPackets.length; i++) {
-            const packet = streamPackets[i];
-            if (packet.adaptationField?.discontinuity_indicator?.value === 1) {
-                // Search for the next PES packet start in this PID
-                let nextPesPacketFound = false;
-                let ptsFound = false;
-                for (let j = i; j < streamPackets.length; j++) {
-                    if (
-                        streamPackets[j].header?.payload_unit_start_indicator
-                            ?.value === 1 &&
-                        streamPackets[j].pes
-                    ) {
-                        nextPesPacketFound = true;
-                        if (streamPackets[j].pes.pts) {
-                            ptsFound = true;
-                        }
-                        break;
-                    }
-                }
-
-                if (nextPesPacketFound && !ptsFound) {
-                    results.push({
-                        id: 'SEMANTIC-PTS-DISCONT',
-                        text: `Missing required PTS after discontinuity on PID ${pid}`,
-                        status: 'fail',
-                        details: `A discontinuity was signaled at packet offset ${packet.offset}. The next PES packet in this stream did not contain a mandatory PTS.`,
-                        isoRef: 'Clause 2.7.5',
-                        category: 'Semantic & Temporal Rules',
-                    });
-                }
-            }
-        }
-    }
-    return results;
-}
-
-/**
- * Checks PCR frequency (Clause 2.7.2).
- * @param {{pcr: BigInt, offset: number}[]} pcrList
- * @param {number} pcrPid
- * @returns {Array<object>}
- */
-function checkPcrFrequency(pcrList, pcrPid) {
-    if (pcrList.length < 2) return [];
-    const results = [];
-    for (let i = 1; i < pcrList.length; i++) {
-        const timeDiff = Number(pcrList[i].pcr - pcrList[i - 1].pcr);
-        const timeDiffSeconds = timeDiff / 27000000;
-        if (timeDiffSeconds > 0.1) {
-            results.push({
-                id: 'SEMANTIC-PCR-FREQ',
-                text: `PCR interval exceeds 100ms for PCR PID ${pcrPid}`,
-                status: 'fail',
-                details: `The interval between PCRs at packet offset ${pcrList[i - 1].offset} and ${pcrList[i].offset} is ${Math.round(timeDiffSeconds * 1000)}ms, violating the 100ms maximum.`,
-                isoRef: 'Clause 2.7.2',
-                category: 'Semantic & Temporal Rules',
-            });
-        }
-    }
-    return results;
-}
-
-/**
- * Checks continuity counter integrity for all PIDs (Clause 2.4.3.3).
- * @param {Record<string, {cc: number, offset: number, hasPayload: boolean}[]>} ccMap
- * @returns {Array<object>}
- */
-function checkContinuityCounter(ccMap) {
-    const results = [];
-    for (const pid in ccMap) {
-        const counters = ccMap[pid];
-        for (let i = 1; i < counters.length; i++) {
-            const prev = counters[i - 1];
-            const curr = counters[i];
-
-            if (!prev.hasPayload) continue; // If previous packet had no payload, CC does not increment.
-
-            const expected_cc = (prev.cc + 1) % 16;
-            if (curr.cc !== expected_cc) {
-                results.push({
-                    id: 'SEMANTIC-CC-ERROR',
-                    text: `Continuity counter error on PID ${pid}`,
-                    status: 'warn',
-                    details: `Packet at offset ${curr.offset} has CC ${curr.cc}, but expected ${expected_cc} after packet at offset ${prev.offset}. This may indicate packet loss.`,
-                    isoRef: 'Clause 2.4.3.3',
-                    category: 'Semantic & Temporal Rules',
-                });
-            }
-        }
-    }
-    return results;
-}
diff --git a/js/domain/compliance/t-std.js b/js/domain/compliance/t-std.js
deleted file mode 100644
index 2491383..0000000
--- a/js/domain/compliance/t-std.js
+++ /dev/null
@@ -1,57 +0,0 @@
-// A model for the Transport Stream System Target Decoder (T-STD)
-// as specified in ISO/IEC 13818-1, Clause 2.4.2.
-
-/**
- * Calculates the leak rate (Rxn) for a given stream type.
- * @param {string | null} streamTypeHexString - The stream_type from the PMT.
- * @returns {number} The leak rate in bits per second.
- */
-function getRxn(streamTypeHexString) {
-    if (!streamTypeHexString) return 2000000; // Default for unknown/other
-    const streamType = parseInt(streamTypeHexString, 16);
-
-    switch (streamType) {
-        case 0x01: // MPEG-1 Video
-        case 0x02: // MPEG-2 Video
-            // This would require profile/level parsing from video headers.
-            // Using a conservative high value for now. Rmax * 1.2
-            return 80000000 * 1.2;
-        case 0x03: // MPEG-1 Audio
-        case 0x04: // MPEG-2 Audio
-            return 2000000;
-        case 0x0f: // AAC Audio (ADTS)
-            // A more complex calculation based on channels is needed.
-            // Using a conservative value for up to 8 channels.
-            return 5529600;
-        case 0x1b: // H.264/AVC Video
-            // MaxBR[level] * 1200
-            return 62500000 * 1.2; // Level 5.1
-        case 0x24: // H.265/HEVC Video
-            // BrNalFactor × MaxBR[tier, level]
-            return 160000000 * 1.2; // Main Tier, Level 5.1
-        default:
-            return 2000000; // Default system data rate
-    }
-}
-
-/**
- * Initializes a T-STD model for a program.
- * @param {object} program - A program object from the parsed PAT/PMT.
- * @returns {object} The initialized T-STD model.
- */
-export function createTstdModel(program) {
-    const model = {
-        transport_rate: 20000000, // Default/initial rate, will be updated dynamically
-        buffers: {},
-    };
-
-    Object.keys(program.streams).forEach((pid) => {
-        const streamType = program.streams[pid];
-        model.buffers[pid] = {
-            TBn: { size: 512, fullness: 0 }, // Transport Buffer, 512 bytes
-            Rxn: getRxn(streamType), // Leak rate from TBn in bps
-        };
-    });
-
-    return model;
-}
diff --git a/js/domain/debug/coverage-analyzer.js b/js/domain/debug/coverage-analyzer.js
deleted file mode 100644
index 65892e7..0000000
--- a/js/domain/debug/coverage-analyzer.js
+++ /dev/null
@@ -1,376 +0,0 @@
-/**
- * Schemas and logic for analyzing manifest parser coverage.
- * This helps identify which tags and attributes are being ignored by the current implementation.
- */
-
-// --- SCHEMA for Manifest-to-Parser analysis (Unparsed check) ---
-const dashXmlSchema = {
-    MPD: {
-        attrs: [
-            'id',
-            'profiles',
-            'type',
-            'availabilityStartTime',
-            'availabilityEndTime',
-            'publishTime',
-            'mediaPresentationDuration',
-            'minimumUpdatePeriod',
-            'minBufferTime',
-            'timeShiftBufferDepth',
-            'suggestedPresentationDelay',
-            'maxSegmentDuration',
-            'maxSubsegmentDuration',
-            'xmlns',
-            'xmlns:xsi',
-            'schemaLocation',
-            'xmlns:cenc',
-        ],
-        children: [
-            'ProgramInformation',
-            'BaseURL',
-            'Location',
-            'PatchLocation',
-            'Period',
-            'UTCTiming',
-            'ServiceDescription',
-            'InitializationSet',
-            'Metrics',
-        ],
-    },
-    Period: {
-        attrs: ['id', 'start', 'duration', 'bitstreamSwitching'],
-        children: [
-            'AdaptationSet',
-            'EventStream',
-            'Subset',
-            'AssetIdentifier',
-            'ServiceDescription',
-            'Preselection',
-            'BaseURL',
-        ],
-    },
-    AdaptationSet: {
-        attrs: [
-            'id',
-            'group',
-            'contentType',
-            'lang',
-            'mimeType',
-            'codecs',
-            'frameRate',
-            'par',
-            'minBandwidth',
-            'maxBandwidth',
-            'minWidth',
-            'maxWidth',
-            'minHeight',
-            'maxHeight',
-            'minFrameRate',
-            'maxFrameRate',
-            'selectionPriority',
-            'segmentAlignment',
-            'subsegmentAlignment',
-            'startWithSAP',
-            'subsegmentStartsWithSAP',
-            'bitstreamSwitching',
-            'initializationPrincipal',
-            'profiles', // Common attribute
-            'containerProfiles',
-        ],
-        children: [
-            'Representation',
-            'ContentProtection',
-            'Role',
-            'Accessibility',
-            'Viewpoint',
-            'Rating',
-            'ContentComponent',
-            'SegmentTemplate',
-            'SegmentList',
-            'SegmentBase',
-            'BaseURL',
-            'SupplementalProperty',
-            'Label',
-        ],
-    },
-    Representation: {
-        attrs: [
-            'id',
-            'bandwidth',
-            'qualityRanking',
-            'dependencyId',
-            'associationId',
-            'associationType',
-            'mediaStreamStructureId',
-            'codecs',
-            'mimeType',
-            'width',
-            'height',
-            'frameRate',
-            'sar',
-            'audioSamplingRate',
-            'scanType',
-        ],
-        children: [
-            'BaseURL',
-            'SegmentBase',
-            'SegmentList',
-            'SegmentTemplate',
-            'SubRepresentation',
-            'ContentProtection',
-            'EssentialProperty',
-            'SupplementalProperty',
-            'InbandEventStream',
-            'AudioChannelConfiguration',
-        ],
-    },
-    // Add other elements as needed...
-};
-
-/**
- * Analyzes a serialized DASH manifest object against a schema of known parsed elements.
- * @param {object} serializedManifest The root MPD element from fast-xml-parser.
- * @returns {import('../../app/types.js').CoverageFinding[]}
- */
-export function analyzeDashCoverage(serializedManifest) {
-    const findings = [];
-    const walk = (node, schemaType, path) => {
-        if (!node || typeof node !== 'object') return;
-        const schema = dashXmlSchema[schemaType];
-        if (!schema) {
-            findings.push({
-                pathOrLine: path,
-                status: 'unparsed',
-                type: 'element',
-                name: schemaType,
-                details:
-                    'This element type is not defined in the parser schema.',
-            });
-            return;
-        }
-
-        // Check attributes
-        const attrs = node[':@'] || {};
-        for (const attrName in attrs) {
-            if (!schema.attrs.includes(attrName)) {
-                findings.push({
-                    pathOrLine: path,
-                    status: 'unparsed',
-                    type: 'attribute',
-                    name: attrName,
-                    details: `Attribute @${attrName} on <${schemaType}> is not parsed.`,
-                });
-            }
-        }
-
-        // Check child elements
-        const childCounts = {};
-        for (const childName in node) {
-            if (childName === ':@' || childName === '#text') continue;
-            if (!schema.children.includes(childName)) {
-                findings.push({
-                    pathOrLine: `${path}.${childName}[0]`,
-                    status: 'unparsed',
-                    type: 'element',
-                    name: childName,
-                    details: `Child element <${childName}> inside <${schemaType}> is not parsed.`,
-                });
-            } else {
-                const children = Array.isArray(node[childName])
-                    ? node[childName]
-                    : [node[childName]];
-                children.forEach((childNode) => {
-                    const currentIndex = childCounts[childName] || 0;
-                    // Only walk into children that have their own schema definition.
-                    if (dashXmlSchema[childName]) {
-                        walk(
-                            childNode,
-                            childName,
-                            `${path}.${childName}[${currentIndex}]`
-                        );
-                    }
-                    childCounts[childName] = currentIndex + 1;
-                });
-            }
-        }
-    };
-
-    walk(serializedManifest, 'MPD', 'MPD[0]');
-    return findings;
-}
-
-// --- SCHEMA for Parser-to-IR analysis (Drift check) ---
-const irSchema = {
-    Representation: [
-        'id',
-        'codecs',
-        'bandwidth',
-        'width',
-        'height',
-        'frameRate',
-        'sar',
-        'mimeType',
-        'profiles',
-        'qualityRanking',
-        'selectionPriority',
-        'codingDependency',
-        'scanType',
-        'dependencyId',
-        'associationId',
-        'associationType',
-        'segmentProfiles',
-        'mediaStreamStructureId',
-        'maximumSAPPeriod',
-        'startWithSAP',
-        'maxPlayoutRate',
-        'tag',
-        'eptDelta',
-        'pdDelta',
-        'representationIndex',
-        'failoverContent',
-        'audioChannelConfigurations',
-        'framePackings',
-        'ratings',
-        'viewpoints',
-        'accessibility',
-        'labels',
-        'groupLabels',
-        'subRepresentations',
-        'resyncs',
-        'outputProtection',
-        'extendedBandwidth',
-        'videoRange',
-        'stableVariantId',
-        'pathwayId',
-        'supplementalCodecs',
-        'reqVideoLayout',
-        'serializedManifest',
-    ],
-    AdaptationSet: [
-        'id',
-        'contentType',
-        'lang',
-        'mimeType',
-        'profiles',
-        'group',
-        'bitstreamSwitching',
-        'maxWidth',
-        'maxHeight',
-        'maxFrameRate',
-        'representations',
-        'contentProtection',
-        'framePackings',
-        'ratings',
-        'viewpoints',
-        'accessibility',
-        'labels',
-        'groupLabels',
-        'roles',
-        'contentComponents',
-        'resyncs',
-        'outputProtection',
-        'stableRenditionId',
-        'bitDepth',
-        'sampleRate',
-        'channels',
-        'assocLanguage',
-        'characteristics',
-        'forced',
-        'serializedManifest',
-    ],
-    Period: [
-        'id',
-        'start',
-        'duration',
-        'bitstreamSwitching',
-        'assetIdentifier',
-        'adaptationSets',
-        'subsets',
-        'preselections',
-        'serviceDescriptions',
-        'eventStreams',
-        'events',
-        'serializedManifest',
-    ],
-    Manifest: [
-        'id',
-        'type',
-        'profiles',
-        'minBufferTime',
-        'publishTime',
-        'availabilityStartTime',
-        'timeShiftBufferDepth',
-        'minimumUpdatePeriod',
-        'duration',
-        'maxSegmentDuration',
-        'maxSubsegmentDuration',
-        'programInformations',
-        'metrics',
-        'locations',
-        'patchLocations',
-        'serviceDescriptions',
-        'initializationSets',
-        'segmentFormat',
-        'events',
-        'periods',
-        'serializedManifest',
-        'summary',
-        'serverControl',
-        'hlsDefinedVariables',
-        'tags',
-        'isMaster',
-        'variants',
-        'segments',
-        'preloadHints',
-        'renditionReports',
-        'partInf',
-    ],
-};
-
-/**
- * Analyzes a DASH or HLS Intermediate Representation (IR) object for properties
- * that are not declared in the canonical IR schema.
- * @param {import('../../app/types.js').Manifest} manifestIR The parsed manifest IR.
- * @returns {import('../../app/types.js').CoverageFinding[]}
- */
-export function analyzeParserDrift(manifestIR) {
-    const findings = [];
-    const ignoreKeys = ['serializedManifest']; // These are containers and not part of the schema itself.
-
-    const checkObject = (obj, schemaName, path) => {
-        const schema = irSchema[schemaName];
-        if (!schema) return;
-
-        for (const key in obj) {
-            if (ignoreKeys.includes(key)) continue;
-            if (!schema.includes(key)) {
-                findings.push({
-                    pathOrLine: path,
-                    status: 'drift',
-                    type: 'property',
-                    name: key,
-                    details: `Property "${key}" exists on parsed ${schemaName} object but is not in the IR schema. This indicates parser drift.`,
-                    lineNumber: obj.serializedManifest?.lineNumber,
-                });
-            }
-        }
-    };
-
-    checkObject(manifestIR, 'Manifest', 'Manifest');
-    manifestIR.periods.forEach((period, p_idx) => {
-        const periodPath = `Manifest.periods[${p_idx}]`;
-        checkObject(period, 'Period', periodPath);
-
-        period.adaptationSets.forEach((as, as_idx) => {
-            const asPath = `${periodPath}.adaptationSets[${as_idx}]`;
-            checkObject(as, 'AdaptationSet', asPath);
-
-            as.representations.forEach((rep, r_idx) => {
-                const repPath = `${asPath}.representations[${r_idx}]`;
-                checkObject(rep, 'Representation', repPath);
-            });
-        });
-    });
-
-    return findings;
-}
diff --git a/js/domain/feature-analysis/analyzer.js b/js/domain/feature-analysis/analyzer.js
deleted file mode 100644
index 358bbd8..0000000
--- a/js/domain/feature-analysis/analyzer.js
+++ /dev/null
@@ -1,61 +0,0 @@
-import { dashFeatureDefinitions } from '../../infrastructure/manifest/dash/feature-definitions.js';
-import { hlsFeatureDefinitions } from '../../infrastructure/manifest/hls/feature-definitions.js';
-import { analyzeDashFeatures } from '../../infrastructure/manifest/dash/feature-analyzer.js';
-import { analyzeHlsFeatures } from '../../infrastructure/manifest/hls/feature-analyzer.js';
-
-/**
- * Analyzes a manifest for feature usage.
- * @param {import('../../app/types.js').Manifest} manifestIR - The manifest IR object.
- * @param {'dash' | 'hls'} protocol
- * @param {object | null} serializedManifest - The serialized DOM object for DASH.
- * @returns {Record<string, import('../../infrastructure/manifest/dash/feature-analyzer.js').FeatureCheckResult>} A map of feature names to their analysis results.
- */
-export function generateFeatureAnalysis(
-    manifestIR,
-    protocol,
-    serializedManifest = null
-) {
-    if (protocol === 'dash') {
-        return analyzeDashFeatures(serializedManifest);
-    } else {
-        return analyzeHlsFeatures(manifestIR); // HLS analyzer operates on the IR
-    }
-}
-
-/**
- * Creates the view model by merging feature definitions with analysis results.
- * @param {Map<string, import('../../app/types.js').FeatureAnalysisResult>} analysisResultsMap
- * @param {'dash' | 'hls'} protocol
- * @param {number} standardVersion - The target standard version to filter features against (for HLS).
- * @returns {object[]} A list of feature objects ready for rendering.
- */
-export function createFeatureViewModel(
-    analysisResultsMap,
-    protocol,
-    standardVersion
-) {
-    let applicableDefinitions;
-
-    if (protocol === 'hls') {
-        // HLS features are filtered by the selected HLS version.
-        applicableDefinitions = hlsFeatureDefinitions.filter(
-            (def) => def.version <= standardVersion
-        );
-    } else {
-        // DASH features are considered generally applicable if present.
-        // No version filtering is applied to DASH features here as profiles
-        // implicitly define feature sets, and this view is for 'what is used'.
-        applicableDefinitions = dashFeatureDefinitions;
-    }
-
-    return applicableDefinitions.map((def) => {
-        const result = analysisResultsMap.get(def.name) || {
-            used: false,
-            details: 'Not detected in manifest.',
-        };
-        return {
-            ...def,
-            ...result,
-        };
-    });
-}
diff --git a/js/domain/hls/steering-validator.js b/js/domain/hls/steering-validator.js
deleted file mode 100644
index 823fb45..0000000
--- a/js/domain/hls/steering-validator.js
+++ /dev/null
@@ -1,86 +0,0 @@
-/**
- * @typedef {object} SteeringValidationResult
- * @property {boolean} isValid - Whether the steering manifest is structurally valid.
- * @property {string[]} errors - A list of validation error messages.
- * @property {object} steeringManifest - The fetched and parsed JSON manifest.
- */
-
-/**
- * Fetches and validates an HLS Content Steering manifest.
- * @param {string} serverUri - The URI of the steering manifest.
- * @returns {Promise<SteeringValidationResult>} The result of the validation.
- */
-export async function validateSteeringManifest(serverUri) {
-    const result = {
-        isValid: false,
-        errors: [],
-        steeringManifest: null,
-    };
-
-    try {
-        const response = await fetch(serverUri);
-        if (!response.ok) {
-            throw new Error(
-                `HTTP ${response.status} fetching steering manifest`
-            );
-        }
-        const manifest = await response.json();
-        result.steeringManifest = manifest;
-
-        // Validation checks based on RFC 8216bis, Section 7.2
-        if (typeof manifest.VERSION !== 'number' || manifest.VERSION < 1) {
-            result.errors.push(
-                'Steering manifest must have a VERSION attribute of at least 1.'
-            );
-        }
-
-        if (typeof manifest.TTL !== 'number' || manifest.TTL < 0) {
-            result.errors.push(
-                'Steering manifest must have a non-negative TTL attribute.'
-            );
-        }
-
-        if (!Array.isArray(manifest['PATHWAY-PRIORITY'])) {
-            result.errors.push(
-                'Steering manifest must have a PATHWAY-PRIORITY array.'
-            );
-        } else {
-            if (
-                manifest['PATHWAY-PRIORITY'].some(
-                    (item) => typeof item !== 'string'
-                )
-            ) {
-                result.errors.push(
-                    'All items in PATHWAY-PRIORITY must be strings.'
-                );
-            }
-        }
-
-        if (manifest['PATHWAY-CLONES']) {
-            if (!Array.isArray(manifest['PATHWAY-CLONES'])) {
-                result.errors.push(
-                    'PATHWAY-CLONES, if present, must be an array.'
-                );
-            } else {
-                manifest['PATHWAY-CLONES'].forEach((clone, i) => {
-                    if (
-                        typeof clone['BASE-ID'] !== 'string' ||
-                        typeof clone.ID !== 'string'
-                    ) {
-                        result.errors.push(
-                            `Pathway clone at index ${i} is missing required BASE-ID or ID.`
-                        );
-                    }
-                });
-            }
-        }
-
-        result.isValid = result.errors.length === 0;
-        return result;
-    } catch (error) {
-        result.errors.push(
-            `Failed to fetch or parse steering manifest: ${error.message}`
-        );
-        return result;
-    }
-}
diff --git a/js/infrastructure/manifest/dash/adapter.js b/js/infrastructure/manifest/dash/adapter.js
deleted file mode 100644
index 81fc212..0000000
--- a/js/infrastructure/manifest/dash/adapter.js
+++ /dev/null
@@ -1,645 +0,0 @@
-/**
- * @typedef {import('../../../app/types.js').Manifest} Manifest
- * @typedef {import('../../../app/types.js').Period} Period
- * @typedef {import('../../../app/types.js').AdaptationSet} AdaptationSet
- * @typedef {import('../../../app/types.js').Representation} Representation
- * @typedef {import('../../../app/types.js').SubRepresentation} SubRepresentation
- * @typedef {import('../../../app/types.js').Descriptor} Descriptor
- * @typedef {import('../../../app/types.js').ContentComponent} ContentComponent
- * @typedef {import('../../../app/types.js').Resync} Resync
- * @typedef {import('../../../app/types.js').Preselection} Preselection
- * @typedef {import('../../../app/types.js').FailoverContent} FailoverContent
- * @typedef {import('../../../app/types.js').OutputProtection} OutputProtection
- * @typedef {import('../../../app/types.js').ExtendedBandwidth} ExtendedBandwidth
- * @typedef {import('../../../app/types.js').ServiceDescription} ServiceDescription
- * @typedef {import('../../../app/types.js').InitializationSet} InitializationSet
- */
-
-import { getDrmSystemName } from '../../../shared/utils/drm.js';
-import { parseDuration } from '../../../shared/utils/time.js';
-import { generateDashSummary } from './summary-generator.js';
-import {
-    getAttr,
-    findChild,
-    findChildren,
-    findChildrenRecursive,
-    mergeElements,
-} from './recursive-parser.js';
-import { parseScte35 } from '../../metadata/scte35/parser.js';
-
-const getText = (el) => el?.['#text'] || null;
-
-/**
- * Creates a deep copy of a parsed manifest object.
- * @param {any} obj The object to clone.
- * @returns {any} A deep copy of the object.
- */
-function deepClone(obj) {
-    if (obj === null || typeof obj !== 'object') {
-        return obj;
-    }
-    if (obj instanceof Date) {
-        return new Date(obj.getTime());
-    }
-    if (Array.isArray(obj)) {
-        return obj.map((item) => deepClone(item));
-    }
-    if (obj instanceof Object) {
-        const copy = {};
-        for (const key in obj) {
-            if (Object.prototype.hasOwnProperty.call(obj, key)) {
-                copy[key] = deepClone(obj[key]);
-            }
-        }
-        return copy;
-    }
-    throw new Error("Unable to copy obj! Its type isn't supported.");
-}
-
-/**
- * Parses a generic DescriptorType element into a consistent IR object.
- * @param {object} el The raw parsed element.
- * @returns {Descriptor}
- */
-const parseGenericDescriptor = (el) => ({
-    schemeIdUri: getAttr(el, 'schemeIdUri'),
-    value: getAttr(el, 'value'),
-    id: getAttr(el, 'id'),
-});
-
-/**
- * Parses a Label or GroupLabel element.
- * @param {object} el The raw parsed element.
- * @returns {import('../../../app/types.js').Label}
- */
-const parseLabel = (el) => ({
-    id: getAttr(el, 'id'),
-    lang: getAttr(el, 'lang'),
-    text: getText(el),
-});
-
-/**
- * Parses a Resync element.
- * @param {object} el The raw parsed Resync element.
- * @returns {Resync}
- */
-const parseResync = (el) => ({
-    type: parseInt(getAttr(el, 'type') || '0', 10),
-    dT: getAttr(el, 'dT') ? parseInt(getAttr(el, 'dT'), 10) : null,
-    dImax: getAttr(el, 'dImax') ? parseFloat(getAttr(el, 'dImax')) : null,
-    dImin: getAttr(el, 'dImin') ? parseFloat(getAttr(el, 'dImin')) : null,
-    marker: getAttr(el, 'marker') === 'true',
-});
-
-/**
- * Parses an OutputProtection element.
- * @param {object} el The raw parsed element.
- * @returns {OutputProtection | null}
- */
-const parseOutputProtection = (el) => {
-    const opEl = findChild(el, 'OutputProtection');
-    if (!opEl) return null;
-    return {
-        schemeIdUri: getAttr(opEl, 'schemeIdUri'),
-        value: getAttr(opEl, 'value'),
-        robustness: getAttr(opEl, 'robustness'),
-    };
-};
-
-/**
- * Parses an ExtendedBandwidth element.
- * @param {object} el The raw parsed element.
- * @returns {ExtendedBandwidth | null}
- */
-const parseExtendedBandwidth = (el) => {
-    const ebEl = findChild(el, 'ExtendedBandwidth');
-    if (!ebEl) return null;
-    return {
-        vbr: getAttr(ebEl, 'vbr') === 'true',
-        modelPairs: findChildren(ebEl, 'ModelPair').map((mpEl) => ({
-            bufferTime: parseDuration(getAttr(mpEl, 'bufferTime')),
-            bandwidth: parseInt(getAttr(mpEl, 'bandwidth'), 10),
-        })),
-    };
-};
-
-/**
- * Parses a FailoverContent element.
- * @param {object} mergedEl The merged parent element containing SegmentBase info.
- * @returns {FailoverContent | null}
- */
-function parseFailoverContent(mergedEl) {
-    const segmentBaseEl = findChild(mergedEl, 'SegmentBase');
-    if (!segmentBaseEl) return null;
-
-    const failoverEl = findChild(segmentBaseEl, 'FailoverContent');
-    if (!failoverEl) return null;
-
-    return {
-        valid: getAttr(failoverEl, 'valid') !== 'false', // Defaults to true
-        fcs: findChildren(failoverEl, 'FCS').map((fcsEl) => ({
-            t: parseInt(getAttr(fcsEl, 't'), 10),
-            d: getAttr(fcsEl, 'd') ? parseInt(getAttr(fcsEl, 'd'), 10) : null,
-        })),
-    };
-}
-
-/**
- * Parses a SubRepresentation element, inheriting from its parent Representation/AdaptationSet.
- * @param {object} subRepEl The raw parsed SubRepresentation element.
- * @param {object} parentMergedEl The already merged element of the parent Representation.
- * @returns {SubRepresentation}
- */
-function parseSubRepresentation(subRepEl, parentMergedEl) {
-    const mergedEl = mergeElements(parentMergedEl, subRepEl);
-
-    /** @type {SubRepresentation} */
-    const subRepIR = {
-        level: getAttr(subRepEl, 'level')
-            ? parseInt(getAttr(subRepEl, 'level'), 10)
-            : null,
-        dependencyLevel: getAttr(subRepEl, 'dependencyLevel'),
-        bandwidth: getAttr(subRepEl, 'bandwidth')
-            ? parseInt(getAttr(subRepEl, 'bandwidth'), 10)
-            : null,
-        contentComponent: getAttr(subRepEl, 'contentComponent')?.split(' '),
-        codecs: getAttr(mergedEl, 'codecs'),
-        mimeType: getAttr(mergedEl, 'mimeType'),
-        profiles: getAttr(mergedEl, 'profiles'),
-        width: getAttr(mergedEl, 'width')
-            ? parseInt(getAttr(mergedEl, 'width'), 10)
-            : null,
-        height: getAttr(mergedEl, 'height')
-            ? parseInt(getAttr(mergedEl, 'height'), 10)
-            : null,
-        serializedManifest: subRepEl,
-    };
-
-    return subRepIR;
-}
-
-/**
- * Parses a Representation element, correctly inheriting all common properties
- * from its parent AdaptationSet.
- * @param {object} repEl The raw parsed Representation element.
- * @param {object} parentMergedEl The already merged parent element (from Period or AdaptationSet).
- * @returns {Representation}
- */
-function parseRepresentation(repEl, parentMergedEl) {
-    const mergedRepEl = mergeElements(parentMergedEl, repEl);
-
-    /** @type {Representation} */
-    const repIR = {
-        id: getAttr(repEl, 'id'),
-        bandwidth: parseInt(getAttr(repEl, 'bandwidth'), 10),
-        qualityRanking: getAttr(repEl, 'qualityRanking')
-            ? parseInt(getAttr(repEl, 'qualityRanking'), 10)
-            : null,
-        dependencyId: getAttr(repEl, 'dependencyId'),
-        associationId: getAttr(repEl, 'associationId'),
-        associationType: getAttr(repEl, 'associationType'),
-        codecs: getAttr(mergedRepEl, 'codecs'),
-        mimeType: getAttr(mergedRepEl, 'mimeType'),
-        profiles: getAttr(mergedRepEl, 'profiles'),
-        width: getAttr(mergedRepEl, 'width')
-            ? parseInt(getAttr(mergedRepEl, 'width'), 10)
-            : null,
-        height: getAttr(mergedRepEl, 'height')
-            ? parseInt(getAttr(mergedRepEl, 'height'), 10)
-            : null,
-        frameRate: getAttr(mergedRepEl, 'frameRate'),
-        sar: getAttr(mergedRepEl, 'sar'),
-        scanType: getAttr(mergedRepEl, 'scanType'),
-        segmentProfiles: getAttr(mergedRepEl, 'segmentProfiles'),
-        mediaStreamStructureId: getAttr(mergedRepEl, 'mediaStreamStructureId'),
-        maximumSAPPeriod: getAttr(mergedRepEl, 'maximumSAPPeriod')
-            ? parseFloat(getAttr(mergedRepEl, 'maximumSAPPeriod'))
-            : null,
-        startWithSAP: getAttr(mergedRepEl, 'startWithSAP')
-            ? parseInt(getAttr(mergedRepEl, 'startWithSAP'), 10)
-            : null,
-        maxPlayoutRate: getAttr(mergedRepEl, 'maxPlayoutRate')
-            ? parseFloat(getAttr(mergedRepEl, 'maxPlayoutRate'))
-            : null,
-        codingDependency:
-            getAttr(mergedRepEl, 'codingDependency') === 'true'
-                ? true
-                : getAttr(mergedRepEl, 'codingDependency') === 'false'
-                  ? false
-                  : null,
-        selectionPriority: getAttr(mergedRepEl, 'selectionPriority')
-            ? parseInt(getAttr(mergedRepEl, 'selectionPriority'), 10)
-            : 0,
-        tag: getAttr(mergedRepEl, 'tag'),
-        eptDelta: null,
-        pdDelta: null,
-        representationIndex: null,
-        failoverContent: parseFailoverContent(mergedRepEl),
-        audioChannelConfigurations: findChildren(
-            mergedRepEl,
-            'AudioChannelConfiguration'
-        ).map((el) => ({
-            schemeIdUri: getAttr(el, 'schemeIdUri'),
-            value: getAttr(el, 'value'),
-        })),
-        framePackings: findChildren(mergedRepEl, 'FramePacking').map(
-            parseGenericDescriptor
-        ),
-        ratings: findChildren(mergedRepEl, 'Rating').map(
-            parseGenericDescriptor
-        ),
-        viewpoints: findChildren(mergedRepEl, 'Viewpoint').map(
-            parseGenericDescriptor
-        ),
-        accessibility: findChildren(mergedRepEl, 'Accessibility').map(
-            parseGenericDescriptor
-        ),
-        labels: findChildren(mergedRepEl, 'Label').map(parseLabel),
-        groupLabels: findChildren(mergedRepEl, 'GroupLabel').map(parseLabel),
-        subRepresentations: findChildren(repEl, 'SubRepresentation').map(
-            (subRepEl) => parseSubRepresentation(subRepEl, mergedRepEl)
-        ),
-        resyncs: findChildren(mergedRepEl, 'Resync').map(parseResync),
-        outputProtection: parseOutputProtection(mergedRepEl),
-        extendedBandwidth: parseExtendedBandwidth(mergedRepEl),
-        videoRange: undefined,
-        stableVariantId: null,
-        pathwayId: null,
-        supplementalCodecs: null,
-        reqVideoLayout: null,
-        serializedManifest: repEl,
-    };
-
-    return repIR;
-}
-
-/**
- * Parses a ContentComponent element.
- * @param {object} ccEl - The raw parsed ContentComponent element.
- * @param {object} parentEl - The parent AdaptationSet element.
- * @returns {ContentComponent}
- */
-function parseContentComponent(ccEl, parentEl) {
-    const mergedEl = mergeElements(parentEl, ccEl);
-    return {
-        id: getAttr(ccEl, 'id'),
-        lang: getAttr(mergedEl, 'lang'),
-        contentType: getAttr(mergedEl, 'contentType'),
-        par: getAttr(mergedEl, 'par'),
-        tag: getAttr(mergedEl, 'tag'),
-        accessibility: findChildren(mergedEl, 'Accessibility').map(
-            parseGenericDescriptor
-        ),
-        roles: findChildren(mergedEl, 'Role').map(parseGenericDescriptor),
-        ratings: findChildren(mergedEl, 'Rating').map(parseGenericDescriptor),
-        viewpoints: findChildren(mergedEl, 'Viewpoint').map(
-            parseGenericDescriptor
-        ),
-        serializedManifest: ccEl,
-    };
-}
-
-function parseAdaptationSet(asEl, parentMergedEl) {
-    const mergedAsEl = mergeElements(parentMergedEl, asEl);
-    const contentComponentEls = findChildren(asEl, 'ContentComponent');
-
-    let contentComponents;
-    if (contentComponentEls.length > 0) {
-        contentComponents = contentComponentEls.map((ccEl) =>
-            parseContentComponent(ccEl, asEl)
-        );
-    } else {
-        // If no explicit ContentComponent, create one implicitly from the AdaptationSet's attributes
-        contentComponents = [
-            {
-                id: null,
-                lang: getAttr(asEl, 'lang'),
-                contentType:
-                    getAttr(asEl, 'contentType') ||
-                    getAttr(asEl, 'mimeType')?.split('/')[0],
-                par: getAttr(asEl, 'par'),
-                tag: getAttr(asEl, 'tag'),
-                accessibility: findChildren(asEl, 'Accessibility').map(
-                    parseGenericDescriptor
-                ),
-                roles: findChildren(asEl, 'Role').map(parseGenericDescriptor),
-                ratings: findChildren(asEl, 'Rating').map(
-                    parseGenericDescriptor
-                ),
-                viewpoints: findChildren(asEl, 'Viewpoint').map(
-                    parseGenericDescriptor
-                ),
-                serializedManifest: asEl,
-            },
-        ];
-    }
-
-    /** @type {AdaptationSet} */
-    const asIR = {
-        id: getAttr(asEl, 'id'),
-        group: getAttr(asEl, 'group')
-            ? parseInt(getAttr(asEl, 'group'), 10)
-            : null,
-        lang: getAttr(asEl, 'lang'),
-        contentType:
-            getAttr(asEl, 'contentType') ||
-            getAttr(asEl, 'mimeType')?.split('/')[0],
-        bitstreamSwitching:
-            getAttr(asEl, 'bitstreamSwitching') === 'true' ? true : null,
-        segmentAlignment: getAttr(mergedAsEl, 'segmentAlignment') === 'true',
-        maxWidth: getAttr(asEl, 'maxWidth')
-            ? parseInt(getAttr(asEl, 'maxWidth'), 10)
-            : null,
-        maxHeight: getAttr(asEl, 'maxHeight')
-            ? parseInt(getAttr(asEl, 'maxHeight'), 10)
-            : null,
-        maxFrameRate: getAttr(asEl, 'maxFrameRate'),
-        mimeType: getAttr(mergedAsEl, 'mimeType'),
-        profiles: getAttr(mergedAsEl, 'profiles'),
-        representations: findChildren(asEl, 'Representation').map((repEl) =>
-            parseRepresentation(repEl, mergedAsEl)
-        ),
-        contentProtection: findChildren(mergedAsEl, 'ContentProtection').map(
-            (cpEl) => ({
-                schemeIdUri: getAttr(cpEl, 'schemeIdUri'),
-                system: getDrmSystemName(getAttr(cpEl, 'schemeIdUri')),
-                defaultKid: getAttr(cpEl, 'cenc:default_KID'),
-                robustness: getAttr(cpEl, 'robustness'),
-            })
-        ),
-        framePackings: findChildren(mergedAsEl, 'FramePacking').map(
-            parseGenericDescriptor
-        ),
-        ratings: findChildren(mergedAsEl, 'Rating').map(parseGenericDescriptor),
-        viewpoints: findChildren(mergedAsEl, 'Viewpoint').map(
-            parseGenericDescriptor
-        ),
-        accessibility: findChildren(mergedAsEl, 'Accessibility').map(
-            parseGenericDescriptor
-        ),
-        labels: findChildren(mergedAsEl, 'Label').map(parseLabel),
-        groupLabels: findChildren(mergedAsEl, 'GroupLabel').map(parseLabel),
-        roles: findChildren(mergedAsEl, 'Role').map(parseGenericDescriptor),
-        contentComponents: contentComponents,
-        resyncs: findChildren(mergedAsEl, 'Resync').map(parseResync),
-        outputProtection: parseOutputProtection(mergedAsEl),
-        stableRenditionId: null,
-        bitDepth: null,
-        sampleRate: null,
-        channels: null,
-        assocLanguage: null,
-        characteristics: null,
-        forced: false,
-        serializedManifest: asEl,
-    };
-
-    return asIR;
-}
-
-/**
- * Parses a Preselection element.
- * @param {object} preselectionEl The raw parsed Preselection element.
- * @param {object} parentMergedEl The parent Period element.
- * @returns {Preselection}
- */
-function parsePreselection(preselectionEl, parentMergedEl) {
-    const mergedEl = mergeElements(parentMergedEl, preselectionEl);
-    return {
-        id: getAttr(preselectionEl, 'id') || '1',
-        preselectionComponents:
-            getAttr(preselectionEl, 'preselectionComponents')?.split(' ') || [],
-        lang: getAttr(preselectionEl, 'lang'),
-        order: getAttr(preselectionEl, 'order') || 'undefined',
-        accessibility: findChildren(mergedEl, 'Accessibility').map(
-            parseGenericDescriptor
-        ),
-        roles: findChildren(mergedEl, 'Role').map(parseGenericDescriptor),
-        ratings: findChildren(mergedEl, 'Rating').map(parseGenericDescriptor),
-        viewpoints: findChildren(mergedEl, 'Viewpoint').map(
-            parseGenericDescriptor
-        ),
-        serializedManifest: preselectionEl,
-    };
-}
-
-/**
- * Parses a ServiceDescription element.
- * @param {object} sdEl Raw parsed ServiceDescription element.
- * @returns {ServiceDescription}
- */
-const parseServiceDescription = (sdEl) => ({
-    id: getAttr(sdEl, 'id'),
-    scopes: findChildren(sdEl, 'Scope').map(parseGenericDescriptor),
-    latencies: findChildren(sdEl, 'Latency').map((el) => ({
-        min: getAttr(el, 'min') ? parseInt(getAttr(el, 'min'), 10) : null,
-        max: getAttr(el, 'max') ? parseInt(getAttr(el, 'max'), 10) : null,
-        target: getAttr(el, 'target')
-            ? parseInt(getAttr(el, 'target'), 10)
-            : null,
-        referenceId: getAttr(el, 'referenceId')
-            ? parseInt(getAttr(el, 'referenceId'), 10)
-            : null,
-    })),
-    playbackRates: findChildren(sdEl, 'PlaybackRate').map((el) => ({
-        min: getAttr(el, 'min') ? parseFloat(getAttr(el, 'min')) : null,
-        max: getAttr(el, 'max') ? parseFloat(getAttr(el, 'max')) : null,
-    })),
-    serializedManifest: sdEl,
-});
-
-function parsePeriod(periodEl, parentMergedEl) {
-    const mergedPeriodEl = mergeElements(parentMergedEl, periodEl);
-    const assetIdentifierEl = findChild(periodEl, 'AssetIdentifier');
-    const subsets = findChildren(periodEl, 'Subset');
-    const eventStreams = findChildren(periodEl, 'EventStream');
-    const periodStart = parseDuration(getAttr(periodEl, 'start')) || 0;
-
-    const allEvents = [];
-    const eventStreamIRs = eventStreams.map((esEl) => {
-        const schemeIdUri = getAttr(esEl, 'schemeIdUri');
-        const timescale = parseInt(getAttr(esEl, 'timescale') || '1', 10);
-        const presentationTimeOffset = parseInt(
-            getAttr(esEl, 'presentationTimeOffset') || '0',
-            10
-        );
-
-        const events = findChildren(esEl, 'Event').map((eEl) => {
-            const presentationTime = parseInt(
-                getAttr(eEl, 'presentationTime') || '0',
-                10
-            );
-            const duration = parseInt(getAttr(eEl, 'duration') || '0', 10);
-            const startTime =
-                periodStart +
-                (presentationTime - presentationTimeOffset) / timescale;
-            const eventDuration = duration / timescale;
-            const messageData = getAttr(eEl, 'messageData');
-
-            const event = {
-                startTime,
-                duration: eventDuration,
-                message: getText(eEl) || messageData,
-                messageData: messageData,
-                type: 'dash-event',
-                cue: null,
-            };
-
-            if (messageData && schemeIdUri?.toLowerCase().includes('scte35')) {
-                try {
-                    const binaryData = Uint8Array.from(atob(messageData), (c) =>
-                        c.charCodeAt(0)
-                    );
-                    event.scte35 = parseScte35(binaryData);
-                } catch (e) {
-                    console.error(
-                        'Failed to parse SCTE-35 from DASH Event:',
-                        e
-                    );
-                }
-            }
-
-            return event;
-        });
-
-        allEvents.push(...events);
-
-        return {
-            schemeIdUri: schemeIdUri,
-            value: getAttr(esEl, 'value'),
-            timescale,
-            presentationTimeOffset,
-            events: [], // Events are aggregated at the Period level for the IR
-        };
-    });
-
-    /** @type {Period} */
-    const periodIR = {
-        id: getAttr(periodEl, 'id'),
-        start: periodStart,
-        duration: parseDuration(getAttr(periodEl, 'duration')),
-        bitstreamSwitching: getAttr(periodEl, 'bitstreamSwitching') === 'true',
-        assetIdentifier: assetIdentifierEl
-            ? {
-                  schemeIdUri: getAttr(assetIdentifierEl, 'schemeIdUri'),
-                  value: getAttr(assetIdentifierEl, 'value'),
-              }
-            : null,
-        subsets: subsets.map((s) => ({
-            contains: (getAttr(s, 'contains') || '').split(' '),
-            id: getAttr(s, 'id'),
-        })),
-        adaptationSets: findChildren(periodEl, 'AdaptationSet').map((asEl) =>
-            parseAdaptationSet(asEl, mergedPeriodEl)
-        ),
-        preselections: findChildren(periodEl, 'Preselection').map((pEl) =>
-            parsePreselection(pEl, mergedPeriodEl)
-        ),
-        serviceDescriptions: findChildren(periodEl, 'ServiceDescription').map(
-            parseServiceDescription
-        ),
-        eventStreams: eventStreamIRs,
-        events: allEvents,
-        serializedManifest: periodEl,
-    };
-
-    return periodIR;
-}
-
-/**
- * Transforms a serialized DASH manifest object into a protocol-agnostic IR.
- * @param {object} manifestElement The root MPD element, serialized.
- * @param {string} baseUrl The base URL for the manifest.
- * @returns {Manifest} The manifest IR object.
- */
-export function adaptDashToIr(manifestElement, baseUrl) {
-    const manifestCopy = deepClone(manifestElement);
-
-    const adaptationSets = findChildrenRecursive(manifestCopy, 'AdaptationSet');
-    const hasTsMimeType = adaptationSets.some(
-        (as) => getAttr(as, 'mimeType') === 'video/mp2t'
-    );
-
-    let segmentFormat = 'unknown';
-    if (hasTsMimeType) {
-        segmentFormat = 'ts';
-    } else if (
-        findChildrenRecursive(manifestCopy, 'SegmentTimeline').length > 0 ||
-        findChildrenRecursive(manifestCopy, 'SegmentTemplate').length > 0 ||
-        findChildrenRecursive(manifestCopy, 'SegmentList').length > 0
-    ) {
-        segmentFormat = 'isobmff';
-    }
-
-    /** @type {Manifest} */
-    const manifestIR = {
-        id: getAttr(manifestCopy, 'id'),
-        type: getAttr(manifestCopy, 'type'),
-        profiles: getAttr(manifestCopy, 'profiles'),
-        minBufferTime: parseDuration(getAttr(manifestCopy, 'minBufferTime')),
-        publishTime: getAttr(manifestCopy, 'publishTime')
-            ? new Date(getAttr(manifestCopy, 'publishTime'))
-            : null,
-        availabilityStartTime: getAttr(manifestCopy, 'availabilityStartTime')
-            ? new Date(getAttr(manifestCopy, 'availabilityStartTime'))
-            : null,
-        timeShiftBufferDepth: parseDuration(
-            getAttr(manifestCopy, 'timeShiftBufferDepth')
-        ),
-        minimumUpdatePeriod: parseDuration(
-            getAttr(manifestCopy, 'minimumUpdatePeriod')
-        ),
-        duration: parseDuration(
-            getAttr(manifestCopy, 'mediaPresentationDuration')
-        ),
-        maxSegmentDuration: parseDuration(
-            getAttr(manifestCopy, 'maxSegmentDuration')
-        ),
-        maxSubsegmentDuration: parseDuration(
-            getAttr(manifestCopy, 'maxSubsegmentDuration')
-        ),
-        programInformations: findChildren(
-            manifestCopy,
-            'ProgramInformation'
-        ).map((el) => ({
-            title: getText(findChild(el, 'Title')),
-            source: getText(findChild(el, 'Source')),
-            copyright: getText(findChild(el, 'Copyright')),
-            lang: getAttr(el, 'lang'),
-            moreInformationURL: getAttr(el, 'moreInformationURL'),
-        })),
-        locations: findChildren(manifestCopy, 'Location').map(getText),
-        patchLocations: findChildren(manifestCopy, 'PatchLocation').map(
-            getText
-        ),
-        serviceDescriptions: findChildren(
-            manifestCopy,
-            'ServiceDescription'
-        ).map(parseServiceDescription),
-        initializationSets: findChildren(manifestCopy, 'InitializationSet').map(
-            (el) => ({
-                id: getAttr(el, 'id'),
-                inAllPeriods: getAttr(el, 'inAllPeriods') !== 'false',
-                contentType: getAttr(el, 'contentType'),
-                initialization: getAttr(el, 'initialization'),
-                codecs: getAttr(el, 'codecs'),
-                serializedManifest: el,
-            })
-        ),
-        periods: findChildren(manifestCopy, 'Period').map((p) =>
-            parsePeriod(p, manifestCopy)
-        ),
-        segmentFormat: /** @type {'isobmff' | 'ts' | 'unknown'} */ (
-            segmentFormat
-        ),
-        serializedManifest: manifestElement,
-        metrics: [],
-        events: [],
-        summary: null,
-        serverControl: null,
-    };
-
-    manifestIR.events = manifestIR.periods.flatMap((p) => p.events);
-    manifestIR.summary = generateDashSummary(manifestIR, manifestCopy);
-
-    return manifestIR;
-}
diff --git a/js/infrastructure/manifest/dash/compliance-rules/best-practices.js b/js/infrastructure/manifest/dash/compliance-rules/best-practices.js
deleted file mode 100644
index d30344b..0000000
--- a/js/infrastructure/manifest/dash/compliance-rules/best-practices.js
+++ /dev/null
@@ -1,77 +0,0 @@
-import { findChildren, getAttr } from '../recursive-parser.js';
-
-/** @typedef {import('./index.js').Rule} Rule */
-
-/** @type {Rule[]} */
-export const bestPracticeRules = [
-    {
-        id: 'AS-1',
-        text: 'AdaptationSet has @contentType or @mimeType',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-        severity: 'warn',
-        scope: 'AdaptationSet',
-        profiles: ['common'],
-        category: 'General Best Practices',
-        check: (as) =>
-            getAttr(as, 'contentType') !== undefined ||
-            getAttr(as, 'mimeType') !== undefined,
-        passDetails: 'OK',
-        failDetails: 'Recommended for clear track identification.',
-    },
-    {
-        id: 'AS-2',
-        text: 'AdaptationSet with multiple Representations uses Segment Alignment',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-        severity: 'warn',
-        scope: 'AdaptationSet',
-        profiles: ['common'],
-        category: 'General Best Practices',
-        check: (as) =>
-            findChildren(as, 'Representation').length > 1
-                ? getAttr(as, 'segmentAlignment') === 'true' ||
-                  getAttr(as, 'segmentAlignment') === 1
-                : 'skip',
-        passDetails: 'OK',
-        failDetails: 'Recommended for seamless ABR switching.',
-    },
-    {
-        id: 'AS-3',
-        text: 'AdaptationSet switching descriptor references valid IDs',
-        isoRef: 'Clause 5.3.3.5',
-        severity: 'warn',
-        scope: 'AdaptationSet',
-        profiles: ['common'],
-        category: 'General Best Practices',
-        check: (as, { period }) => {
-            const supplementalProperties = findChildren(
-                as,
-                'SupplementalProperty'
-            );
-            const switchingDescriptor = supplementalProperties.find(
-                (sp) =>
-                    getAttr(sp, 'schemeIdUri') ===
-                    'urn:mpeg:dash:adaptation-set-switching:2016'
-            );
-
-            if (!switchingDescriptor) return 'skip';
-
-            const allAdaptationSetIdsInPeriod = new Set(
-                findChildren(period, 'AdaptationSet')
-                    .map((a) => getAttr(a, 'id'))
-                    .filter(Boolean)
-            );
-
-            const referencedIds = (
-                getAttr(switchingDescriptor, 'value') || ''
-            ).split(',');
-            if (referencedIds.length === 0) return true; // Empty value is valid.
-
-            return referencedIds.every((id) =>
-                allAdaptationSetIdsInPeriod.has(id.trim())
-            );
-        },
-        passDetails: 'OK',
-        failDetails:
-            'One or more AdaptationSet IDs referenced in the switching descriptor do not exist in this Period.',
-    },
-];
diff --git a/js/infrastructure/manifest/dash/compliance-rules/index.js b/js/infrastructure/manifest/dash/compliance-rules/index.js
deleted file mode 100644
index 3b29c90..0000000
--- a/js/infrastructure/manifest/dash/compliance-rules/index.js
+++ /dev/null
@@ -1,41 +0,0 @@
-import {} from '../recursive-parser.js';
-import { structureRules } from './structure.js';
-import { liveRules } from './live.js';
-import { segmentRules } from './segments.js';
-import { profileRules } from './profiles.js';
-import { bestPracticeRules } from './best-practices.js';
-
-/**
- * @typedef {'error' | 'warn' | 'info' | 'pass' | 'fail'} CheckStatus
- */
-
-/**
- * @typedef {'Manifest Structure' | 'Live Stream Properties' | 'Segment & Timing Info' | 'Profile Conformance' | 'General Best Practices' | 'HLS Structure' | 'Encryption' | 'Interoperability'} RuleCategory
- */
-
-/**
- * @typedef {'MPD' | 'Period' | 'AdaptationSet' | 'Representation' | 'Playlist'} RuleScope
- */
-
-/**
- * @typedef {object} Rule
- * @property {string} id - A unique identifier for the rule.
- * @property {string} text - The human-readable title of the check.
- * @property {string} isoRef - The reference to the ISO/IEC 23009-1:2022 standard clause.
- * @property {CheckStatus} severity - The status to assign if the check fails ('fail' or 'warn').
- * @property {RuleScope} scope - The MPD element level this rule applies to.
- * @property {string[]} profiles - An array of DASH profiles this rule applies to. 'common' for general applicability.
- * @property {(element: object, context: object) => boolean | 'skip'} check - The function that performs the validation. Returns `true` for pass, `false` for fail/warn, or `'skip'` if not applicable.
- * @property {string | ((element: object, context: object) => string)} passDetails - Details for a passing check.
- * @property {string | ((element: object, context: object) => string)} failDetails - Details for a failing or warning check.
- * @property {RuleCategory} category
- */
-
-/** @type {Rule[]} */
-export const rules = [
-    ...structureRules,
-    ...liveRules,
-    ...segmentRules,
-    ...profileRules,
-    ...bestPracticeRules,
-];
diff --git a/js/infrastructure/manifest/dash/compliance-rules/live.js b/js/infrastructure/manifest/dash/compliance-rules/live.js
deleted file mode 100644
index 8d17ec5..0000000
--- a/js/infrastructure/manifest/dash/compliance-rules/live.js
+++ /dev/null
@@ -1,158 +0,0 @@
-import { findChild, findChildren, getAttr } from '../recursive-parser.js';
-
-/** @typedef {import('./index.js').Rule} Rule */
-
-/** @type {Rule[]} */
-export const liveRules = [
-    {
-        id: 'MPDPATCH-1',
-        text: 'PatchLocation requires MPD@id and @publishTime',
-        isoRef: 'Clause 5.15.2',
-        severity: 'fail',
-        scope: 'MPD',
-        profiles: ['isoff-live:2011', 'cmaf:2019'],
-        category: 'Live Stream Properties',
-        check: (mpd) => {
-            if (!findChild(mpd, 'PatchLocation')) return 'skip';
-            return (
-                getAttr(mpd, 'id') !== undefined &&
-                getAttr(mpd, 'publishTime') !== undefined
-            );
-        },
-        passDetails: 'OK',
-        failDetails:
-            'When <PatchLocation> is present, the <MPD> element must have both an @id and a @publishTime attribute.',
-    },
-    {
-        id: 'LIVE-1',
-        text: 'Dynamic MPD has @availabilityStartTime',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-        severity: 'fail',
-        scope: 'MPD',
-        profiles: ['isoff-live:2011', 'cmaf:2019', 'mp2t-main:2011'],
-        category: 'Live Stream Properties',
-        check: (mpd, { isDynamic }) =>
-            isDynamic
-                ? getAttr(mpd, 'availabilityStartTime') !== undefined
-                : 'skip',
-        passDetails: 'OK',
-        failDetails: 'Required for dynamic MPDs.',
-    },
-    {
-        id: 'LIVE-2',
-        text: 'Dynamic MPD has @publishTime',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-        severity: 'fail',
-        scope: 'MPD',
-        profiles: ['isoff-live:2011', 'cmaf:2019', 'mp2t-main:2011'],
-        category: 'Live Stream Properties',
-        check: (mpd, { isDynamic }) =>
-            isDynamic ? getAttr(mpd, 'publishTime') !== undefined : 'skip',
-        passDetails: 'OK',
-        failDetails: 'Required for dynamic MPDs.',
-    },
-    {
-        id: 'LIVE-3',
-        text: 'Dynamic MPD has @minimumUpdatePeriod',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-        severity: 'warn',
-        scope: 'MPD',
-        profiles: ['isoff-live:2011', 'cmaf:2019', 'mp2t-main:2011'],
-        category: 'Live Stream Properties',
-        check: (mpd, { isDynamic }) =>
-            isDynamic
-                ? getAttr(mpd, 'minimumUpdatePeriod') !== undefined
-                : 'skip',
-        passDetails: 'OK',
-        failDetails: 'Recommended for dynamic MPDs to signal update frequency.',
-    },
-    {
-        id: 'LIVE-4',
-        text: 'Dynamic MPD should contain a UTCTiming element',
-        isoRef: 'Clause 5.8.4.11',
-        severity: 'warn',
-        scope: 'MPD',
-        profiles: ['common'],
-        category: 'Live Stream Properties',
-        check: (mpd, { isDynamic }) => {
-            if (!isDynamic) return 'skip';
-            return findChildren(mpd, 'UTCTiming').length > 0;
-        },
-        passDetails: 'OK',
-        failDetails:
-            'Recommended for dynamic MPDs to provide a clock synchronization source for clients.',
-    },
-    {
-        id: 'PERIOD-1',
-        text: 'Dynamic Period has @id',
-        isoRef: 'Clause 5.3.2.2, Table 4',
-        severity: 'fail',
-        scope: 'Period',
-        profiles: ['isoff-live:2011', 'cmaf:2019', 'mp2t-main:2011'],
-        category: 'Live Stream Properties',
-        check: (period, { isDynamic }) =>
-            isDynamic ? getAttr(period, 'id') !== undefined : 'skip',
-        passDetails: 'OK',
-        failDetails: (period) =>
-            `Period (start="${getAttr(period, 'start')}") requires an @id in dynamic manifests.`,
-    },
-    {
-        id: 'LL-1',
-        text: 'Latency element requires target attribute',
-        isoRef: 'Annex K.3.2.2',
-        severity: 'fail',
-        scope: 'AdaptationSet',
-        profiles: ['isoff-live:2011', 'cmaf:2019'],
-        category: 'Live Stream Properties',
-        check: (as) => {
-            const serviceDescription = findChild(as, 'ServiceDescription');
-            if (!serviceDescription) return 'skip';
-            const latency = findChild(serviceDescription, 'Latency');
-            if (!latency) return 'skip';
-            return getAttr(latency, 'target') !== undefined;
-        },
-        passDetails: 'OK',
-        failDetails: 'The <Latency> element must have a @target attribute.',
-    },
-    {
-        id: 'LL-2',
-        text: 'Latency values should be logically consistent',
-        isoRef: 'Annex K.3.2.2',
-        severity: 'warn',
-        scope: 'MPD', // Can also be on Period, but MPD level covers all cases
-        profiles: ['isoff-live:2011', 'cmaf:2019'],
-        category: 'Live Stream Properties',
-        check: (mpd) => {
-            const serviceDescriptions = findChildren(mpd, 'ServiceDescription');
-            if (serviceDescriptions.length === 0) return 'skip';
-
-            for (const sd of serviceDescriptions) {
-                const latency = findChild(sd, 'Latency');
-                if (latency) {
-                    const min = getAttr(latency, 'min');
-                    const max = getAttr(latency, 'max');
-                    const target = getAttr(latency, 'target');
-
-                    if (
-                        min !== undefined &&
-                        target !== undefined &&
-                        min > target
-                    )
-                        return false;
-                    if (
-                        target !== undefined &&
-                        max !== undefined &&
-                        target > max
-                    )
-                        return false;
-                    if (min !== undefined && max !== undefined && min > max)
-                        return false;
-                }
-            }
-            return true;
-        },
-        passDetails: 'OK',
-        failDetails:
-            'Inconsistent latency values found. The logical order is @min <= @target <= @max.',
-    },
-];
diff --git a/js/infrastructure/manifest/dash/compliance-rules/profiles.js b/js/infrastructure/manifest/dash/compliance-rules/profiles.js
deleted file mode 100644
index 8bdaff5..0000000
--- a/js/infrastructure/manifest/dash/compliance-rules/profiles.js
+++ /dev/null
@@ -1,59 +0,0 @@
-import { findChild, getAttr } from '../recursive-parser.js';
-
-/** @typedef {import('./index.js').Rule} Rule */
-
-/** @type {Rule[]} */
-export const profileRules = [
-    {
-        id: 'PROFILE-ONDEMAND-1',
-        text: 'On-Demand profile requires MPD@type="static"',
-        isoRef: 'Clause 8.3.2',
-        severity: 'fail',
-        scope: 'MPD',
-        profiles: ['isoff-on-demand:2011'],
-        category: 'Profile Conformance',
-        check: (mpd) => getAttr(mpd, 'type') === 'static',
-        passDetails: 'OK',
-        failDetails: (mpd) =>
-            `Profile requires 'static', but found '${getAttr(mpd, 'type')}'`,
-    },
-    {
-        id: 'PROFILE-LIVE-1',
-        text: 'Live profile requires SegmentTemplate',
-        isoRef: 'Clause 8.4.2',
-        severity: 'fail',
-        scope: 'Representation',
-        profiles: ['isoff-live:2011'],
-        category: 'Profile Conformance',
-        check: (rep, { adaptationSet, period }) =>
-            !!(
-                findChild(rep, 'SegmentTemplate') ||
-                findChild(adaptationSet, 'SegmentTemplate') ||
-                findChild(period, 'SegmentTemplate')
-            ),
-        passDetails: 'OK',
-        failDetails: 'SegmentTemplate must be used in this profile.',
-    },
-    {
-        id: 'PROFILE-CMAF-1',
-        text: "CMAF profile requires 'cmfc' or 'cmf2' brand",
-        isoRef: 'Clause 8.12.4.3',
-        severity: 'fail',
-        scope: 'AdaptationSet',
-        profiles: ['cmaf:2019'],
-        category: 'Profile Conformance',
-        check: (as) => {
-            const mimeType = getAttr(as, 'mimeType');
-            if (mimeType !== 'video/mp4' && mimeType !== 'audio/mp4')
-                return 'skip';
-            const containerProfiles = getAttr(as, 'containerProfiles') || '';
-            return (
-                containerProfiles.includes('cmfc') ||
-                containerProfiles.includes('cmf2')
-            );
-        },
-        passDetails: 'OK',
-        failDetails:
-            'AdaptationSet is missing a CMAF structural brand in @containerProfiles.',
-    },
-];
diff --git a/js/infrastructure/manifest/dash/compliance-rules/segments.js b/js/infrastructure/manifest/dash/compliance-rules/segments.js
deleted file mode 100644
index dc9ea79..0000000
--- a/js/infrastructure/manifest/dash/compliance-rules/segments.js
+++ /dev/null
@@ -1,79 +0,0 @@
-import {
-    findChild,
-    getInheritedElement,
-    getAttr,
-} from '../recursive-parser.js';
-
-/** @typedef {import('./index.js').Rule} Rule */
-
-/** @type {Rule[]} */
-export const segmentRules = [
-    {
-        id: 'SEGMENT-1',
-        text: 'Representation has exactly one segment information type',
-        isoRef: 'Clause 5.3.9.1',
-        severity: 'fail',
-        scope: 'Representation',
-        profiles: ['common'],
-        category: 'Segment & Timing Info',
-        check: (rep) => {
-            const elements = [
-                findChild(rep, 'SegmentBase'),
-                findChild(rep, 'SegmentList'),
-                findChild(rep, 'SegmentTemplate'),
-            ];
-            return elements.filter(Boolean).length <= 1;
-        },
-        passDetails: 'OK',
-        failDetails:
-            'A Representation can only contain one of SegmentBase, SegmentList, or SegmentTemplate directly.',
-    },
-    {
-        id: 'SEGMENT-2',
-        text: 'SegmentTemplate with $Number$ has duration info',
-        isoRef: 'Clause 5.3.9.5.3',
-        severity: 'fail',
-        scope: 'Representation',
-        profiles: ['isoff-live:2011', 'cmaf:2019', 'isoff-on-demand:2011'],
-        category: 'Segment & Timing Info',
-        check: (rep, { adaptationSet, period }) => {
-            const hierarchy = [rep, adaptationSet, period];
-            const template = getInheritedElement('SegmentTemplate', hierarchy);
-            const mediaAttr = getAttr(template, 'media');
-
-            if (!template || !mediaAttr?.includes('$Number$')) {
-                return 'skip';
-            }
-
-            const duration = getAttr(template, 'duration');
-            return (
-                duration !== undefined ||
-                !!findChild(template, 'SegmentTimeline')
-            );
-        },
-        passDetails: 'OK',
-        failDetails:
-            'When using $Number$, either @duration must be specified or a SegmentTimeline must be present.',
-    },
-    {
-        id: 'SEGMENT-3',
-        text: 'SegmentTemplate with $Time$ has SegmentTimeline',
-        isoRef: 'Clause 5.3.9.4.4, Table 21',
-        severity: 'fail',
-        scope: 'Representation',
-        profiles: ['isoff-live:2011', 'cmaf:2019'],
-        category: 'Segment & Timing Info',
-        check: (rep, { adaptationSet, period }) => {
-            const hierarchy = [rep, adaptationSet, period];
-            const template = getInheritedElement('SegmentTemplate', hierarchy);
-
-            if (!template || !getAttr(template, 'media')?.includes('$Time$')) {
-                return 'skip';
-            }
-            return !!findChild(template, 'SegmentTimeline');
-        },
-        passDetails: 'OK',
-        failDetails:
-            'When using $Time$, a SegmentTimeline must be present within the SegmentTemplate.',
-    },
-];
diff --git a/js/infrastructure/manifest/dash/compliance-rules/structure.js b/js/infrastructure/manifest/dash/compliance-rules/structure.js
deleted file mode 100644
index c91b294..0000000
--- a/js/infrastructure/manifest/dash/compliance-rules/structure.js
+++ /dev/null
@@ -1,222 +0,0 @@
-import { findChildren, getAttr } from '../recursive-parser.js';
-
-/** @typedef {import('./index.js').Rule} Rule */
-
-/** @type {Rule[]} */
-export const structureRules = [
-    {
-        id: 'MPD-1',
-        text: 'MPD root element must exist',
-        isoRef: 'Clause 5.3.1.2',
-        severity: 'fail',
-        scope: 'MPD',
-        profiles: ['common'],
-        category: 'Manifest Structure',
-        check: (mpd) => !!mpd,
-        passDetails: 'OK',
-        failDetails:
-            'The document could not be parsed or does not contain an MPD root element.',
-    },
-    {
-        id: 'MPD-2',
-        text: 'MPD@profiles is mandatory',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-        severity: 'fail',
-        scope: 'MPD',
-        profiles: ['common'],
-        category: 'Manifest Structure',
-        check: (mpd) =>
-            getAttr(mpd, 'profiles') !== undefined &&
-            getAttr(mpd, 'profiles') !== '',
-        passDetails: 'OK',
-        failDetails:
-            'The @profiles attribute is mandatory and must not be empty.',
-    },
-    {
-        id: 'MPD-3',
-        text: 'MPD@minBufferTime is mandatory',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-        severity: 'fail',
-        scope: 'MPD',
-        profiles: ['common'],
-        category: 'Manifest Structure',
-        check: (mpd) => getAttr(mpd, 'minBufferTime') !== undefined,
-        passDetails: 'OK',
-        failDetails: 'The @minBufferTime attribute is mandatory.',
-    },
-    {
-        id: 'MPD-4',
-        text: 'MPD@type is mandatory',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-        severity: 'fail',
-        scope: 'MPD',
-        profiles: ['common'],
-        category: 'Manifest Structure',
-        check: (mpd) =>
-            getAttr(mpd, 'type') === 'static' ||
-            getAttr(mpd, 'type') === 'dynamic',
-        passDetails: 'OK',
-        failDetails:
-            'The @type attribute is mandatory and must be either "static" or "dynamic".',
-    },
-    {
-        id: 'MPD-5',
-        text: 'At most one BaseURL at the MPD level',
-        isoRef: 'Clause 5.6',
-        severity: 'fail',
-        scope: 'MPD',
-        profiles: ['common'],
-        category: 'Manifest Structure',
-        check: (mpd) => findChildren(mpd, 'BaseURL').length <= 1,
-        passDetails: 'OK',
-        failDetails: 'The MPD element may contain at most one BaseURL element.',
-    },
-    {
-        id: 'STATIC-1',
-        text: 'Static MPD has a defined duration',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-        severity: 'fail',
-        scope: 'MPD',
-        profiles: ['isoff-on-demand:2011', 'common'],
-        category: 'Manifest Structure',
-        check: (mpd, { isDynamic }) => {
-            if (isDynamic) return 'skip';
-            const hasMpdDuration =
-                getAttr(mpd, 'mediaPresentationDuration') !== undefined;
-            const periods = findChildren(mpd, 'Period');
-            const lastPeriod = periods[periods.length - 1];
-            const lastPeriodHasDuration = lastPeriod
-                ? getAttr(lastPeriod, 'duration') !== undefined
-                : false;
-            return hasMpdDuration || lastPeriodHasDuration;
-        },
-        passDetails: 'OK',
-        failDetails:
-            'Static MPDs must have @mediaPresentationDuration or the last Period must have a @duration.',
-    },
-    {
-        id: 'STATIC-2',
-        text: 'Static MPD does not have @minimumUpdatePeriod',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-        severity: 'fail',
-        scope: 'MPD',
-        profiles: ['isoff-on-demand:2011', 'common'],
-        category: 'Manifest Structure',
-        check: (mpd, { isDynamic }) =>
-            isDynamic
-                ? 'skip'
-                : getAttr(mpd, 'minimumUpdatePeriod') === undefined,
-        passDetails: 'OK',
-        failDetails: 'Should not be present for static MPDs.',
-    },
-    {
-        id: 'STATIC-3',
-        text: 'Static MPD does not have @timeShiftBufferDepth',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-        severity: 'fail',
-        scope: 'MPD',
-        profiles: ['isoff-on-demand:2011', 'common'],
-        category: 'Manifest Structure',
-        check: (mpd, { isDynamic }) =>
-            isDynamic
-                ? 'skip'
-                : getAttr(mpd, 'timeShiftBufferDepth') === undefined,
-        passDetails: 'OK',
-        failDetails: 'Should not be present for static MPDs.',
-    },
-    {
-        id: 'PERIOD-2',
-        text: 'Period contains at least one AdaptationSet',
-        isoRef: 'Clause 5.3.2.2, Table 4',
-        severity: 'warn',
-        scope: 'Period',
-        profiles: ['common'],
-        category: 'Manifest Structure',
-        check: (period) => {
-            const duration = getAttr(period, 'duration');
-            return (
-                findChildren(period, 'AdaptationSet').length > 0 ||
-                duration === 'PT0S' ||
-                duration === '0'
-            );
-        },
-        passDetails: 'OK',
-        failDetails:
-            'A Period should contain at least one AdaptationSet unless its duration is 0.',
-    },
-    {
-        id: 'PERIOD-3',
-        text: 'EventStream requires @schemeIdUri',
-        isoRef: 'Clause 5.10.2, Table 24',
-        severity: 'fail',
-        scope: 'Period',
-        profiles: ['common'],
-        category: 'Manifest Structure',
-        check: (period) => {
-            const eventStreams = findChildren(period, 'EventStream');
-            if (eventStreams.length === 0) return 'skip';
-            return eventStreams.every((es) => getAttr(es, 'schemeIdUri'));
-        },
-        passDetails: 'OK',
-        failDetails:
-            'All EventStream elements must have a schemeIdUri attribute.',
-    },
-    {
-        id: 'REP-1',
-        text: 'Representation has mandatory @id',
-        isoRef: 'Clause 5.3.5.2, Table 9',
-        severity: 'fail',
-        scope: 'Representation',
-        profiles: ['common'],
-        category: 'Manifest Structure',
-        check: (rep) => getAttr(rep, 'id') !== undefined,
-        passDetails: 'OK',
-        failDetails: 'Representation @id is mandatory.',
-    },
-    {
-        id: 'REP-2',
-        text: 'Representation has mandatory @bandwidth',
-        isoRef: 'Clause 5.3.5.2, Table 9',
-        severity: 'fail',
-        scope: 'Representation',
-        profiles: ['common'],
-        category: 'Manifest Structure',
-        check: (rep) => getAttr(rep, 'bandwidth') !== undefined,
-        passDetails: 'OK',
-        failDetails: 'Representation @bandwidth is mandatory.',
-    },
-    {
-        id: 'REP-3',
-        text: 'Representation has an effective @mimeType',
-        isoRef: 'Clause 5.3.7.2, Table 14',
-        severity: 'fail',
-        scope: 'Representation',
-        profiles: ['common'],
-        category: 'Manifest Structure',
-        check: (rep, { adaptationSet }) =>
-            getAttr(rep, 'mimeType') !== undefined ||
-            getAttr(adaptationSet, 'mimeType') !== undefined,
-        passDetails: 'OK',
-        failDetails:
-            'Representation @mimeType must be present on the Representation or inherited from the AdaptationSet.',
-    },
-    {
-        id: 'REP-4',
-        text: 'Representation @dependencyId is valid',
-        isoRef: 'Clause 5.3.5.2, Table 9',
-        severity: 'warn',
-        scope: 'Representation',
-        profiles: ['common'],
-        category: 'Manifest Structure',
-        check: (rep, { allRepIdsInPeriod }) => {
-            const dependencyId = getAttr(rep, 'dependencyId');
-            if (!dependencyId) return 'skip';
-            return dependencyId
-                .split(' ')
-                .every((id) => allRepIdsInPeriod.has(id));
-        },
-        passDetails: 'OK',
-        failDetails: (rep) =>
-            `One or more IDs in @dependencyId="${getAttr(rep, 'dependencyId')}" do not exist in this Period.`,
-    },
-];
diff --git a/js/infrastructure/manifest/dash/feature-analyzer.js b/js/infrastructure/manifest/dash/feature-analyzer.js
deleted file mode 100644
index 353863b..0000000
--- a/js/infrastructure/manifest/dash/feature-analyzer.js
+++ /dev/null
@@ -1,295 +0,0 @@
-import { getDrmSystemName } from '../../../shared/utils/drm.js';
-import { getAttr, findChildrenRecursive } from './recursive-parser.js';
-
-/**
- * @typedef {object} FeatureCheckResult
- * @property {boolean} used
- * @property {string} details
- */
-
-// Local helper to get the first result from the recursive search.
-const findChildRecursive = (element, tagName) =>
-    findChildrenRecursive(element, tagName)[0];
-
-const createCheck = (tagName, usedDetails, notUsedDetails) => {
-    return (manifestObj) => {
-        const element = findChildRecursive(manifestObj, tagName);
-        return {
-            used: !!element,
-            details: element ? usedDetails(element) : notUsedDetails,
-        };
-    };
-};
-
-const createCountCheck = (tagName, singular, plural) => {
-    return (manifestObj) => {
-        const elements = findChildrenRecursive(manifestObj, tagName);
-        const count = elements.length;
-        if (count === 0) {
-            return { used: false, details: '' };
-        }
-        const noun = count === 1 ? singular : plural;
-        return {
-            used: true,
-            details: `${count} ${noun} found.`,
-        };
-    };
-};
-
-const featureChecks = {
-    'Presentation Type': (manifestObj) => ({
-        used: true,
-        details: `<code>${getAttr(manifestObj, 'type')}</code>`,
-    }),
-    'MPD Locations': createCountCheck(
-        'Location',
-        'location',
-        'locations provided'
-    ),
-    'Scoped Profiles': (manifestObj) => {
-        const adaptationSets = findChildrenRecursive(
-            manifestObj,
-            'AdaptationSet'
-        );
-        const representations = findChildrenRecursive(
-            manifestObj,
-            'Representation'
-        );
-        const count =
-            adaptationSets.filter((as) => getAttr(as, 'profiles')).length +
-            representations.filter((r) => getAttr(r, 'profiles')).length;
-
-        if (count === 0) return { used: false, details: '' };
-        const noun = count === 1 ? 'scoped profile' : 'scoped profiles';
-        return { used: true, details: `${count} ${noun}` };
-    },
-    'Multi-Period': createCountCheck('Period', 'Period', 'Periods'),
-    'Content Protection': (manifestObj) => {
-        const protection = findChildrenRecursive(
-            manifestObj,
-            'ContentProtection'
-        );
-        if (protection.length > 0) {
-            const schemes = [
-                ...new Set(
-                    protection.map((cp) =>
-                        getDrmSystemName(getAttr(cp, 'schemeIdUri'))
-                    )
-                ),
-            ];
-            return {
-                used: true,
-                details: `Systems: <b>${schemes.join(', ')}</b>`,
-            };
-        }
-        return { used: false, details: 'No encryption descriptors found.' };
-    },
-    'Client Authentication': createCheck(
-        'EssentialProperty',
-        () => 'Signals requirement for client authentication.',
-        ''
-    ),
-    'Content Authorization': createCheck(
-        'SupplementalProperty',
-        () => 'Signals requirement for content authorization.',
-        ''
-    ),
-    'Segment Templates': createCheck(
-        'SegmentTemplate',
-        () => 'Uses templates for segment URL generation.',
-        ''
-    ),
-    'Segment Timeline': createCheck(
-        'SegmentTimeline',
-        () =>
-            'Provides explicit segment timing via <code>&lt;S&gt;</code> elements.',
-        ''
-    ),
-    'Segment List': createCheck(
-        'SegmentList',
-        () => 'Provides an explicit list of segment URLs.',
-        ''
-    ),
-    'Representation Index': createCountCheck(
-        'RepresentationIndex',
-        'representation index',
-        'representation indices'
-    ),
-    'Low Latency Streaming': (manifestObj) => {
-        if (getAttr(manifestObj, 'type') !== 'dynamic') {
-            return { used: false, details: 'Not a dynamic (live) manifest.' };
-        }
-        const hasLatency = !!findChildRecursive(manifestObj, 'Latency');
-        const allTemplates = findChildrenRecursive(
-            manifestObj,
-            'SegmentTemplate'
-        );
-        const hasChunkHint = allTemplates.some(
-            (t) => getAttr(t, 'availabilityTimeComplete') === 'false'
-        );
-
-        if (hasLatency || hasChunkHint) {
-            const details = [];
-            if (hasLatency)
-                details.push('<code>&lt;Latency&gt;</code> target defined.');
-            if (hasChunkHint) details.push('Chunked transfer hint present.');
-            return { used: true, details: details.join(' ') };
-        }
-        return {
-            used: false,
-            details: 'No specific low-latency signals found.',
-        };
-    },
-    'Manifest Patch Updates': createCheck(
-        'PatchLocation',
-        (el) => `Patch location: <code>${el['#text']?.trim()}</code>`,
-        'Uses full manifest reloads.'
-    ),
-    'UTC Timing Source': (manifestObj) => {
-        const utcTimings = findChildrenRecursive(manifestObj, 'UTCTiming');
-        if (utcTimings.length > 0) {
-            const schemes = [
-                ...new Set(
-                    utcTimings.map(
-                        (el) =>
-                            `<code>${getAttr(el, 'schemeIdUri')
-                                .split(':')
-                                .pop()}</code>`
-                    )
-                ),
-            ];
-            return { used: true, details: `Schemes: ${schemes.join(', ')}` };
-        }
-        return {
-            used: false,
-            details: 'No clock synchronization source provided.',
-        };
-    },
-    'Dependent Representations': (manifestObj) => {
-        const reps = findChildrenRecursive(
-            manifestObj,
-            'Representation'
-        ).filter((r) => getAttr(r, 'dependencyId'));
-        if (reps.length > 0)
-            return {
-                used: true,
-                details: `${reps.length} dependent Representations`,
-            };
-        return { used: false, details: '' };
-    },
-    'Associated Representations': (manifestObj) => {
-        const reps = findChildrenRecursive(
-            manifestObj,
-            'Representation'
-        ).filter((r) => getAttr(r, 'associationId'));
-        if (reps.length > 0)
-            return { used: true, details: `${reps.length} associations` };
-        return { used: false, details: '' };
-    },
-    'Trick Modes': (manifestObj) => {
-        const subRep = findChildRecursive(manifestObj, 'SubRepresentation');
-        const trickRole = findChildrenRecursive(manifestObj, 'Role').some(
-            (r) => getAttr(r, 'value') === 'trick'
-        );
-        if (subRep || trickRole) {
-            const details = [];
-            if (subRep) details.push('<code>&lt;SubRepresentation&gt;</code>');
-            if (trickRole) details.push('<code>Role="trick"</code>');
-            return {
-                used: true,
-                details: `Detected via: ${details.join(', ')}`,
-            };
-        }
-        return {
-            used: false,
-            details: 'No explicit trick mode signals found.',
-        };
-    },
-    'Subtitles & Captions': (manifestObj) => {
-        const textTracks = findChildrenRecursive(
-            manifestObj,
-            'AdaptationSet'
-        ).filter(
-            (as) =>
-                getAttr(as, 'contentType') === 'text' ||
-                getAttr(as, 'mimeType')?.startsWith('application')
-        );
-        if (textTracks.length > 0) {
-            const languages = [
-                ...new Set(
-                    textTracks.map((as) => getAttr(as, 'lang')).filter(Boolean)
-                ),
-            ];
-            return {
-                used: true,
-                details: `Found ${textTracks.length} track(s). ${
-                    languages.length > 0
-                        ? `Languages: <b>${languages.join(', ')}</b>`
-                        : ''
-                }`,
-            };
-        }
-        return {
-            used: false,
-            details: 'No text or application AdaptationSets found.',
-        };
-    },
-    'Role Descriptors': (manifestObj) => {
-        const roles = findChildrenRecursive(manifestObj, 'Role');
-        if (roles.length > 0) {
-            const roleValues = [
-                ...new Set(
-                    roles.map(
-                        (role) => `<code>${getAttr(role, 'value')}</code>`
-                    )
-                ),
-            ];
-            return {
-                used: true,
-                details: `Roles found: ${roleValues.join(', ')}`,
-            };
-        }
-        return { used: false, details: 'No roles specified.' };
-    },
-    'MPD Events': createCheck(
-        'EventStream',
-        () => 'Uses <EventStream> for out-of-band event signaling.',
-        ''
-    ),
-    'Inband Events': createCheck(
-        'InbandEventStream',
-        () => 'Uses <InbandEventStream> to signal events within segments.',
-        ''
-    ),
-};
-
-/**
- * Runs a series of DASH-specific checks against a serialized manifest object.
- * @param {object} manifestObject - The serialized manifest object.
- * @returns {Record<string, FeatureCheckResult>} A map of feature names to their analysis results.
- */
-export function analyzeDashFeatures(manifestObject) {
-    /** @type {Record<string, FeatureCheckResult>} */
-    const results = {};
-
-    if (!manifestObject) {
-        return {
-            Error: {
-                used: true,
-                details:
-                    'Serialized XML object was not found for feature analysis.',
-            },
-        };
-    }
-
-    for (const [name, checkFn] of Object.entries(featureChecks)) {
-        try {
-            results[name] = checkFn(manifestObject);
-        } catch (error) {
-            console.error(`Error analyzing feature "${name}":`, error);
-            results[name] = { used: false, details: 'Analysis failed.' };
-        }
-    }
-
-    return results;
-}
diff --git a/js/infrastructure/manifest/dash/feature-definitions.js b/js/infrastructure/manifest/dash/feature-definitions.js
deleted file mode 100644
index 7522ee8..0000000
--- a/js/infrastructure/manifest/dash/feature-definitions.js
+++ /dev/null
@@ -1,341 +0,0 @@
-/**
- * @typedef {object} Feature
- * @property {string} name
- * @property {'Core Streaming' | 'Timeline & Segment Management' | 'Live & Dynamic' | 'Advanced Content' | 'Client Guidance & Optimization' | 'Accessibility & Metadata'} category
- * @property {string} desc
- * @property {string} isoRef
- */
-
-/** @type {Feature[]} */
-export const dashFeatureDefinitions = [
-    {
-        name: 'Presentation Type',
-        category: 'Core Streaming',
-        desc: 'Defines if the stream is live (`dynamic`) or on-demand (`static`).',
-        isoRef: 'DASH: 5.3.1.2',
-    },
-    {
-        name: 'MPD Locations',
-        category: 'Core Streaming',
-        desc: 'Provides alternative URLs where the MPD can be fetched, enabling CDN redundancy.',
-        isoRef: 'DASH: 5.3.1.2',
-    },
-    {
-        name: 'Scoped Profiles',
-        category: 'Core Streaming',
-        desc: 'Declares profile conformance for specific Adaptation Sets or Representations, allowing for mixed-profile manifests.',
-        isoRef: 'DASH: 5.3.7.2',
-    },
-    {
-        name: 'Multi-Period',
-        category: 'Core Streaming',
-        desc: 'The presentation is split into multiple, independent periods. Commonly used for Server-Side Ad Insertion (SSAI).',
-        isoRef: 'DASH: 5.3.2',
-    },
-    {
-        name: 'Content Protection',
-        category: 'Core Streaming',
-        desc: 'Indicates that the content is encrypted using one or more schemes like CENC.',
-        isoRef: 'DASH: 5.8.4.1',
-    },
-    {
-        name: 'Client Authentication',
-        category: 'Core Streaming',
-        desc: 'Signals that client authentication is required to access the content, typically via an EssentialProperty descriptor.',
-        isoRef: 'DASH: 5.8.5.11',
-    },
-    {
-        name: 'Content Authorization',
-        category: 'Core Streaming',
-        desc: 'Signals that content authorization is required to access the content, often in conjunction with Client Authentication.',
-        isoRef: 'DASH: 5.8.5.11',
-    },
-    {
-        name: 'Segment Templates',
-        category: 'Timeline & Segment Management',
-        desc: 'Segment URLs are generated using a template, typically with $Number$ or $Time$ placeholders.',
-        isoRef: 'DASH: 5.3.9.4',
-    },
-    {
-        name: 'Segment Timeline',
-        category: 'Timeline & Segment Management',
-        desc: 'Provides explicit timing and duration for each segment via <S> elements, allowing for variable segment sizes.',
-        isoRef: 'DASH: 5.3.9.6',
-    },
-    {
-        name: 'Segment List',
-        category: 'Timeline & Segment Management',
-        desc: 'Segment URLs are listed explicitly in the manifest. Common for VOD content.',
-        isoRef: 'DASH: 5.3.9.3',
-    },
-    {
-        name: 'Representation Index',
-        category: 'Timeline & Segment Management',
-        desc: 'Provides an index for the entire Representation in a single segment, separate from media segments.',
-        isoRef: 'DASH: 5.3.9.2.2',
-    },
-    {
-        name: 'MPD Chaining',
-        category: 'Timeline & Segment Management',
-        desc: 'The manifest indicates that another MPD should be played after this one concludes, allowing for programmatic playlists of presentations.',
-        isoRef: 'DASH: 5.11',
-    },
-    {
-        name: 'Failover Content',
-        category: 'Timeline & Segment Management',
-        desc: 'Signals time ranges where content may be replaced by failover content (e.g., slate) due to encoding errors.',
-        isoRef: 'DASH: 5.3.9.7',
-    },
-    {
-        name: 'Low Latency Streaming',
-        category: 'Live & Dynamic',
-        desc: 'The manifest includes features for low-latency playback, such as chunked transfer hints or specific service descriptions.',
-        isoRef: 'DASH: Annex K.3.2',
-    },
-    {
-        name: 'Manifest Patch Updates',
-        category: 'Live & Dynamic',
-        desc: 'Allows efficient manifest updates by sending only the changed parts of the manifest.',
-        isoRef: 'DASH: 5.15',
-    },
-    {
-        name: 'MPD Events',
-        category: 'Live & Dynamic',
-        desc: 'The manifest contains one or more <EventStream> elements, allowing timed metadata to be communicated to the client via the MPD.',
-        isoRef: 'DASH: 5.10.2',
-    },
-    {
-        name: 'Inband Events',
-        category: 'Live & Dynamic',
-        desc: 'The manifest signals that event messages ("emsg" boxes) are present within the media segments themselves, allowing for tightly synchronized metadata.',
-        isoRef: 'DASH: 5.10.3',
-    },
-    {
-        name: 'Producer Reference Time',
-        category: 'Live & Dynamic',
-        desc: 'Provides a mapping between media timestamps and a wall-clock production time, enabling latency measurement and control.',
-        isoRef: 'DASH: 5.12',
-    },
-    {
-        name: 'UTC Timing Source',
-        category: 'Live & Dynamic',
-        desc: 'Provides a source for clients to synchronize their wall-clock time, crucial for live playback.',
-        isoRef: 'DASH: 5.8.4.11',
-    },
-    {
-        name: 'Leap Second Information',
-        category: 'Live & Dynamic',
-        desc: 'Provides information on leap seconds to ensure accurate time calculations across time zones and daylight saving changes.',
-        isoRef: 'DASH: 5.13',
-    },
-    {
-        name: 'Dependent Representations',
-        category: 'Advanced Content',
-        desc: 'Uses Representations that depend on others for decoding, enabling scalable video coding (SVC) or multi-view coding (MVC).',
-        isoRef: 'DASH: 5.3.5.2',
-    },
-    {
-        name: 'Associated Representations',
-        category: 'Advanced Content',
-        desc: 'Signals a relationship between representations, such as a video description track associated with a main video track.',
-        isoRef: 'DASH: 5.3.5.2',
-    },
-    {
-        name: 'Trick Modes',
-        category: 'Advanced Content',
-        desc: 'Provides special tracks (e.g. I-Frame only) to enable efficient fast-forward and rewind.',
-        isoRef: 'DASH: 5.3.6',
-    },
-    {
-        name: 'Adaptation Set Switching',
-        category: 'Client Guidance & Optimization',
-        desc: 'Signals that a client can seamlessly switch between Representations in different Adaptation Sets (e.g., for different codecs).',
-        isoRef: 'DASH: 5.3.3.5',
-    },
-    {
-        name: 'Service Description',
-        category: 'Client Guidance & Optimization',
-        desc: 'Provides guidance to the client on latency targets, playback rates, and quality/bandwidth constraints for the service.',
-        isoRef: 'DASH: Annex K',
-    },
-    {
-        name: 'Resync Points',
-        category: 'Client Guidance & Optimization',
-        desc: 'Signals the presence of resynchronization points within segments to allow for faster startup or recovery after a stall.',
-        isoRef: 'DASH: 5.3.13',
-    },
-    {
-        name: 'Initialization Sets',
-        category: 'Client Guidance & Optimization',
-        desc: 'Defines a common set of media properties that apply across multiple Periods, allowing a client to establish a decoding environment upfront.',
-        isoRef: 'DASH: 5.3.12',
-    },
-    {
-        name: 'Selection Priority',
-        category: 'Client Guidance & Optimization',
-        desc: 'Provides a numeric priority for Adaptation Sets to guide client selection logic, where higher numbers are preferred.',
-        isoRef: 'DASH: 5.3.7.2',
-    },
-    {
-        name: 'Adaptation Set Grouping',
-        category: 'Client Guidance & Optimization',
-        desc: 'Groups Adaptation Sets to signal that they are mutually exclusive (e.g., different camera angles).',
-        isoRef: 'DASH: 5.3.3.1',
-    },
-    {
-        name: 'Bitstream Switching',
-        category: 'Client Guidance & Optimization',
-        desc: 'Signals that a client can switch between Representations without re-initializing the media decoder, enabling faster, more efficient switching.',
-        isoRef: 'DASH: 5.3.3.2',
-    },
-    {
-        name: 'Segment Profiles',
-        category: 'Client Guidance & Optimization',
-        desc: 'Specifies profiles that media segments conform to, providing more granular compatibility information.',
-        isoRef: 'DASH: 5.3.7.2',
-    },
-    {
-        name: 'Media Stream Structure',
-        category: 'Client Guidance & Optimization',
-        desc: 'Signals that different Representations share a compatible internal structure, simplifying seamless switching.',
-        isoRef: 'DASH: 5.3.5.2',
-    },
-    {
-        name: 'Max SAP Period',
-        category: 'Client Guidance & Optimization',
-        desc: 'Specifies the maximum time between stream access points (SAPs), allowing clients to better manage seeking and buffering.',
-        isoRef: 'DASH: 5.3.7.2',
-    },
-    {
-        name: 'Starts with SAP',
-        category: 'Client Guidance & Optimization',
-        desc: 'Indicates that segments begin with a Stream Access Point (SAP), which greatly simplifies switching and seeking logic.',
-        isoRef: 'DASH: 5.3.7.2',
-    },
-    {
-        name: 'Max Playout Rate',
-        category: 'Client Guidance & Optimization',
-        desc: 'Indicates the maximum playback rate (for trick modes like fast-forward) that the stream supports.',
-        isoRef: 'DASH: 5.3.7.2',
-    },
-    {
-        name: 'Byte-Range URL Templating',
-        category: 'Client Guidance & Optimization',
-        desc: 'Provides a template on a BaseURL for clients in environments that do not support HTTP Range headers.',
-        isoRef: 'DASH: 5.6.2',
-    },
-    {
-        name: 'Essential Properties',
-        category: 'Client Guidance & Optimization',
-        desc: 'Signals properties that are essential for the client to process for a valid experience.',
-        isoRef: 'DASH: 5.8.4.8',
-    },
-    {
-        name: 'Supplemental Properties',
-        category: 'Client Guidance & Optimization',
-        desc: 'Signals supplemental properties that a client may use for optimization.',
-        isoRef: 'DASH: 5.8.4.9',
-    },
-    {
-        name: 'Metrics',
-        category: 'Client Guidance & Optimization',
-        desc: 'Signals a request for the client to collect and report playback metrics.',
-        isoRef: 'DASH: 5.9',
-    },
-    {
-        name: 'Role Descriptors',
-        category: 'Accessibility & Metadata',
-        desc: 'Uses Role Descriptors to provide alternative tracks for language, commentary, or camera angles.',
-        isoRef: 'DASH: 5.8.4.2',
-    },
-    {
-        name: 'Subtitles & Captions',
-        category: 'Accessibility & Metadata',
-        desc: 'Provides text-based tracks for subtitles, closed captions, or other timed text information.',
-        isoRef: 'DASH: 5.3.3',
-    },
-    {
-        name: 'Asset Identifier',
-        category: 'Accessibility & Metadata',
-        desc: 'Provides a common identifier for Periods that belong to the same content asset, useful for tracking content across ad breaks.',
-        isoRef: 'DASH: 5.8.4.10',
-    },
-    {
-        name: 'Subsets',
-        category: 'Accessibility & Metadata',
-        desc: 'Restricts the combination of Adaptation Sets that can be played simultaneously, for example to prevent incompatible audio and video tracks from being selected.',
-        isoRef: 'DASH: 5.3.8',
-    },
-    {
-        name: 'Preselections',
-        category: 'Accessibility & Metadata',
-        desc: 'Defines a complete "experience" by grouping a set of Adaptation Sets (e.g., video + main audio + commentary). Primarily for advanced audio like NGA.',
-        isoRef: 'DASH: 5.3.11',
-    },
-    {
-        name: 'Labels',
-        category: 'Accessibility & Metadata',
-        desc: 'Provides human-readable text labels for elements like Representations and Adaptation Sets, which can be used in UI selectors.',
-        isoRef: 'DASH: 5.3.10',
-    },
-    {
-        name: 'Quality Ranking',
-        category: 'Accessibility & Metadata',
-        desc: 'Provides a numeric ranking for Representations within an Adaptation Set to guide ABR logic, where lower numbers typically mean higher quality.',
-        isoRef: 'DASH: 5.3.5.2',
-    },
-    {
-        name: 'Coding Dependency',
-        category: 'Accessibility & Metadata',
-        desc: 'Signals whether a Representation contains inter-frame dependencies (e.g., P/B-frames) or is entirely self-contained (e.g., I-frame only).',
-        isoRef: 'DASH: 5.3.7.2',
-    },
-    {
-        name: 'Audio Channel Configuration',
-        category: 'Accessibility & Metadata',
-        desc: 'Describes the audio channel layout, such as stereo (2.0) or surround sound (5.1).',
-        isoRef: 'DASH: 5.8.4.7',
-    },
-    {
-        name: 'Scan Type',
-        category: 'Accessibility & Metadata',
-        desc: 'Indicates whether the video content is progressive or interlaced.',
-        isoRef: 'DASH: 5.3.7.2',
-    },
-    {
-        name: 'Tag attribute',
-        category: 'Accessibility & Metadata',
-        desc: 'A generic string attribute that can be used for application-specific logic, such as decoder selection.',
-        isoRef: 'DASH: 5.3.7.2',
-    },
-    {
-        name: 'Program Information',
-        category: 'Accessibility & Metadata',
-        desc: 'Provides descriptive metadata about the media presentation, such as title or source.',
-        isoRef: 'DASH: 5.7',
-    },
-    {
-        name: 'Frame Packing Descriptors',
-        category: 'Accessibility & Metadata',
-        desc: 'Provides information on 3D video frame packing arrangements.',
-        isoRef: 'DASH: 5.8.4.6',
-    },
-    {
-        name: 'Rating Descriptors',
-        category: 'Accessibility & Metadata',
-        desc: 'Provides content rating information (e.g., MPAA ratings).',
-        isoRef: 'DASH: 5.8.4.4',
-    },
-    {
-        name: 'Viewpoint Descriptors',
-        category: 'Accessibility & Metadata',
-        desc: 'Provides information on camera viewpoints for multi-view content.',
-        isoRef: 'DASH: 5.8.4.5',
-    },
-    {
-        name: 'Accessibility Descriptors',
-        category: 'Accessibility & Metadata',
-        desc: 'Provides information about accessibility features for the content, such as audio descriptions.',
-        isoRef: 'DASH: 5.8.4.3',
-    },
-];
diff --git a/js/infrastructure/manifest/dash/parser.js b/js/infrastructure/manifest/dash/parser.js
deleted file mode 100644
index 09a8377..0000000
--- a/js/infrastructure/manifest/dash/parser.js
+++ /dev/null
@@ -1,100 +0,0 @@
-import { adaptDashToIr } from './adapter.js';
-import { XMLParser } from 'fast-xml-parser';
-
-/**
- * Parses a DASH Manifest XML string and returns a protocol-agnostic Intermediate Representation.
- * This is the public entry point for the DASH manifest parsing module.
- * @param {string} xmlString The raw MPD XML.
- * @param {string} baseUrl The URL from which the MPD was fetched.
- * @returns {Promise<{manifest: import('../../../app/types.js').Manifest, serializedManifest: object, baseUrl: string}>}
- */
-export async function parseManifest(xmlString, baseUrl) {
-    const parser = new XMLParser({
-        ignoreAttributes: false,
-        attributeNamePrefix: '',
-        attributesGroupName: ':@',
-        textNodeName: '#text',
-        allowBooleanAttributes: true,
-        removeNSPrefix: true,
-        alwaysCreateTextNode: true,
-        isArray: (tagName) => {
-            return [
-                // MPD Level
-                'ProgramInformation',
-                'BaseURL',
-                'Location',
-                'PatchLocation',
-                'ServiceDescription',
-                'InitializationSet',
-                'InitializationGroup',
-                'InitializationPresentation',
-                'ContentProtection',
-                'Period',
-                'Metrics',
-                'EssentialProperty',
-                'SupplementalProperty',
-                'UTCTiming',
-                // Period Level
-                'EventStream',
-                'AdaptationSet',
-                'Subset',
-                'EmptyAdaptationSet',
-                'GroupLabel',
-                'Preselection',
-                // AdaptationSet & RepresentationBase Levels
-                'Accessibility',
-                'Role',
-                'Rating',
-                'Viewpoint',
-                'ContentComponent',
-                'Representation',
-                'FramePacking',
-                'AudioChannelConfiguration',
-                'InbandEventStream',
-                'Switching',
-                'RandomAccess',
-                'Label',
-                'ProducerReferenceTime',
-                'ContentPopularityRate',
-                'Resync',
-                'OutputProtection',
-                // Representation Level
-                'SubRepresentation',
-                'ExtendedBandwidth',
-                'ModelPair',
-                // ServiceDescription Level
-                'Scope',
-                'Latency',
-                'PlaybackRate',
-                'OperatingQuality',
-                'OperatingBandwidth',
-                // Segment Info
-                'SegmentURL',
-                'S',
-                'FCS', // FailoverContent child
-                // Event Info
-                'Event',
-                // Metrics Info
-                'Reporting',
-                'Range',
-            ].includes(tagName);
-        },
-    });
-
-    const jsonObj = parser.parse(xmlString);
-    const mpdNodeKey = Object.keys(jsonObj).find(
-        (key) => key.toUpperCase() === 'MPD'
-    );
-    if (!mpdNodeKey) {
-        throw new Error('Could not find MPD root element in the manifest.');
-    }
-    const serializedManifest = jsonObj[mpdNodeKey];
-
-    const manifestIR = adaptDashToIr(serializedManifest, baseUrl);
-
-    return {
-        manifest: manifestIR,
-        serializedManifest,
-        baseUrl: baseUrl,
-    };
-}
diff --git a/js/infrastructure/manifest/dash/recursive-parser.js b/js/infrastructure/manifest/dash/recursive-parser.js
deleted file mode 100644
index 555e92b..0000000
--- a/js/infrastructure/manifest/dash/recursive-parser.js
+++ /dev/null
@@ -1,179 +0,0 @@
-export const getAttr = (el, attr) => el?.[':@']?.[attr];
-
-export const findChild = (el, tagName) => {
-    if (!el || !el[tagName]) {
-        return undefined;
-    }
-    const children = el[tagName];
-    // If it's an array (multiple elements), return the first. If it's an object (single element), return it directly.
-    return Array.isArray(children) ? children[0] : children;
-};
-
-export const findChildren = (el, tagName) => {
-    if (!el || !el[tagName]) {
-        return [];
-    }
-    const children = el[tagName];
-    // If it's already an array, return it. If it's a single object, wrap it in an array.
-    return Array.isArray(children) ? children : [children];
-};
-
-export const findChildrenRecursive = (element, tagName) => {
-    let results = [];
-    if (!element || typeof element !== 'object') return results;
-
-    for (const key in element) {
-        if (key === ':@' || key === '#text') continue;
-
-        const children = element[key];
-        if (!children) continue;
-
-        const childArray = Array.isArray(children) ? children : [children];
-
-        for (const child of childArray) {
-            if (key === tagName) {
-                results.push(child);
-            }
-            if (typeof child === 'object') {
-                results = results.concat(findChildrenRecursive(child, tagName));
-            }
-        }
-    }
-    return results;
-};
-
-export function findElementsByTagNameRecursive(element, tagName, context = {}) {
-    const results = [];
-    if (!element || typeof element !== 'object') {
-        return results;
-    }
-
-    for (const key in element) {
-        if (key === ':@' || key === '#text') continue;
-
-        const children = element[key];
-        if (!children) continue;
-
-        const childArray = Array.isArray(children) ? children : [children];
-
-        for (const child of childArray) {
-            if (typeof child !== 'object') continue;
-
-            const newContext = /** @type {any} */ ({
-                ...context,
-                parent: element,
-            });
-            if (key === 'Period') newContext.period = child;
-            if (key === 'AdaptationSet') newContext.adaptationSet = child;
-
-            if (key === tagName) {
-                results.push({ element: child, context: newContext });
-            }
-            results.push(
-                ...findElementsByTagNameRecursive(child, tagName, newContext)
-            );
-        }
-    }
-    return results;
-}
-
-/**
- * Merges two element objects, with the child's properties overriding the parent's.
- * This is crucial for DASH hierarchical inheritance. It now correctly concatenates
- * arrays for multi-instance child elements like ContentProtection.
- * @param {object | undefined} parent The parent element object from fast-xml-parser.
- * @param {object | undefined} child The child element object from fast-xml-parser.
- * @returns {object | undefined} The merged element.
- */
-export function mergeElements(parent, child) {
-    if (!child) return parent;
-    if (!parent) return child;
-
-    const merged = JSON.parse(JSON.stringify(parent));
-    Object.assign(merged[':@'] || (merged[':@'] = {}), child[':@']);
-
-    for (const key in child) {
-        if (key === ':@') continue;
-
-        if (
-            merged[key] &&
-            Array.isArray(merged[key]) &&
-            Array.isArray(child[key])
-        ) {
-            // If both are arrays (e.g., ContentProtection), concatenate them.
-            merged[key] = merged[key].concat(child[key]);
-        } else {
-            // Otherwise, child's property (element or array of elements) replaces parent's.
-            // This is correct for single-instance elements like SegmentTemplate.
-            merged[key] = child[key];
-        }
-    }
-    return merged;
-}
-
-/**
- * Gets a merged element by inheriting from a hierarchy of parent elements.
- * The hierarchy is child-first (e.g., Representation, then AdaptationSet, then Period).
- * @param {string} tagName - The name of the element to find (e.g., 'SegmentTemplate').
- * @param {object[]} elementHierarchy - An array of elements to search, from lowest to highest level.
- * @returns {object | undefined} The merged element, or undefined if not found.
- */
-export function getInheritedElement(tagName, elementHierarchy) {
-    const elements = elementHierarchy
-        .map((el) => findChild(el, tagName))
-        .filter(Boolean);
-
-    if (elements.length === 0) return undefined;
-
-    // The hierarchy is [rep, as, period]. reduceRight merges from parent-to-child.
-    // 1. acc = period, el = as -> merge(period, as) -> result1
-    // 2. acc = result1, el = rep -> merge(result1, rep) -> final result
-    return elements.reduceRight((acc, el) => mergeElements(acc, el));
-}
-
-const getText = (el) => el?.['#text'] || null;
-
-/**
- * Implements the hierarchical BaseURL resolution as per MPEG-DASH spec (Clause 5.6).
- * This function correctly models inheritance and handles empty <BaseURL> tags
- * by inheriting the parent's base URL, as per RFC 3986.
- * @param {string} manifestBaseUrl The URL of the manifest itself.
- * @param {object} mpdEl The root MPD element.
- * @param {object} periodEl The current Period element.
- * @param {object} asEl The current AdaptationSet element.
- * @param {object} repEl The current Representation element.
- * @returns {string} The fully resolved base URL for the current context.
- */
-export function resolveBaseUrl(manifestBaseUrl, mpdEl, periodEl, asEl, repEl) {
-    /**
-     * Calculates the effective base URL at a specific level of the hierarchy.
-     * @param {object | undefined} el The manifest element for the current level.
-     * @param {string} parentBaseUrl The resolved base URL from the parent level.
-     * @returns {string} The effective base URL for this level.
-     */
-    const getEffectiveBase = (el, parentBaseUrl) => {
-        if (!el) return parentBaseUrl;
-        const baseUrlEl = findChild(el, 'BaseURL');
-        if (!baseUrlEl) return parentBaseUrl;
-
-        const urlContent = getText(baseUrlEl);
-        // An empty string is a valid relative reference that resolves to the base URI itself,
-        // effectively inheriting the parent base. A null value means the tag is empty (<BaseURL/>),
-        // which also means it should inherit.
-        const relativeUrl = (urlContent || '').trim();
-
-        try {
-            return new URL(relativeUrl, parentBaseUrl).href;
-        } catch (e) {
-            console.warn(`Invalid URL part in BaseURL: "${relativeUrl}"`, e);
-            return parentBaseUrl;
-        }
-    };
-
-    const baseMpd = getEffectiveBase(mpdEl, manifestBaseUrl);
-    const basePeriod = getEffectiveBase(periodEl, baseMpd);
-    const baseAs = getEffectiveBase(asEl, basePeriod);
-    const baseRep = getEffectiveBase(repEl, baseAs);
-
-    return baseRep;
-}
diff --git a/js/infrastructure/manifest/dash/segment-parser.js b/js/infrastructure/manifest/dash/segment-parser.js
deleted file mode 100644
index c7680de..0000000
--- a/js/infrastructure/manifest/dash/segment-parser.js
+++ /dev/null
@@ -1,335 +0,0 @@
-import { parseDuration } from '../../../shared/utils/time.js';
-import {
-    getAttr,
-    findChild,
-    findChildren,
-    getInheritedElement,
-    resolveBaseUrl,
-} from './recursive-parser.js';
-import { findElementsByTagNameRecursive } from './recursive-parser.js';
-
-/**
- * Parses all segment URLs from a serialized DASH manifest object.
- * @param {object} manifestElement The serialized <MPD> element.
- * @param {string} manifestUrl The URL from which the MPD was fetched (the initial base URL).
- * @returns {Record<string, object[]>} A map of composite keys (periodId-repId) to their segment lists.
- */
-export function parseAllSegmentUrls(manifestElement, manifestUrl) {
-    /** @type {Record<string, object[]>} */
-    const segmentsByRep = {};
-    const isDynamic = getAttr(manifestElement, 'type') === 'dynamic';
-    const availabilityStartTime = isDynamic
-        ? new Date(getAttr(manifestElement, 'availabilityStartTime')).getTime()
-        : 0;
-
-    const allRepsWithContext = findElementsByTagNameRecursive(
-        manifestElement,
-        'Representation'
-    );
-
-    allRepsWithContext.forEach(({ element: rep, context }) => {
-        const repId = getAttr(rep, 'id');
-        if (!repId) return;
-
-        const { period, adaptationSet } = context;
-        if (!period || !adaptationSet) return;
-
-        const periodId = getAttr(period, 'id');
-        if (!periodId) {
-            console.warn(
-                'Skipping Representation in Period without an ID.',
-                rep
-            );
-            return;
-        }
-
-        const compositeKey = `${periodId}-${repId}`;
-        segmentsByRep[compositeKey] = [];
-
-        const hierarchy = [rep, adaptationSet, period];
-
-        const baseUrl = resolveBaseUrl(
-            manifestUrl,
-            manifestElement,
-            period,
-            adaptationSet,
-            rep
-        );
-
-        const template = getInheritedElement('SegmentTemplate', hierarchy);
-        const segmentList = getInheritedElement('SegmentList', hierarchy);
-        const segmentBase = getInheritedElement('SegmentBase', hierarchy);
-
-        let initTemplate = getAttr(template, 'initialization');
-        if (!initTemplate) {
-            const initContainer = segmentList || segmentBase;
-            const initializationEl = initContainer
-                ? findChild(initContainer, 'Initialization')
-                : null;
-            if (initializationEl) {
-                initTemplate = getAttr(initializationEl, 'sourceURL');
-            }
-        }
-
-        if (initTemplate) {
-            const initUrl = initTemplate.replace(
-                /\$RepresentationID\$/g,
-                repId
-            );
-            segmentsByRep[compositeKey].push({
-                repId,
-                type: 'Init',
-                number: 0,
-                resolvedUrl: new URL(initUrl, baseUrl).href,
-                template: initUrl,
-                time: -1,
-                duration: 0,
-                timescale: parseInt(
-                    getAttr(template || segmentList, 'timescale') || '1'
-                ),
-                startTimeUTC: null,
-                endTimeUTC: null,
-            });
-        }
-
-        if (template) {
-            const timescale = parseInt(getAttr(template, 'timescale') || '1');
-            const mediaTemplate = getAttr(template, 'media');
-            const timeline = findChild(template, 'SegmentTimeline');
-            const startNumber = parseInt(
-                getAttr(template, 'startNumber') || '1'
-            );
-            const periodStart = parseDuration(getAttr(period, 'start')) || 0;
-            const availabilityTimeOffset =
-                parseFloat(getAttr(template, 'availabilityTimeOffset')) || 0;
-
-            if (mediaTemplate && timeline) {
-                let segmentNumber = startNumber;
-                let currentTime = 0;
-                findChildren(timeline, 'S').forEach((sNode) => {
-                    const t = getAttr(sNode, 't')
-                        ? parseInt(getAttr(sNode, 't'))
-                        : currentTime;
-                    const d = parseInt(getAttr(sNode, 'd'));
-                    const r = parseInt(getAttr(sNode, 'r') || '0');
-                    currentTime = t;
-
-                    for (let i = 0; i <= r; i++) {
-                        const segTime = currentTime;
-                        const startTimeSeconds =
-                            periodStart + segTime / timescale;
-                        const durationSeconds = d / timescale;
-                        const segAvailabilityStartTime = isDynamic
-                            ? availabilityStartTime +
-                              (startTimeSeconds +
-                                  durationSeconds -
-                                  availabilityTimeOffset) *
-                                  1000
-                            : null;
-
-                        const url = mediaTemplate
-                            .replace(/\$RepresentationID\$/g, repId)
-                            .replace(/\$Number(%0\d+d)?\$/g, (match, p) =>
-                                String(segmentNumber).padStart(
-                                    p
-                                        ? parseInt(p.substring(2, p.length - 1))
-                                        : 1,
-                                    '0'
-                                )
-                            )
-                            .replace(/\$Time\$/g, String(segTime));
-                        segmentsByRep[compositeKey].push({
-                            repId,
-                            type: 'Media',
-                            number: segmentNumber,
-                            resolvedUrl: new URL(url, baseUrl).href,
-                            template: url,
-                            time: segTime,
-                            duration: d,
-                            timescale,
-                            startTimeUTC: segAvailabilityStartTime,
-                            endTimeUTC: segAvailabilityStartTime
-                                ? segAvailabilityStartTime +
-                                  durationSeconds * 1000
-                                : null,
-                        });
-                        currentTime += d;
-                        segmentNumber++;
-                    }
-                });
-            } else if (mediaTemplate && getAttr(template, 'duration')) {
-                const segmentDuration = parseInt(getAttr(template, 'duration'));
-                const segmentDurationSeconds = segmentDuration / timescale;
-                let numSegments = 0;
-                const endNumber = getAttr(template, 'endNumber')
-                    ? parseInt(getAttr(template, 'endNumber'))
-                    : null;
-
-                if (isDynamic) {
-                    numSegments = 10; // Heuristic for live streams
-                } else {
-                    if (endNumber !== null) {
-                        numSegments = endNumber - startNumber + 1;
-                    } else {
-                        const totalDuration =
-                            parseDuration(
-                                getAttr(
-                                    manifestElement,
-                                    'mediaPresentationDuration'
-                                )
-                            ) || parseDuration(getAttr(period, 'duration'));
-                        if (!totalDuration || !segmentDurationSeconds) return;
-                        numSegments = Math.ceil(
-                            totalDuration / segmentDurationSeconds
-                        );
-                    }
-                }
-
-                for (let i = 0; i < numSegments; i++) {
-                    const segmentNumber = startNumber + i;
-                    const time =
-                        (segmentNumber - startNumber) * segmentDuration;
-                    const startTimeSeconds = periodStart + time / timescale;
-                    const segAvailabilityStartTime = isDynamic
-                        ? availabilityStartTime +
-                          (startTimeSeconds +
-                              segmentDurationSeconds -
-                              availabilityTimeOffset) *
-                              1000
-                        : null;
-
-                    const url = mediaTemplate
-                        .replace(/\$RepresentationID\$/g, repId)
-                        .replace(/\$Number(%0\d+d)?\$/g, (m, p) =>
-                            String(segmentNumber).padStart(
-                                p ? parseInt(p.substring(2, p.length - 1)) : 1,
-                                '0'
-                            )
-                        );
-                    segmentsByRep[compositeKey].push({
-                        repId,
-                        type: 'Media',
-                        number: segmentNumber,
-                        resolvedUrl: new URL(url, baseUrl).href,
-                        template: url,
-                        time: time,
-                        duration: segmentDuration,
-                        timescale,
-                        startTimeUTC: segAvailabilityStartTime,
-                        endTimeUTC: segAvailabilityStartTime
-                            ? segAvailabilityStartTime +
-                              segmentDurationSeconds * 1000
-                            : null,
-                    });
-                }
-            }
-        } else if (segmentList) {
-            const timescale = parseInt(
-                getAttr(segmentList, 'timescale') || '1'
-            );
-            const duration = parseInt(getAttr(segmentList, 'duration'));
-            const durationSeconds = duration / timescale;
-            let currentTime = 0;
-            const periodStart = parseDuration(getAttr(period, 'start')) || 0;
-            const availabilityTimeOffset =
-                parseFloat(getAttr(segmentList, 'availabilityTimeOffset')) || 0;
-
-            const segmentUrls = findChildren(segmentList, 'SegmentURL');
-            segmentUrls.forEach((segmentUrlEl, i) => {
-                const mediaUrl = getAttr(segmentUrlEl, 'media');
-                if (mediaUrl) {
-                    const startTimeSeconds =
-                        periodStart + currentTime / timescale;
-                    const segAvailabilityStartTime = isDynamic
-                        ? availabilityStartTime +
-                          (startTimeSeconds +
-                              durationSeconds -
-                              availabilityTimeOffset) *
-                              1000
-                        : null;
-                    segmentsByRep[compositeKey].push({
-                        repId,
-                        type: 'Media',
-                        number: i + 1,
-                        resolvedUrl: new URL(mediaUrl, baseUrl).href,
-                        template: mediaUrl,
-                        time: currentTime,
-                        duration: duration,
-                        timescale,
-                        startTimeUTC: segAvailabilityStartTime,
-                        endTimeUTC: segAvailabilityStartTime
-                            ? segAvailabilityStartTime + durationSeconds * 1000
-                            : null,
-                    });
-                    currentTime += duration;
-                }
-            });
-        } else if (segmentBase || findChild(rep, 'BaseURL')) {
-            const timescale = parseInt(
-                getAttr(adaptationSet, 'timescale') || '1'
-            );
-            const totalDuration =
-                parseDuration(
-                    getAttr(manifestElement, 'mediaPresentationDuration')
-                ) ||
-                parseDuration(getAttr(period, 'duration')) ||
-                0;
-
-            segmentsByRep[compositeKey].push({
-                repId,
-                type: 'Media',
-                number: 1,
-                resolvedUrl: baseUrl,
-                template: findChild(rep, 'BaseURL') ? 'BaseURL' : 'SegmentBase',
-                time: 0,
-                duration: totalDuration * timescale,
-                timescale,
-                startTimeUTC: null,
-                endTimeUTC: null,
-            });
-        }
-    });
-    return segmentsByRep;
-}
-
-export function findInitSegmentUrl(
-    representation,
-    adaptationSet,
-    period,
-    baseUrl
-) {
-    const repElement = representation.serializedManifest;
-    if (!repElement) return null;
-
-    const hierarchy = [
-        repElement,
-        adaptationSet.serializedManifest,
-        period.serializedManifest,
-    ];
-
-    const template = getInheritedElement('SegmentTemplate', hierarchy);
-
-    if (template && getAttr(template, 'initialization')) {
-        return new URL(
-            getAttr(template, 'initialization').replace(
-                /\$RepresentationID\$/g,
-                representation.id
-            ),
-            baseUrl
-        ).href;
-    }
-
-    const list = getInheritedElement('SegmentList', hierarchy);
-    const base = getInheritedElement('SegmentBase', hierarchy);
-
-    const initContainer = list || base;
-    const initialization = initContainer
-        ? findChild(initContainer, 'Initialization')
-        : null;
-
-    if (initialization && getAttr(initialization, 'sourceURL')) {
-        return new URL(getAttr(initialization, 'sourceURL'), baseUrl).href;
-    }
-
-    return null;
-}
diff --git a/js/infrastructure/manifest/dash/summary-generator.js b/js/infrastructure/manifest/dash/summary-generator.js
deleted file mode 100644
index 90c0b95..0000000
--- a/js/infrastructure/manifest/dash/summary-generator.js
+++ /dev/null
@@ -1,223 +0,0 @@
-/**
- * @typedef {import('../../../app/types.js').Manifest} Manifest
- * @typedef {import('../../../app/types.js').PeriodSummary} PeriodSummary
- */
-
-import { findChildrenRecursive } from './recursive-parser.js';
-import { formatBitrate } from '../../../shared/utils/format.js';
-
-const getSegmentingStrategy = (serializedManifest) => {
-    if (!serializedManifest) return 'unknown';
-    if (findChildrenRecursive(serializedManifest, 'SegmentList').length > 0)
-        return 'SegmentList';
-    const template = findChildrenRecursive(
-        serializedManifest,
-        'SegmentTemplate'
-    )[0];
-    if (template) {
-        if (findChildrenRecursive(template, 'SegmentTimeline').length > 0)
-            return 'SegmentTemplate with SegmentTimeline';
-        if (template[':@']?.media?.includes('$Number$'))
-            return 'SegmentTemplate with $Number$';
-        if (template[':@']?.media?.includes('$Time$'))
-            return 'SegmentTemplate with $Time$';
-        return 'SegmentTemplate';
-    }
-    if (findChildrenRecursive(serializedManifest, 'SegmentBase').length > 0)
-        return 'SegmentBase';
-    if (findChildrenRecursive(serializedManifest, 'BaseURL').length > 0)
-        return 'BaseURL / Single Segment';
-    return 'Unknown';
-};
-
-/**
- * Creates a protocol-agnostic summary view-model from a DASH manifest.
- * @param {Manifest} manifestIR - The adapted manifest IR.
- * @param {object} serializedManifest - The serialized manifest DOM object.
- * @returns {import('../../../app/types.js').ManifestSummary}
- */
-export function generateDashSummary(manifestIR, serializedManifest) {
-    const protectionSchemes = new Set();
-    const kids = new Set();
-
-    const periodSummaries = manifestIR.periods.map((period) => {
-        /** @type {import('../../../app/types.js').AdaptationSet[]} */
-        const videoTracks = [];
-        /** @type {import('../../../app/types.js').AdaptationSet[]} */
-        const audioTracks = [];
-        /** @type {import('../../../app/types.js').AdaptationSet[]} */
-        const textTracks = [];
-
-        for (const as of period.adaptationSets) {
-            for (const cp of as.contentProtection) {
-                protectionSchemes.add(cp.system);
-                if (cp.defaultKid) {
-                    kids.add(cp.defaultKid);
-                }
-            }
-
-            switch (as.contentType) {
-                case 'video':
-                    videoTracks.push(as);
-                    break;
-                case 'audio':
-                    audioTracks.push(as);
-                    break;
-                case 'text':
-                case 'application':
-                    textTracks.push(as);
-                    break;
-            }
-        }
-
-        /** @type {PeriodSummary} */
-        const periodSummary = {
-            id: period.id,
-            start: period.start,
-            duration: period.duration,
-            videoTracks,
-            audioTracks,
-            textTracks,
-        };
-        return periodSummary;
-    });
-
-    const serviceDescription = findChildrenRecursive(
-        serializedManifest,
-        'ServiceDescription'
-    )[0];
-    const latencyEl = serviceDescription
-        ? findChildrenRecursive(serviceDescription, 'Latency')[0]
-        : null;
-
-    // Aggregate flattened summaries for top-level/comparison views
-    const allVideoTracks = periodSummaries
-        .flatMap((p) => p.videoTracks)
-        .map((as) => {
-            const bitrates = as.representations
-                .map((r) => r.bandwidth)
-                .filter(Boolean);
-            return {
-                id: as.id || 'N/A',
-                profiles: as.profiles,
-                bitrateRange:
-                    bitrates.length > 0
-                        ? `${formatBitrate(
-                              Math.min(...bitrates)
-                          )} - ${formatBitrate(Math.max(...bitrates))}`
-                        : 'N/A',
-                resolutions: [
-                    ...new Set(
-                        as.representations.map((r) => `${r.width}x${r.height}`)
-                    ),
-                ],
-                codecs: [
-                    ...new Set(
-                        as.representations.map((r) => r.codecs).filter(Boolean)
-                    ),
-                ],
-                scanType: as.representations[0]?.scanType || null,
-                videoRange: null,
-                roles: as.roles.map((r) => r.value).filter(Boolean),
-            };
-        });
-
-    const allAudioTracks = periodSummaries
-        .flatMap((p) => p.audioTracks)
-        .map((as) => ({
-            id: as.id || 'N/A',
-            lang: as.lang,
-            codecs: [
-                ...new Set(
-                    as.representations.map((r) => r.codecs).filter(Boolean)
-                ),
-            ],
-            channels:
-                [
-                    ...new Set(
-                        as.representations
-                            .flatMap((r) => r.audioChannelConfigurations)
-                            .map((c) => c.value)
-                            .filter(Boolean)
-                    ),
-                ].join(', ') || null,
-            isDefault: as.roles.some((r) => r.value === 'main'),
-            isForced: false,
-            roles: as.roles.map((r) => r.value).filter(Boolean),
-        }));
-
-    const allTextTracks = periodSummaries
-        .flatMap((p) => p.textTracks)
-        .map((as) => ({
-            id: as.id || 'N/A',
-            lang: as.lang,
-            codecsOrMimeTypes: [
-                ...new Set(
-                    as.representations
-                        .map((r) => r.codecs || r.mimeType)
-                        .filter(Boolean)
-                ),
-            ],
-            isDefault: as.roles.some((r) => r.value === 'main'),
-            isForced: as.roles.some((r) => r.value === 'forced'),
-            roles: as.roles.map((r) => r.value).filter(Boolean),
-        }));
-
-    /** @type {import('../../../app/types.js').ManifestSummary} */
-    const summary = {
-        general: {
-            protocol: 'DASH',
-            streamType:
-                manifestIR.type === 'dynamic'
-                    ? 'Live / Dynamic'
-                    : 'VOD / Static',
-            streamTypeColor:
-                manifestIR.type === 'dynamic'
-                    ? 'text-red-400'
-                    : 'text-blue-400',
-            duration: manifestIR.duration,
-            segmentFormat: manifestIR.segmentFormat,
-            title: manifestIR.programInformations[0]?.title || null,
-            locations: manifestIR.locations,
-            segmenting: getSegmentingStrategy(serializedManifest),
-        },
-        dash: {
-            profiles: manifestIR.profiles,
-            minBufferTime: manifestIR.minBufferTime,
-            timeShiftBufferDepth: manifestIR.timeShiftBufferDepth,
-            minimumUpdatePeriod: manifestIR.minimumUpdatePeriod,
-            availabilityStartTime: manifestIR.availabilityStartTime,
-            publishTime: manifestIR.publishTime,
-        },
-        hls: null,
-        lowLatency: {
-            isLowLatency: !!latencyEl,
-            targetLatency: latencyEl
-                ? parseInt(latencyEl[':@']?.target, 10)
-                : null,
-            minLatency: latencyEl ? parseInt(latencyEl[':@']?.min, 10) : null,
-            maxLatency: latencyEl ? parseInt(latencyEl[':@']?.max, 10) : null,
-            partTargetDuration: null,
-            partHoldBack: null,
-            canBlockReload: false,
-        },
-        content: {
-            totalPeriods: manifestIR.periods.length,
-            totalVideoTracks: allVideoTracks.length,
-            totalAudioTracks: allAudioTracks.length,
-            totalTextTracks: allTextTracks.length,
-            mediaPlaylists: 0,
-            periods: periodSummaries,
-        },
-        videoTracks: allVideoTracks,
-        audioTracks: allAudioTracks,
-        textTracks: allTextTracks,
-        security: {
-            isEncrypted: protectionSchemes.size > 0,
-            systems: Array.from(protectionSchemes),
-            kids: Array.from(kids),
-        },
-    };
-
-    return summary;
-}
diff --git a/js/infrastructure/manifest/hls/adapter.js b/js/infrastructure/manifest/hls/adapter.js
deleted file mode 100644
index 406b555..0000000
--- a/js/infrastructure/manifest/hls/adapter.js
+++ /dev/null
@@ -1,385 +0,0 @@
-/**
- * @typedef {import('../../../app/types.js').Manifest} Manifest
- * @typedef {import('../../../app/types.js').Period} Period
- * @typedef {import('../../../app/types.js').AdaptationSet} AdaptationSet
- * @typedef {import('../../../app/types.js').Representation} Representation
- */
-
-import { generateHlsSummary } from './summary-generator.js';
-import { parseScte35 } from '../../metadata/scte35/parser.js';
-
-/**
- * Transforms a parsed HLS manifest object into a protocol-agnostic Intermediate Representation (IR).
- * @param {object} hlsParsed - The parsed HLS manifest data from the parser.
- * @returns {Manifest} The manifest IR object.
- */
-export function adaptHlsToIr(hlsParsed) {
-    /** @type {Manifest} */
-    const manifestIR = {
-        id: null,
-        type: hlsParsed.isLive ? 'dynamic' : 'static',
-        profiles: `HLS v${hlsParsed.version}`,
-        minBufferTime: hlsParsed.targetDuration || null,
-        publishTime: null,
-        availabilityStartTime: null,
-        timeShiftBufferDepth: null,
-        minimumUpdatePeriod: hlsParsed.isLive ? hlsParsed.targetDuration : null,
-        duration: hlsParsed.isMaster
-            ? null
-            : hlsParsed.segments.reduce((sum, seg) => sum + seg.duration, 0),
-        maxSegmentDuration: null,
-        maxSubsegmentDuration: null,
-        programInformations: [],
-        metrics: [],
-        locations: [],
-        patchLocations: [],
-        serviceDescriptions: [],
-        initializationSets: [],
-        segmentFormat: hlsParsed.map ? 'isobmff' : 'ts',
-        periods: [],
-        events: [],
-        serializedManifest: hlsParsed,
-        summary: null, // Will be populated after main parsing
-        serverControl: hlsParsed.serverControl || null,
-        tags: hlsParsed.tags || [], // Copy tags for feature analysis
-        isMaster: hlsParsed.isMaster,
-        variants: hlsParsed.variants || [],
-        segments: hlsParsed.segments || [],
-        preloadHints: hlsParsed.preloadHints || [],
-        renditionReports: hlsParsed.renditionReports || [],
-        partInf: hlsParsed.partInf || null,
-    };
-
-    // Parse Date Ranges into standard Event objects
-    const dateRanges = hlsParsed.tags.filter(
-        (t) => t.name === 'EXT-X-DATERANGE'
-    );
-    let cumulativeTime = 0;
-    const pdtMap = new Map();
-    for (const seg of hlsParsed.segments) {
-        if (seg.dateTime) {
-            pdtMap.set(new Date(seg.dateTime).getTime(), cumulativeTime);
-        }
-        cumulativeTime += seg.duration;
-    }
-
-    for (const range of dateRanges) {
-        const startDate = new Date(range.value['START-DATE']).getTime();
-        const duration = parseFloat(range.value['DURATION']);
-        // Find the closest preceding PDT to calculate start time
-        const closestPdt = Array.from(pdtMap.keys())
-            .filter((t) => t <= startDate)
-            .pop();
-
-        if (closestPdt) {
-            const timeOffset = (startDate - closestPdt) / 1000;
-            const isInterstitial =
-                range.value.CLASS === 'com.apple.hls.interstitial';
-            const event = {
-                startTime: pdtMap.get(closestPdt) + timeOffset,
-                duration: duration,
-                message: isInterstitial
-                    ? `Interstitial: ${range.value['ID'] || 'N/A'}`
-                    : `Date Range: ${range.value['ID'] || 'N/A'}`,
-                messageData: isInterstitial ? range.value : null,
-                type: 'hls-daterange',
-                cue: range.value['CUE'] || null,
-                scte35: null,
-            };
-
-            const scte35Out = range.value['SCTE35-OUT'];
-            const scte35In = range.value['SCTE35-IN'];
-            const scte35Cmd = range.value['SCTE35-CMD'];
-            const scte35Data = scte35Out || scte35In || scte35Cmd;
-
-            if (scte35Data) {
-                try {
-                    // SCTE-35 data in HLS is typically hex-encoded
-                    const hex = String(scte35Data).replace(/^0x/, '');
-                    const binaryData = new Uint8Array(
-                        hex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16))
-                    );
-                    event.scte35 = parseScte35(binaryData);
-                } catch (e) {
-                    console.error('Failed to parse SCTE-35 from DATERANGE:', e);
-                }
-            }
-            manifestIR.events.push(event);
-        }
-    }
-
-    /** @type {Period} */
-    const periodIR = {
-        id: 'hls-period-0',
-        start: 0,
-        duration: manifestIR.duration,
-        bitstreamSwitching: null,
-        assetIdentifier: null,
-        subsets: [],
-        adaptationSets: [],
-        eventStreams: [],
-        events: [], // HLS events are manifest-level
-        serializedManifest: hlsParsed,
-        serviceDescriptions: [],
-        preselections: [],
-    };
-
-    if (hlsParsed.isMaster) {
-        // First, process all alternative renditions defined in EXT-X-MEDIA tags.
-        const mediaGroups = hlsParsed.media.reduce((acc, media) => {
-            const groupId = media['GROUP-ID'];
-            const type = media.TYPE.toLowerCase();
-            if (!acc[type]) acc[type] = {};
-            if (!acc[type][groupId]) acc[type][groupId] = [];
-            acc[type][groupId].push(media);
-            return acc;
-        }, {});
-
-        Object.entries(mediaGroups).forEach(([type, groups]) => {
-            Object.entries(groups).forEach(
-                ([groupId, renditions], groupIndex) => {
-                    renditions.forEach((media, mediaIndex) => {
-                        const contentType =
-                            type === 'subtitles' ? 'text' : type;
-                        /** @type {AdaptationSet} */
-                        const as = {
-                            id:
-                                media['STABLE-RENDITION-ID'] ||
-                                `${type}-rendition-${groupId}-${mediaIndex}`,
-                            contentType: contentType,
-                            lang: media.LANGUAGE,
-                            mimeType:
-                                contentType === 'text'
-                                    ? 'text/vtt'
-                                    : 'video/mp2t',
-                            segmentAlignment: false, // HLS doesn't signal this in the same way as DASH
-                            representations: [], // Representations for these are in their own playlists
-                            contentProtection: [],
-                            roles: [],
-                            profiles: null,
-                            group: null,
-                            bitstreamSwitching: null,
-                            maxWidth: null,
-                            maxHeight: null,
-                            maxFrameRate: null,
-                            framePackings: [],
-                            ratings: [],
-                            viewpoints: [],
-                            accessibility: [],
-                            labels: [],
-                            groupLabels: [],
-                            contentComponents: [],
-                            resyncs: [],
-                            outputProtection: null,
-                            stableRenditionId:
-                                media['STABLE-RENDITION-ID'] || null,
-                            bitDepth: media['BIT-DEPTH'] || null,
-                            sampleRate: media['SAMPLE-RATE'] || null,
-                            channels: media.CHANNELS || null,
-                            assocLanguage: media['ASSOC-LANGUAGE'] || null,
-                            characteristics: media.CHARACTERISTICS
-                                ? String(media.CHARACTERISTICS).split(',')
-                                : null,
-                            forced: media.FORCED === 'YES',
-                            serializedManifest: media,
-                        };
-                        periodIR.adaptationSets.push(as);
-                    });
-                }
-            );
-        });
-
-        // Second, process all variant streams from EXT-X-STREAM-INF tags.
-        hlsParsed.variants.forEach((variant, index) => {
-            const resolution = variant.attributes.RESOLUTION;
-
-            /** @type {Representation} */
-            const rep = {
-                id:
-                    variant.attributes['STABLE-VARIANT-ID'] ||
-                    `variant-${index}-rep-0`,
-                codecs: variant.attributes.CODECS || '',
-                bandwidth: variant.attributes.BANDWIDTH,
-                width: resolution
-                    ? parseInt(String(resolution).split('x')[0], 10)
-                    : null,
-                height: resolution
-                    ? parseInt(String(resolution).split('x')[1], 10)
-                    : null,
-                frameRate: variant.attributes['FRAME-RATE'] || null,
-                videoRange: variant.attributes['VIDEO-RANGE'] || null,
-                supplementalCodecs:
-                    variant.attributes['SUPPLEMENTAL-CODECS'] || null,
-                reqVideoLayout: variant.attributes['REQ-VIDEO-LAYOUT'] || null,
-                pathwayId: variant.attributes['PATHWAY-ID'] || null,
-                stableVariantId:
-                    variant.attributes['STABLE-VARIANT-ID'] || null,
-                sar: null,
-                qualityRanking: variant.attributes.SCORE,
-                mimeType: null,
-                profiles: null,
-                selectionPriority: null,
-                codingDependency: null,
-                scanType: null,
-                associationId: null,
-                associationType: null,
-                segmentProfiles: null,
-                mediaStreamStructureId: null,
-                maximumSAPPeriod: null,
-                startWithSAP: null,
-                maxPlayoutRate: null,
-                tag: null,
-                eptDelta: null,
-                pdDelta: null,
-                representationIndex: null,
-                failoverContent: null,
-                audioChannelConfigurations: [],
-                framePackings: [],
-                ratings: [],
-                viewpoints: [],
-                accessibility: [],
-                labels: [],
-                groupLabels: [],
-                subRepresentations: [],
-                resyncs: [],
-                outputProtection: null,
-                extendedBandwidth: null,
-                dependencyId: null,
-                serializedManifest: variant,
-            };
-
-            /** @type {AdaptationSet} */
-            const asIR = {
-                id: `variant-${index}`,
-                contentType: 'video', // Assume video if resolution/video codec is present
-                lang: null,
-                mimeType: 'video/mp2t',
-                segmentAlignment: false, // HLS doesn't signal this in the same way as DASH
-                representations: [rep],
-                contentProtection: [],
-                roles: [],
-                profiles: null,
-                group: null,
-                bitstreamSwitching: null,
-                maxWidth: null,
-                maxHeight: null,
-                maxFrameRate: null,
-                framePackings: [],
-                ratings: [],
-                viewpoints: [],
-                accessibility: [],
-                labels: [],
-                groupLabels: [],
-                contentComponents: [],
-                resyncs: [],
-                outputProtection: null,
-                stableRenditionId: null,
-                bitDepth: null,
-                sampleRate: null,
-                channels: null,
-                assocLanguage: null,
-                characteristics: null,
-                forced: false,
-                serializedManifest: variant,
-            };
-            periodIR.adaptationSets.push(asIR);
-        });
-    } else {
-        // Handle a simple Media Playlist
-        /** @type {AdaptationSet} */
-        const asIR = {
-            id: 'media-0',
-            contentType: 'video', // Assume video/muxed if not master
-            lang: null,
-            mimeType: hlsParsed.map ? 'video/mp4' : 'video/mp2t',
-            segmentAlignment: false, // HLS doesn't signal this in the same way as DASH
-            representations: [
-                {
-                    id: 'media-0-rep-0',
-                    codecs: null,
-                    bandwidth: 0,
-                    width: null,
-                    height: null,
-                    mimeType: null,
-                    profiles: null,
-                    qualityRanking: null,
-                    selectionPriority: null,
-                    codingDependency: null,
-                    scanType: null,
-                    associationId: null,
-                    associationType: null,
-                    segmentProfiles: null,
-                    mediaStreamStructureId: null,
-                    maximumSAPPeriod: null,
-                    startWithSAP: null,
-                    maxPlayoutRate: null,
-                    tag: null,
-                    eptDelta: null,
-                    pdDelta: null,
-                    representationIndex: null,
-                    failoverContent: null,
-                    audioChannelConfigurations: [],
-                    framePackings: [],
-                    ratings: [],
-                    viewpoints: [],
-                    accessibility: [],
-                    labels: [],
-                    groupLabels: [],
-                    videoRange: undefined,
-                    subRepresentations: [],
-                    resyncs: [],
-                    outputProtection: null,
-                    extendedBandwidth: null,
-                    dependencyId: null,
-                    frameRate: null,
-                    sar: null,
-                    stableVariantId: null,
-                    pathwayId: null,
-                    supplementalCodecs: null,
-                    reqVideoLayout: null,
-                    serializedManifest: hlsParsed,
-                },
-            ],
-            contentProtection: [],
-            roles: [],
-            profiles: null,
-            group: null,
-            bitstreamSwitching: null,
-            maxWidth: null,
-            maxHeight: null,
-            maxFrameRate: null,
-            framePackings: [],
-            ratings: [],
-            viewpoints: [],
-            accessibility: [],
-            labels: [],
-            groupLabels: [],
-            contentComponents: [],
-            resyncs: [],
-            outputProtection: null,
-            stableRenditionId: null,
-            bitDepth: null,
-            sampleRate: null,
-            channels: null,
-            assocLanguage: null,
-            characteristics: null,
-            forced: false,
-            serializedManifest: hlsParsed,
-        };
-        const keyTag = hlsParsed.segments.find((s) => s.key)?.key;
-        if (keyTag && keyTag.METHOD !== 'NONE') {
-            asIR.contentProtection.push({
-                schemeIdUri: keyTag.KEYFORMAT || 'identity',
-                system: keyTag.METHOD,
-                defaultKid: null,
-                robustness: null, // HLS EXT-X-KEY does not define robustness
-            });
-        }
-        periodIR.adaptationSets.push(asIR);
-    }
-
-    manifestIR.periods.push(periodIR);
-    manifestIR.summary = generateHlsSummary(manifestIR);
-
-    return manifestIR;
-}
diff --git a/js/infrastructure/manifest/hls/compliance-rules/encryption.js b/js/infrastructure/manifest/hls/compliance-rules/encryption.js
deleted file mode 100644
index 3bf81b3..0000000
--- a/js/infrastructure/manifest/hls/compliance-rules/encryption.js
+++ /dev/null
@@ -1,37 +0,0 @@
-/**
- * @typedef {'error' | 'warn' | 'info' | 'pass' | 'fail'} CheckStatus
- * @typedef {'Manifest Structure' | 'Live Stream Properties' | 'Segment & Timing Info' | 'Profile Conformance' | 'General Best Practices' | 'HLS Structure' | 'Encryption' | 'Interoperability' | 'Low-Latency HLS' | 'Variables & Steering'} RuleCategory
- * @typedef {'Playlist' | 'MediaPlaylist' | 'MasterPlaylist' | 'Segment' | 'Key' | 'MediaGroup' | 'Variant' | 'IframeVariant'} HlsRuleScope
- */
-
-/**
- * @typedef {object} HlsRule
- * @property {string} id - A unique identifier for the rule.
- * @property {string} text - The human-readable title of the check.
- * @property {string} isoRef - The reference to the standard clause.
- * @property {number} version - The HLS protocol version where this rule was introduced.
- * @property {CheckStatus} severity - The status to assign if the check fails ('fail' or 'warn').
- * @property {HlsRuleScope} scope - The HLS manifest level this rule applies to.
- * @property {(element: object, context: object) => boolean | 'skip'} check - The function that performs the validation.
- * @property {string} passDetails - Details for a passing check.
- * @property {string | ((element: object, context: object) => string)} failDetails - Details for a failing or warning check.
- * @property {RuleCategory} category
- */
-
-/** @type {HlsRule[]} */
-export const encryptionRules = [
-    {
-        id: 'HLS-KEY-1',
-        text: 'EXT-X-KEY must have a URI if method is not NONE',
-        isoRef: 'HLS 2nd Ed: 4.4.4.4',
-        version: 1,
-        severity: 'fail',
-        scope: 'Key',
-        category: 'Encryption',
-        check: (key) =>
-            key.METHOD === 'NONE' || (key.METHOD !== 'NONE' && key.URI),
-        passDetails: 'OK',
-        failDetails:
-            'The URI attribute is REQUIRED for EXT-X-KEY unless the METHOD is NONE.',
-    },
-];
diff --git a/js/infrastructure/manifest/hls/compliance-rules/index.js b/js/infrastructure/manifest/hls/compliance-rules/index.js
deleted file mode 100644
index aa98795..0000000
--- a/js/infrastructure/manifest/hls/compliance-rules/index.js
+++ /dev/null
@@ -1,38 +0,0 @@
-import { encryptionRules } from './encryption.js';
-import { interoperabilityRules } from './interoperability.js';
-import { liveRules } from './live.js';
-import { llHlsRules } from './ll-hls.js';
-import { segmentRules } from './segments.js';
-import { structureRules } from './structure.js';
-import { variableRules } from './variables.js';
-
-/**
- * @typedef {'error' | 'warn' | 'info' | 'pass' | 'fail'} CheckStatus
- * @typedef {'Manifest Structure' | 'Live Stream Properties' | 'Segment & Timing Info' | 'Profile Conformance' | 'General Best Practices' | 'HLS Structure' | 'Encryption' | 'Interoperability' | 'Low-Latency HLS' | 'Variables & Steering'} RuleCategory
- * @typedef {'Playlist' | 'MediaPlaylist' | 'MasterPlaylist' | 'Segment' | 'Key' | 'MediaGroup' | 'Variant' | 'IframeVariant'} HlsRuleScope
- */
-
-/**
- * @typedef {object} HlsRule
- * @property {string} id - A unique identifier for the rule.
- * @property {string} text - The human-readable title of the check.
- * @property {string} isoRef - The reference to the standard clause.
- * @property {number} version - The HLS protocol version where this rule was introduced.
- * @property {CheckStatus} severity - The status to assign if the check fails ('fail' or 'warn').
- * @property {HlsRuleScope} scope - The HLS manifest level this rule applies to.
- * @property {(element: object, context: object) => boolean | 'skip'} check - The function that performs the validation.
- * @property {string} passDetails - Details for a passing check.
- * @property {string | ((element: object, context: object) => string)} failDetails - Details for a failing or warning check.
- * @property {RuleCategory} category
- */
-
-/** @type {HlsRule[]} */
-export const rules = [
-    ...structureRules,
-    ...variableRules,
-    ...liveRules,
-    ...llHlsRules,
-    ...segmentRules,
-    ...encryptionRules,
-    ...interoperabilityRules,
-];
diff --git a/js/infrastructure/manifest/hls/compliance-rules/interoperability.js b/js/infrastructure/manifest/hls/compliance-rules/interoperability.js
deleted file mode 100644
index 2939070..0000000
--- a/js/infrastructure/manifest/hls/compliance-rules/interoperability.js
+++ /dev/null
@@ -1,36 +0,0 @@
-/**
- * @typedef {'error' | 'warn' | 'info' | 'pass' | 'fail'} CheckStatus
- * @typedef {'Manifest Structure' | 'Live Stream Properties' | 'Segment & Timing Info' | 'Profile Conformance' | 'General Best Practices' | 'HLS Structure' | 'Encryption' | 'Interoperability' | 'Low-Latency HLS' | 'Variables & Steering'} RuleCategory
- * @typedef {'Playlist' | 'MediaPlaylist' | 'MasterPlaylist' | 'Segment' | 'Key' | 'MediaGroup' | 'Variant' | 'IframeVariant'} HlsRuleScope
- */
-
-/**
- * @typedef {object} HlsRule
- * @property {string} id - A unique identifier for the rule.
- * @property {string} text - The human-readable title of the check.
- * @property {string} isoRef - The reference to the standard clause.
- * @property {number} version - The HLS protocol version where this rule was introduced.
- * @property {CheckStatus} severity - The status to assign if the check fails ('fail' or 'warn').
- * @property {HlsRuleScope} scope - The HLS manifest level this rule applies to.
- * @property {(element: object, context: object) => boolean | 'skip'} check - The function that performs the validation.
- * @property {string} passDetails - Details for a passing check.
- * @property {string | ((element: object, context: object) => string)} failDetails - Details for a failing or warning check.
- * @property {RuleCategory} category
- */
-
-/** @type {HlsRule[]} */
-export const interoperabilityRules = [
-    {
-        id: 'HLS-VARIANT-2',
-        text: 'EXT-X-STREAM-INF should have CODECS attribute',
-        isoRef: 'HLS 2nd Ed: 4.4.6.2',
-        version: 1,
-        severity: 'warn',
-        scope: 'Variant',
-        category: 'Interoperability',
-        check: (variant) => variant.attributes.CODECS !== undefined,
-        passDetails: 'OK',
-        failDetails:
-            'The CODECS attribute SHOULD be present for a client to make an informed selection.',
-    },
-];
diff --git a/js/infrastructure/manifest/hls/compliance-rules/live.js b/js/infrastructure/manifest/hls/compliance-rules/live.js
deleted file mode 100644
index 3e7f379..0000000
--- a/js/infrastructure/manifest/hls/compliance-rules/live.js
+++ /dev/null
@@ -1,56 +0,0 @@
-/**
- * @typedef {'error' | 'warn' | 'info' | 'pass' | 'fail'} CheckStatus
- * @typedef {'Manifest Structure' | 'Live Stream Properties' | 'Segment & Timing Info' | 'Profile Conformance' | 'General Best Practices' | 'HLS Structure' | 'Encryption' | 'Interoperability' | 'Low-Latency HLS' | 'Variables & Steering'} RuleCategory
- * @typedef {'Playlist' | 'MediaPlaylist' | 'MasterPlaylist' | 'Segment' | 'Key' | 'MediaGroup' | 'Variant' | 'IframeVariant'} HlsRuleScope
- */
-
-/**
- * @typedef {object} HlsRule
- * @property {string} id - A unique identifier for the rule.
- * @property {string} text - The human-readable title of the check.
- * @property {string} isoRef - The reference to the standard clause.
- * @property {number} version - The HLS protocol version where this rule was introduced.
- * @property {CheckStatus} severity - The status to assign if the check fails ('fail' or 'warn').
- * @property {HlsRuleScope} scope - The HLS manifest level this rule applies to.
- * @property {(element: object, context: object) => boolean | 'skip'} check - The function that performs the validation.
- * @property {string} passDetails - Details for a passing check.
- * @property {string | ((element: object, context: object) => string)} failDetails - Details for a failing or warning check.
- * @property {RuleCategory} category
- */
-
-/** @type {HlsRule[]} */
-export const liveRules = [
-    {
-        id: 'HLS-MEDIA-2',
-        text: 'Live Media Playlist must not contain EXT-X-ENDLIST',
-        isoRef: 'HLS 2nd Ed: 6.2.1',
-        version: 1,
-        severity: 'fail',
-        scope: 'MediaPlaylist',
-        category: 'Live Stream Properties',
-        check: (hls, { isLive }) => {
-            if (!isLive) return 'skip';
-            return !hls.tags.some((t) => t.name === 'EXT-X-ENDLIST');
-        },
-        passDetails: 'OK',
-        failDetails:
-            'A live Media Playlist MUST NOT contain the EXT-X-ENDLIST tag.',
-    },
-    {
-        id: 'HLS-MEDIA-3',
-        text: 'Live Media Playlist should have EXT-X-MEDIA-SEQUENCE',
-        isoRef: 'HLS 2nd Ed: 6.2.2',
-        version: 1,
-        severity: 'warn',
-        scope: 'MediaPlaylist',
-        category: 'Live Stream Properties',
-        check: (hls, { isLive }) => {
-            if (!isLive) return 'skip';
-            // It's only strictly required if segments are to be removed. We warn because this is common for live.
-            return hls.tags.some((t) => t.name === 'EXT-X-MEDIA-SEQUENCE');
-        },
-        passDetails: 'OK',
-        failDetails:
-            'For live playlists where segments are removed, EXT-X-MEDIA-SEQUENCE is essential for clients to reload correctly.',
-    },
-];
diff --git a/js/infrastructure/manifest/hls/compliance-rules/ll-hls.js b/js/infrastructure/manifest/hls/compliance-rules/ll-hls.js
deleted file mode 100644
index a8eb196..0000000
--- a/js/infrastructure/manifest/hls/compliance-rules/ll-hls.js
+++ /dev/null
@@ -1,164 +0,0 @@
-/**
- * @typedef {'error' | 'warn' | 'info' | 'pass' | 'fail'} CheckStatus
- * @typedef {'Manifest Structure' | 'Live Stream Properties' | 'Segment & Timing Info' | 'Profile Conformance' | 'General Best Practices' | 'HLS Structure' | 'Encryption' | 'Interoperability' | 'Low-Latency HLS' | 'Variables & Steering'} RuleCategory
- * @typedef {'Playlist' | 'MediaPlaylist' | 'MasterPlaylist' | 'Segment' | 'Key' | 'MediaGroup' | 'Variant' | 'IframeVariant'} HlsRuleScope
- */
-
-/**
- * @typedef {object} HlsRule
- * @property {string} id - A unique identifier for the rule.
- * @property {string} text - The human-readable title of the check.
- * @property {string} isoRef - The reference to the standard clause.
- * @property {number} version - The HLS protocol version where this rule was introduced.
- * @property {CheckStatus} severity - The status to assign if the check fails ('fail' or 'warn').
- * @property {HlsRuleScope} scope - The HLS manifest level this rule applies to.
- * @property {(element: object, context: object) => boolean | 'skip'} check - The function that performs the validation.
- * @property {string} passDetails - Details for a passing check.
- * @property {string | ((element: object, context: object) => string)} failDetails - Details for a failing or warning check.
- * @property {RuleCategory} category
- */
-
-/** @type {HlsRule[]} */
-export const llHlsRules = [
-    {
-        id: 'LL-HLS-1',
-        text: 'LL-HLS requires EXT-X-PART-INF if PARTs are present',
-        isoRef: 'HLS 2nd Ed: 4.4.3.7',
-        version: 9,
-        severity: 'fail',
-        scope: 'MediaPlaylist',
-        category: 'Low-Latency HLS',
-        check: (hls) => {
-            const hasParts = hls.segments.some(
-                (s) => s.parts && s.parts.length > 0
-            );
-            if (!hasParts && !hls.preloadHints.some((h) => h.TYPE === 'PART'))
-                return 'skip';
-            return !!hls.partInf;
-        },
-        passDetails: 'OK, EXT-X-PART-INF is present as required.',
-        failDetails:
-            'The playlist contains PARTs or PART hints but is missing the required EXT-X-PART-INF tag.',
-    },
-    {
-        id: 'LL-HLS-2',
-        text: 'LL-HLS requires EXT-X-VERSION of 9 or greater',
-        isoRef: 'HLS 2nd Ed: 4.4.3.7',
-        version: 9,
-        severity: 'fail',
-        scope: 'MediaPlaylist',
-        category: 'Low-Latency HLS',
-        check: (hls) => {
-            if (!hls.partInf) return 'skip';
-            return hls.version >= 9;
-        },
-        passDetails: 'OK, EXT-X-VERSION is 9 or greater.',
-        failDetails:
-            'Playlists containing Partial Segments (PARTs) MUST have an EXT-X-VERSION of 9 or greater.',
-    },
-    {
-        id: 'LL-HLS-3',
-        text: 'EXT-X-PART-INF must have PART-TARGET attribute',
-        isoRef: 'HLS 2nd Ed: 4.4.3.7',
-        version: 9,
-        severity: 'fail',
-        scope: 'MediaPlaylist',
-        category: 'Low-Latency HLS',
-        check: (hls) => {
-            if (!hls.partInf) return 'skip';
-            return hls.partInf['PART-TARGET'] !== undefined;
-        },
-        passDetails: 'OK, PART-TARGET is present.',
-        failDetails:
-            'The EXT-X-PART-INF tag MUST have a PART-TARGET attribute.',
-    },
-    {
-        id: 'LL-HLS-4',
-        text: 'LL-HLS requires a PART-HOLD-BACK attribute',
-        isoRef: 'HLS 2nd Ed: 4.4.3.8',
-        version: 9,
-        severity: 'fail',
-        scope: 'MediaPlaylist',
-        category: 'Low-Latency HLS',
-        check: (hls) => {
-            if (!hls.partInf) return 'skip';
-            return (
-                hls.serverControl &&
-                hls.serverControl['PART-HOLD-BACK'] !== undefined
-            );
-        },
-        passDetails: 'OK, PART-HOLD-BACK is specified.',
-        failDetails:
-            'Playlists containing PARTs must specify a PART-HOLD-BACK attribute in the EXT-X-SERVER-CONTROL tag.',
-    },
-    {
-        id: 'LL-HLS-5',
-        text: 'LL-HLS PART-HOLD-BACK must be >= 2x PART-TARGET',
-        isoRef: 'HLS 2nd Ed: 4.4.3.8',
-        version: 9,
-        severity: 'fail',
-        scope: 'MediaPlaylist',
-        category: 'Low-Latency HLS',
-        check: (hls) => {
-            if (
-                !hls.partInf?.['PART-TARGET'] ||
-                !hls.serverControl?.['PART-HOLD-BACK']
-            )
-                return 'skip';
-            const partHoldBack = hls.serverControl['PART-HOLD-BACK'];
-            const partTarget = hls.partInf['PART-TARGET'];
-            return partHoldBack >= 2 * partTarget;
-        },
-        passDetails: 'OK, PART-HOLD-BACK is a valid duration.',
-        failDetails: (hls) =>
-            `PART-HOLD-BACK (${hls.serverControl['PART-HOLD-BACK']}s) must be at least twice the PART-TARGET (${hls.partInf['PART-TARGET']}s).`,
-    },
-    {
-        id: 'LL-HLS-6',
-        text: 'LL-HLS profile requires EXT-X-PROGRAM-DATE-TIME tags',
-        isoRef: 'HLS 2nd Ed: Appendix B.1',
-        version: 9,
-        severity: 'fail',
-        scope: 'MediaPlaylist',
-        category: 'Low-Latency HLS',
-        check: (hls) => {
-            if (!hls.partInf) return 'skip';
-            return hls.segments.some((s) => s.dateTime);
-        },
-        passDetails: 'OK, at least one PDT tag is present.',
-        failDetails:
-            'The Low-Latency HLS profile requires EXT-X-PROGRAM-DATE-TIME tags for precise synchronization.',
-    },
-    {
-        id: 'LL-HLS-7',
-        text: 'LL-HLS profile requires EXT-X-PRELOAD-HINT for the next Partial Segment',
-        isoRef: 'HLS 2nd Ed: Appendix B.1',
-        version: 9,
-        severity: 'fail',
-        scope: 'MediaPlaylist',
-        category: 'Low-Latency HLS',
-        check: (hls) => {
-            if (!hls.partInf || !hls.isLive) return 'skip';
-            return hls.preloadHints.some((t) => t.TYPE === 'PART');
-        },
-        passDetails: 'OK, a preload hint for a partial segment was found.',
-        failDetails:
-            'The Low-Latency HLS profile requires a preload hint for the next expected partial segment to reduce latency.',
-    },
-    {
-        id: 'LL-HLS-8',
-        text: 'LL-HLS profile requires EXT-X-RENDITION-REPORT tags in media playlists',
-        isoRef: 'HLS 2nd Ed: Appendix B.1',
-        version: 9,
-        severity: 'fail',
-        scope: 'MediaPlaylist',
-        category: 'Low-Latency HLS',
-        check: (hls) => {
-            if (!hls.partInf || !hls.isLive) return 'skip';
-            return hls.renditionReports.length > 0;
-        },
-        passDetails: 'OK, rendition reports are present.',
-        failDetails:
-            'The Low-Latency HLS profile requires rendition reports in each media playlist to avoid tune-in delays.',
-    },
-];
diff --git a/js/infrastructure/manifest/hls/compliance-rules/segments.js b/js/infrastructure/manifest/hls/compliance-rules/segments.js
deleted file mode 100644
index 92db0a8..0000000
--- a/js/infrastructure/manifest/hls/compliance-rules/segments.js
+++ /dev/null
@@ -1,57 +0,0 @@
-/**
- * @typedef {'error' | 'warn' | 'info' | 'pass' | 'fail'} CheckStatus
- * @typedef {'Manifest Structure' | 'Live Stream Properties' | 'Segment & Timing Info' | 'Profile Conformance' | 'General Best Practices' | 'HLS Structure' | 'Encryption' | 'Interoperability' | 'Low-Latency HLS' | 'Variables & Steering'} RuleCategory
- * @typedef {'Playlist' | 'MediaPlaylist' | 'MasterPlaylist' | 'Segment' | 'Key' | 'MediaGroup' | 'Variant' | 'IframeVariant'} HlsRuleScope
- */
-
-/**
- * @typedef {object} HlsRule
- * @property {string} id - A unique identifier for the rule.
- * @property {string} text - The human-readable title of the check.
- * @property {string} isoRef - The reference to the standard clause.
- * @property {number} version - The HLS protocol version where this rule was introduced.
- * @property {CheckStatus} severity - The status to assign if the check fails ('fail' or 'warn').
- * @property {HlsRuleScope} scope - The HLS manifest level this rule applies to.
- * @property {(element: object, context: object) => boolean | 'skip'} check - The function that performs the validation.
- * @property {string} passDetails - Details for a passing check.
- * @property {string | ((element: object, context: object) => string)} failDetails - Details for a failing or warning check.
- * @property {RuleCategory} category
- */
-
-/** @type {HlsRule[]} */
-export const segmentRules = [
-    {
-        id: 'HLS-SEGMENT-2',
-        text: 'EXTINF duration must be <= target duration (integer rounded)',
-        isoRef: 'HLS 2nd Ed: 4.4.3.1',
-        version: 1,
-        severity: 'fail',
-        scope: 'Segment',
-        category: 'Segment & Timing Info',
-        check: (segment, { targetDuration }) => {
-            if (targetDuration === null) return 'skip';
-            return Math.round(segment.duration) <= targetDuration;
-        },
-        passDetails: 'OK',
-        failDetails: (segment, { targetDuration }) =>
-            `Segment duration (${segment.duration}s) rounded to the nearest integer (${Math.round(segment.duration)}s) MUST be <= the target duration (${targetDuration}s).`,
-    },
-    {
-        id: 'HLS-PART-1',
-        text: 'EXT-X-PART must have URI and DURATION attributes',
-        isoRef: 'HLS 2nd Ed: 4.4.4.9',
-        version: 9,
-        severity: 'fail',
-        scope: 'Segment',
-        category: 'Low-Latency HLS',
-        check: (segment) => {
-            if (!segment.parts || segment.parts.length === 0) return 'skip';
-            return segment.parts.every(
-                (p) => p.URI !== undefined && p.DURATION !== undefined
-            );
-        },
-        passDetails: 'OK',
-        failDetails:
-            'Each EXT-X-PART tag must have URI and DURATION attributes.',
-    },
-];
diff --git a/js/infrastructure/manifest/hls/compliance-rules/structure.js b/js/infrastructure/manifest/hls/compliance-rules/structure.js
deleted file mode 100644
index 6dc9e6f..0000000
--- a/js/infrastructure/manifest/hls/compliance-rules/structure.js
+++ /dev/null
@@ -1,227 +0,0 @@
-/**
- * @typedef {'error' | 'warn' | 'info' | 'pass' | 'fail'} CheckStatus
- * @typedef {'Manifest Structure' | 'Live Stream Properties' | 'Segment & Timing Info' | 'Profile Conformance' | 'General Best Practices' | 'HLS Structure' | 'Encryption' | 'Interoperability' | 'Low-Latency HLS' | 'Variables & Steering'} RuleCategory
- * @typedef {'Playlist' | 'MediaPlaylist' | 'MasterPlaylist' | 'Segment' | 'Key' | 'MediaGroup' | 'Variant' | 'IframeVariant'} HlsRuleScope
- */
-
-/**
- * @typedef {object} HlsRule
- * @property {string} id - A unique identifier for the rule.
- * @property {string} text - The human-readable title of the check.
- * @property {string} isoRef - The reference to the standard clause.
- * @property {number} version - The HLS protocol version where this rule was introduced.
- * @property {CheckStatus} severity - The status to assign if the check fails ('fail' or 'warn').
- * @property {HlsRuleScope} scope - The HLS manifest level this rule applies to.
- * @property {(element: object, context: object) => boolean | 'skip'} check - The function that performs the validation.
- * @property {string} passDetails - Details for a passing check.
- * @property {string | ((element: object, context: object) => string)} failDetails - Details for a failing or warning check.
- * @property {RuleCategory} category
- */
-
-/** @type {HlsRule[]} */
-export const structureRules = [
-    {
-        id: 'HLS-1',
-        text: 'Playlist must start with #EXTM3U',
-        isoRef: 'HLS 2nd Ed: 4.4.1.1',
-        version: 1,
-        severity: 'fail',
-        scope: 'Playlist',
-        category: 'HLS Structure',
-        check: (hls) =>
-            hls.serializedManifest.raw &&
-            hls.serializedManifest.raw.trim().startsWith('#EXTM3U'),
-        passDetails: 'OK',
-        failDetails: 'The playlist must begin with the #EXTM3U tag.',
-    },
-    {
-        id: 'HLS-2',
-        text: 'Playlist must contain no more than one EXT-X-VERSION tag',
-        isoRef: 'HLS 2nd Ed: 4.4.1.2',
-        version: 1,
-        severity: 'fail',
-        scope: 'Playlist',
-        category: 'HLS Structure',
-        check: (hls) =>
-            hls.tags.filter((t) => t.name === 'EXT-X-VERSION').length <= 1,
-        passDetails: 'OK',
-        failDetails:
-            'A playlist MUST NOT contain more than one EXT-X-VERSION tag.',
-    },
-    {
-        id: 'HLS-5',
-        text: 'Playlist must not mix Media and Multivariant tags',
-        isoRef: 'HLS 2nd Ed: 4.1',
-        version: 1,
-        severity: 'fail',
-        scope: 'Playlist',
-        category: 'HLS Structure',
-        check: (hls) => !(hls.isMaster && hls.segments.length > 0),
-        passDetails: 'OK',
-        failDetails:
-            'A playlist cannot be both a Media Playlist (with segments) and a Multivariant Playlist (with variants). It must be one or the other.',
-    },
-    {
-        id: 'HLS-MEDIA-1',
-        text: 'Media Playlist must contain an EXT-X-TARGETDURATION tag',
-        isoRef: 'HLS 2nd Ed: 4.4.3.1',
-        version: 1,
-        severity: 'fail',
-        scope: 'MediaPlaylist',
-        category: 'HLS Structure',
-        check: (hls) =>
-            hls.targetDuration !== undefined && hls.targetDuration !== null,
-        passDetails: 'OK',
-        failDetails:
-            'The EXT-X-TARGETDURATION tag is REQUIRED for Media Playlists.',
-    },
-    {
-        id: 'HLS-MEDIA-4',
-        text: 'VOD playlist implies EXT-X-ENDLIST must be present',
-        isoRef: 'HLS 2nd Ed: 4.4.3.4',
-        version: 1,
-        severity: 'fail',
-        scope: 'MediaPlaylist',
-        category: 'HLS Structure',
-        check: (hls) => {
-            if (hls.playlistType === 'VOD' || !hls.isLive) {
-                return hls.tags.some((t) => t.name === 'EXT-X-ENDLIST');
-            }
-            return 'skip';
-        },
-        passDetails: 'OK',
-        failDetails:
-            'A VOD or non-live playlist MUST contain the EXT-X-ENDLIST tag.',
-    },
-    {
-        id: 'HLS-MASTER-1',
-        text: 'Multivariant Playlist must contain at least one EXT-X-STREAM-INF tag',
-        isoRef: 'HLS 2nd Ed: 4.1',
-        version: 1,
-        severity: 'fail',
-        scope: 'MasterPlaylist',
-        category: 'HLS Structure',
-        check: (hls) => hls.variants && hls.variants.length > 0,
-        passDetails: 'OK',
-        failDetails:
-            'A Multivariant Playlist must list at least one Variant Stream.',
-    },
-    {
-        id: 'HLS-INSTREAM-ID-VERSION',
-        text: 'INSTREAM-ID for non-CC types requires version 13',
-        isoRef: 'HLS 2nd Ed: 8',
-        version: 13,
-        severity: 'fail',
-        scope: 'MasterPlaylist',
-        category: 'HLS Structure',
-        check: (hls, context) => {
-            const hasAdvancedInstreamId = (hls.tags || []).some(
-                (t) =>
-                    t.name === 'EXT-X-MEDIA' &&
-                    t.value['INSTREAM-ID'] &&
-                    t.value.TYPE !== 'CLOSED-CAPTIONS'
-            );
-            if (!hasAdvancedInstreamId) {
-                return 'skip';
-            }
-            return context.standardVersion >= 13;
-        },
-        passDetails:
-            'OK, playlist version is sufficient for advanced INSTREAM-ID usage.',
-        failDetails:
-            'EXT-X-MEDIA with INSTREAM-ID for types other than CLOSED-CAPTIONS requires EXT-X-VERSION 13 or higher.',
-    },
-    {
-        id: 'HLS-VARIANT-1',
-        text: 'EXT-X-STREAM-INF must have a BANDWIDTH attribute',
-        isoRef: 'HLS 2nd Ed: 4.4.6.2',
-        version: 1,
-        severity: 'fail',
-        scope: 'Variant',
-        category: 'HLS Structure',
-        check: (variant) =>
-            variant.attributes && variant.attributes.BANDWIDTH !== undefined,
-        passDetails: 'OK',
-        failDetails:
-            'Every EXT-X-STREAM-INF tag MUST include the BANDWIDTH attribute.',
-    },
-    {
-        id: 'HLS-VARIANT-3',
-        text: 'EXT-X-STREAM-INF must be followed by a URI',
-        isoRef: 'HLS 2nd Ed: 4.4.6.2',
-        version: 1,
-        severity: 'fail',
-        scope: 'Variant',
-        category: 'HLS Structure',
-        check: (variant) => variant.uri && variant.uri.trim() !== '',
-        passDetails: 'OK',
-        failDetails:
-            'The EXT-X-STREAM-INF tag must be followed by the URI of its Media Playlist on the next line.',
-    },
-    {
-        id: 'HLS-VARIANT-4',
-        text: 'CLOSED-CAPTIONS=NONE must apply to all variants if used',
-        isoRef: 'HLS 2nd Ed: 4.4.6.2',
-        version: 4,
-        severity: 'fail',
-        scope: 'MasterPlaylist',
-        category: 'HLS Structure',
-        check: (hls) => {
-            const variantsWithCC = hls.variants.filter(
-                (v) => v.attributes['CLOSED-CAPTIONS'] !== undefined
-            );
-            if (variantsWithCC.length === 0) return 'skip';
-            const hasNone = variantsWithCC.some(
-                (v) => v.attributes['CLOSED-CAPTIONS'] === 'NONE'
-            );
-            if (!hasNone) return 'skip';
-            return hls.variants.every(
-                (v) => v.attributes['CLOSED-CAPTIONS'] === 'NONE'
-            );
-        },
-        passDetails: 'OK',
-        failDetails:
-            'If the value of the CLOSED-CAPTIONS attribute is NONE, all EXT-X-STREAM-INF tags MUST have this attribute with a value of NONE.',
-    },
-    {
-        id: 'HLS-SEGMENT-1',
-        text: 'Each Media Segment must be preceded by an EXTINF tag',
-        isoRef: 'HLS 2nd Ed: 4.4.4.1',
-        version: 1,
-        severity: 'fail',
-        scope: 'Segment',
-        category: 'HLS Structure',
-        check: (segment) => segment.duration !== undefined,
-        passDetails: 'OK',
-        failDetails: 'The EXTINF tag is REQUIRED for each Media Segment.',
-    },
-    {
-        id: 'HLS-MEDIA-5',
-        text: 'A Rendition Group must not have more than one DEFAULT=YES member',
-        isoRef: 'HLS 2nd Ed: 4.4.6.1.1',
-        version: 4,
-        severity: 'fail',
-        scope: 'MediaGroup',
-        category: 'HLS Structure',
-        check: (group) => group.filter((m) => m.DEFAULT === 'YES').length <= 1,
-        passDetails: 'OK',
-        failDetails:
-            'A group of renditions MUST NOT have more than one member with DEFAULT=YES.',
-    },
-    {
-        id: 'HLS-MEDIA-6',
-        text: 'All members of a Rendition Group must have different NAME attributes',
-        isoRef: 'HLS 2nd Ed: 4.4.6.1.1',
-        version: 4,
-        severity: 'fail',
-        scope: 'MediaGroup',
-        category: 'HLS Structure',
-        check: (group) => {
-            const names = group.map((m) => m.NAME);
-            return new Set(names).size === names.length;
-        },
-        passDetails: 'OK',
-        failDetails:
-            'All EXT-X-MEDIA tags in the same Group MUST have different NAME attributes.',
-    },
-];
diff --git a/js/infrastructure/manifest/hls/compliance-rules/variables.js b/js/infrastructure/manifest/hls/compliance-rules/variables.js
deleted file mode 100644
index 17e5832..0000000
--- a/js/infrastructure/manifest/hls/compliance-rules/variables.js
+++ /dev/null
@@ -1,70 +0,0 @@
-/**
- * @typedef {'error' | 'warn' | 'info' | 'pass' | 'fail'} CheckStatus
- * @typedef {'Manifest Structure' | 'Live Stream Properties' | 'Segment & Timing Info' | 'Profile Conformance' | 'General Best Practices' | 'HLS Structure' | 'Encryption' | 'Interoperability' | 'Low-Latency HLS' | 'Variables & Steering'} RuleCategory
- * @typedef {'Playlist' | 'MediaPlaylist' | 'MasterPlaylist' | 'Segment' | 'Key' | 'MediaGroup' | 'Variant' | 'IframeVariant'} HlsRuleScope
- */
-
-/**
- * @typedef {object} HlsRule
- * @property {string} id - A unique identifier for the rule.
- * @property {string} text - The human-readable title of the check.
- * @property {string} isoRef - The reference to the standard clause.
- * @property {number} version - The HLS protocol version where this rule was introduced.
- * @property {CheckStatus} severity - The status to assign if the check fails ('fail' or 'warn').
- * @property {HlsRuleScope} scope - The HLS manifest level this rule applies to.
- * @property {(element: object, context: object) => boolean | 'skip'} check - The function that performs the validation.
- * @property {string} passDetails - Details for a passing check.
- * @property {string | ((element: object, context: object) => string)} failDetails - Details for a failing or warning check.
- * @property {RuleCategory} category
- */
-
-/** @type {HlsRule[]} */
-export const variableRules = [
-    {
-        id: 'HLS-DEFINE-1',
-        text: 'EXT-X-DEFINE tag must contain a NAME, IMPORT, or QUERYPARAM attribute',
-        isoRef: 'HLS 2nd Ed: 4.4.2.3',
-        version: 8,
-        severity: 'fail',
-        scope: 'Playlist',
-        category: 'Variables & Steering',
-        check: (hls) => {
-            const defineTags = hls.tags.filter(
-                (t) => t.name === 'EXT-X-DEFINE'
-            );
-            if (defineTags.length === 0) return 'skip';
-            return defineTags.every(
-                (t) =>
-                    (t.value.NAME && t.value.VALUE !== undefined) ||
-                    t.value.IMPORT ||
-                    t.value.QUERYPARAM
-            );
-        },
-        passDetails: 'OK',
-        failDetails:
-            'Every EXT-X-DEFINE tag MUST have a NAME/VALUE, IMPORT, or QUERYPARAM attribute.',
-    },
-    {
-        id: 'HLS-DEFINE-2',
-        text: 'EXT-X-DEFINE tag variable names must be unique within a playlist',
-        isoRef: 'HLS 2nd Ed: 4.4.2.3',
-        version: 8,
-        severity: 'fail',
-        scope: 'Playlist',
-        category: 'Variables & Steering',
-        check: (hls) => {
-            const defineTags = hls.tags.filter(
-                (t) => t.name === 'EXT-X-DEFINE'
-            );
-            if (defineTags.length === 0) return 'skip';
-            const names = defineTags.map(
-                (t) =>
-                    t.value.NAME || t.value.IMPORT || t.value.QUERYPARAM || ''
-            );
-            return new Set(names).size === names.length;
-        },
-        passDetails: 'OK',
-        failDetails:
-            'An EXT-X-DEFINE tag MUST NOT specify the same Variable Name as any other EXT-X-DEFINE tag in the same Playlist.',
-    },
-];
diff --git a/js/infrastructure/manifest/hls/feature-analyzer.js b/js/infrastructure/manifest/hls/feature-analyzer.js
deleted file mode 100644
index 83f5124..0000000
--- a/js/infrastructure/manifest/hls/feature-analyzer.js
+++ /dev/null
@@ -1,323 +0,0 @@
-/**
- * @typedef {import('../../../app/types.js').Manifest} Manifest
- * @typedef {object} FeatureCheckResult
- * @property {boolean} used
- * @property {string} details
- */
-
-/**
- * Runs a series of HLS-specific checks against a manifest IR object.
- * @param {Manifest} manifestIR - The manifest IR object.
- * @returns {Record<string, FeatureCheckResult>} A map of feature names to their analysis results.
- */
-export function analyzeHlsFeatures(manifestIR) {
-    /** @type {Record<string, FeatureCheckResult>} */
-    const results = {};
-    const tags = manifestIR.tags || [];
-    const allAdaptationSets = manifestIR.periods.flatMap(
-        (p) => p.adaptationSets
-    );
-
-    results['Presentation Type'] = {
-        used: true,
-        details:
-            manifestIR.type === 'dynamic'
-                ? '<code>EVENT</code> or Live'
-                : '<code>VOD</code>',
-    };
-
-    results['Multivariant Playlist'] = {
-        used: manifestIR.isMaster,
-        details: manifestIR.isMaster
-            ? `${manifestIR.variants?.length || 0} Variant Streams found.`
-            : 'Media Playlist.',
-    };
-
-    results['Byte-Range Segments'] = {
-        used: tags.some((t) => t.name === 'EXT-X-BYTERANGE'),
-        details: 'Uses #EXT-X-BYTERANGE to define segments as sub-ranges.',
-    };
-
-    results['Discontinuity Sequence'] = {
-        used: tags.some((t) => t.name === 'EXT-X-DISCONTINUITY-SEQUENCE'),
-        details: 'Uses #EXT-X-DISCONTINUITY-SEQUENCE for synchronization.',
-    };
-
-    results['HDCP Level'] = {
-        used: (manifestIR.variants || []).some(
-            (v) => v.attributes['HDCP-LEVEL']
-        ),
-        details: 'HDCP-LEVEL attribute is present on one or more variants.',
-    };
-
-    const hasStableIds =
-        (manifestIR.variants || []).some(
-            (v) => v.attributes['STABLE-VARIANT-ID']
-        ) || allAdaptationSets.some((as) => as.stableRenditionId);
-    results['Stable Variant/Rendition IDs'] = {
-        used: hasStableIds,
-        details: hasStableIds
-            ? 'Uses STABLE-VARIANT-ID and/or STABLE-RENDITION-ID for persistent references.'
-            : 'Not used.',
-    };
-
-    const hasAdvancedChannels = allAdaptationSets.some(
-        (as) => as.channels && String(as.channels).includes('/')
-    );
-    results['Advanced Spatial Audio (CHANNELS)'] = {
-        used: hasAdvancedChannels,
-        details: hasAdvancedChannels
-            ? 'CHANNELS attribute contains advanced spatial audio parameters.'
-            : 'Not used.',
-    };
-
-    const hasMachineGenerated = allAdaptationSets.some(
-        (as) =>
-            as.characteristics &&
-            as.characteristics.includes('public.machine-generated')
-    );
-    results['Machine-Generated Content Flag'] = {
-        used: hasMachineGenerated,
-        details: hasMachineGenerated
-            ? 'One or more renditions are marked as machine-generated.'
-            : 'Not used.',
-    };
-
-    const hasDiscontinuity = (manifestIR.segments || []).some(
-        (s) => s.discontinuity
-    );
-    results['Discontinuity'] = {
-        used: hasDiscontinuity,
-        details: hasDiscontinuity
-            ? 'Contains #EXT-X-DISCONTINUITY tags.'
-            : 'No discontinuities found.',
-    };
-
-    const keyTag = tags.find((t) => t.name === 'EXT-X-KEY');
-    if (keyTag && keyTag.value.METHOD !== 'NONE') {
-        const methods = [
-            ...new Set(
-                tags
-                    .filter((t) => t.name === 'EXT-X-KEY')
-                    .map((t) => t.value.METHOD)
-            ),
-        ];
-        results['Content Protection'] = {
-            used: true,
-            details: `Methods: <b>${methods.join(', ')}</b>`,
-        };
-    } else {
-        results['Content Protection'] = {
-            used: false,
-            details: 'No #EXT-X-KEY tags found.',
-        };
-    }
-
-    const hasFmp4 = tags.some((t) => t.name === 'EXT-X-MAP');
-    results['Fragmented MP4 Segments'] = {
-        used: hasFmp4,
-        details: hasFmp4
-            ? 'Uses #EXT-X-MAP, indicating fMP4 segments.'
-            : 'Likely Transport Stream (TS) segments.',
-    };
-
-    const hasGap = (manifestIR.segments || []).some((s) => s.gap);
-    results['Gap Segments'] = {
-        used: hasGap,
-        details: hasGap
-            ? 'Contains #EXT-X-GAP tags to signal missing media.'
-            : 'No gap tags found.',
-    };
-
-    const hasBitrate = (manifestIR.segments || []).some((s) => s.bitrate);
-    results['Bitrate Hinting'] = {
-        used: hasBitrate,
-        details: hasBitrate
-            ? 'Contains #EXT-X-BITRATE tags.'
-            : 'No bitrate tags found.',
-    };
-
-    results['I-Frame Playlists'] = {
-        used: tags.some((t) => t.name === 'EXT-X-I-FRAME-STREAM-INF'),
-        details: 'Provides dedicated playlists for trick-play modes.',
-    };
-
-    const mediaTags = tags.filter((t) => t.name === 'EXT-X-MEDIA');
-    results['Alternative Renditions'] = {
-        used: mediaTags.length > 0,
-        details:
-            mediaTags.length > 0
-                ? `${mediaTags.length} #EXT-X-MEDIA tags found.`
-                : 'No separate audio/video/subtitle renditions declared.',
-    };
-
-    results['Associated Language'] = {
-        used: allAdaptationSets.some((as) => as.assocLanguage),
-        details: 'Uses ASSOC-LANGUAGE to link related language renditions.',
-    };
-
-    results['Forced Subtitles'] = {
-        used: allAdaptationSets.some((as) => as.forced),
-        details: 'Contains subtitle renditions marked as FORCED.',
-    };
-
-    const allCharacteristics = [
-        ...new Set(allAdaptationSets.flatMap((as) => as.characteristics || [])),
-    ];
-    results['Rendition Characteristics'] = {
-        used: allCharacteristics.length > 0,
-        details:
-            allCharacteristics.length > 0
-                ? `Detected: ${allCharacteristics.join(', ')}`
-                : 'Not used.',
-    };
-
-    results['Date Ranges / Timed Metadata'] = {
-        used: manifestIR.events.some((e) => e.type === 'hls-daterange'),
-        details:
-            'Carries timed metadata, often used for ad insertion signaling.',
-    };
-
-    const hasSubtitles = mediaTags.some((m) => m.value.TYPE === 'SUBTITLES');
-    results['Subtitles & Captions'] = {
-        used: hasSubtitles,
-        details: hasSubtitles
-            ? 'Contains #EXT-X-MEDIA tags with TYPE=SUBTITLES.'
-            : 'No subtitle renditions declared.',
-    };
-
-    results['Session Data'] = {
-        used: tags.some((t) => t.name === 'EXT-X-SESSION-DATA'),
-        details: 'Carries arbitrary session data in the multivariant playlist.',
-    };
-    results['Session Keys'] = {
-        used: tags.some((t) => t.name === 'EXT-X-SESSION-KEY'),
-        details:
-            'Allows pre-loading of encryption keys from the multivariant playlist.',
-    };
-    results['Independent Segments'] = {
-        used: tags.some((t) => t.name === 'EXT-X-INDEPENDENT-SEGMENTS'),
-        details: 'All segments are self-contained for decoding.',
-    };
-    results['Start Offset'] = {
-        used: tags.some((t) => t.name === 'EXT-X-START'),
-        details: 'Specifies a preferred starting position in the playlist.',
-    };
-
-    // --- Low-Latency HLS Feature Check ---
-    const llhlsTags = [];
-    if (manifestIR.partInf) llhlsTags.push('EXT-X-PART-INF');
-    if ((manifestIR.segments || []).some((s) => (s.parts || []).length > 0))
-        llhlsTags.push('EXT-X-PART');
-    if (manifestIR.serverControl) llhlsTags.push('EXT-X-SERVER-CONTROL');
-    if ((manifestIR.preloadHints || []).length > 0)
-        llhlsTags.push('EXT-X-PRELOAD-HINT');
-    if ((manifestIR.renditionReports || []).length > 0)
-        llhlsTags.push('EXT-X-RENDITION-REPORT');
-
-    results['Low-Latency HLS'] = {
-        used: llhlsTags.length > 0,
-        details:
-            llhlsTags.length > 0
-                ? `Detected low-latency tags: <b>${llhlsTags.join(', ')}</b>`
-                : 'Standard latency HLS.',
-    };
-
-    const hasSkip = tags.some((t) => t.name === 'EXT-X-SKIP');
-    results['Playlist Delta Updates'] = {
-        used: hasSkip,
-        details: hasSkip
-            ? 'Contains #EXT-X-SKIP tag, indicating a partial playlist update.'
-            : 'No delta updates detected.',
-    };
-
-    const hasDefine = tags.some((t) => t.name === 'EXT-X-DEFINE');
-    results['Variable Substitution'] = {
-        used: hasDefine,
-        details: hasDefine
-            ? 'Uses #EXT-X-DEFINE for variable substitution.'
-            : 'No variables defined.',
-    };
-
-    const hasSteering = tags.some((t) => t.name === 'EXT-X-CONTENT-STEERING');
-    results['Content Steering'] = {
-        used: hasSteering,
-        details: hasSteering
-            ? 'Provides client-side CDN steering information.'
-            : 'No content steering information found.',
-    };
-
-    const videoRangeValues = new Set(
-        manifestIR.periods
-            .flatMap((p) => p.adaptationSets)
-            .flatMap((as) => as.representations)
-            .map((r) => r.videoRange)
-            .filter(Boolean)
-    );
-    results['Video Range (SDR/PQ/HLG)'] = {
-        used: videoRangeValues.size > 0,
-        details:
-            videoRangeValues.size > 0
-                ? `Detected: ${Array.from(videoRangeValues).join(', ')}`
-                : 'Not specified.',
-    };
-
-    const hasGeneralizedInstreamId = (manifestIR.periods || [])
-        .flatMap((p) => p.adaptationSets)
-        .some(
-            (as) =>
-                as.serializedManifest['INSTREAM-ID'] &&
-                /** @type {any} */ (as.serializedManifest).TYPE !==
-                    'CLOSED-CAPTIONS'
-        );
-    results['Generalized INSTREAM-ID'] = {
-        used: hasGeneralizedInstreamId,
-        details: hasGeneralizedInstreamId
-            ? 'INSTREAM-ID used on non-CC media types.'
-            : 'Not used.',
-    };
-
-    const hasImmersiveVideo = (manifestIR.periods || [])
-        .flatMap((p) => p.adaptationSets)
-        .flatMap((as) => as.representations)
-        .some((r) => r.reqVideoLayout);
-    results['Immersive Video (REQ-VIDEO-LAYOUT)'] = {
-        used: hasImmersiveVideo,
-        details: hasImmersiveVideo
-            ? 'REQ-VIDEO-LAYOUT attribute found on one or more variants.'
-            : 'Not used.',
-    };
-
-    // --- Advanced Metadata Check ---
-    const advancedMetadata = [];
-    if ((manifestIR.variants || []).some((v) => v.attributes.SCORE))
-        advancedMetadata.push('SCORE');
-    if (
-        (manifestIR.variants || []).some(
-            (v) => v.attributes['STABLE-VARIANT-ID']
-        )
-    )
-        advancedMetadata.push('STABLE-VARIANT-ID');
-    if (mediaTags.some((m) => m.value['STABLE-RENDITION-ID']))
-        advancedMetadata.push('STABLE-RENDITION-ID');
-    if (
-        manifestIR.events.some(
-            (e) =>
-                e.type === 'hls-daterange' &&
-                e.message.toLowerCase().includes('interstitial')
-        )
-    )
-        advancedMetadata.push('Interstitials');
-
-    results['Advanced Metadata & Rendition Selection'] = {
-        used: advancedMetadata.length > 0,
-        details:
-            advancedMetadata.length > 0
-                ? `Detected advanced attributes: <b>${advancedMetadata.join(
-                      ', '
-                  )}</b>`
-                : 'Uses standard metadata.',
-    };
-
-    return results;
-}
diff --git a/js/infrastructure/manifest/hls/feature-definitions.js b/js/infrastructure/manifest/hls/feature-definitions.js
deleted file mode 100644
index 7c6df23..0000000
--- a/js/infrastructure/manifest/hls/feature-definitions.js
+++ /dev/null
@@ -1,236 +0,0 @@
-/**
- * @typedef {object} Feature
- * @property {string} name
- * @property {'Core Streaming' | 'Timeline & Segment Management' | 'Live & Dynamic' | 'Advanced Content' | 'Client Guidance & Optimization' | 'Accessibility & Metadata'} category
- * @property {string} desc
- * @property {string} isoRef
- * @property {number} version - The HLS protocol version where this feature was introduced.
- */
-
-/** @type {Feature[]} */
-export const hlsFeatureDefinitions = [
-    {
-        name: 'Presentation Type',
-        category: 'Core Streaming',
-        desc: 'Defines if the stream is live (`EVENT`) or on-demand (`VOD`).',
-        isoRef: 'HLS 2nd Ed: 4.4.3.5',
-        version: 1,
-    },
-    {
-        name: 'Multivariant Playlist',
-        category: 'Core Streaming',
-        desc: 'The manifest is an HLS multivariant playlist that references multiple variant streams at different bitrates.',
-        isoRef: 'HLS 2nd Ed: 4.4.6.2',
-        version: 1,
-    },
-    {
-        name: 'Discontinuity',
-        category: 'Core Streaming',
-        desc: 'The presentation contains discontinuity tags, commonly used for Server-Side Ad Insertion (SSAI).',
-        isoRef: 'HLS 2nd Ed: 4.4.4.3',
-        version: 1,
-    },
-    {
-        name: 'Content Protection',
-        category: 'Core Streaming',
-        desc: 'Indicates that the content is encrypted using AES-128 or SAMPLE-AES.',
-        isoRef: 'HLS 2nd Ed: 4.4.4.4',
-        version: 1,
-    },
-    {
-        name: 'Session Keys',
-        category: 'Core Streaming',
-        desc: 'Allows encryption keys to be specified in the Multivariant Playlist via #EXT-X-SESSION-KEY, enabling clients to preload keys for faster startup.',
-        isoRef: 'HLS 2nd Ed: 4.4.6.5',
-        version: 1,
-    },
-    {
-        name: 'Fragmented MP4 Segments',
-        category: 'Core Streaming',
-        desc: 'Content is structured using fMP4 segments instead of MPEG-2 Transport Stream (TS), indicated by #EXT-X-MAP.',
-        isoRef: 'HLS 2nd Ed: 4.4.4.5',
-        version: 5,
-    },
-    {
-        name: 'Byte-Range Segments',
-        category: 'Timeline & Segment Management',
-        desc: 'Media Segments are defined as sub-ranges of a larger resource using the #EXT-X-BYTERANGE tag.',
-        isoRef: 'HLS 2nd Ed: 4.4.4.2',
-        version: 4,
-    },
-    {
-        name: 'Discontinuity Sequence',
-        category: 'Timeline & Segment Management',
-        desc: 'Uses #EXT-X-DISCONTINUITY-SEQUENCE to allow synchronization between different renditions of the same variant stream.',
-        isoRef: 'HLS 2nd Ed: 4.4.3.3',
-        version: 1,
-    },
-    {
-        name: 'Gap Segments',
-        category: 'Core Streaming',
-        desc: 'Uses EXT-X-GAP to signal the absence of media data, for example during a temporary encoder outage.',
-        isoRef: 'HLS 2nd Ed: 4.4.4.7',
-        version: 8,
-    },
-    {
-        name: 'Independent Segments',
-        category: 'Timeline & Segment Management',
-        desc: 'The playlist uses #EXT-X-INDEPENDENT-SEGMENTS, indicating that all media samples in a segment can be decoded without information from other segments.',
-        isoRef: 'HLS 2nd Ed: 4.4.2.1',
-        version: 1,
-    },
-    {
-        name: 'Date Ranges / Timed Metadata',
-        category: 'Live & Dynamic',
-        desc: 'The manifest includes timed metadata via #EXT-X-DATERANGE, typically used for ad insertion signaling (SCTE-35).',
-        isoRef: 'HLS 2nd Ed: 4.4.5.1',
-        version: 1,
-    },
-    {
-        name: 'Low-Latency HLS',
-        category: 'Live & Dynamic',
-        desc: 'Uses modern HLS features for reduced latency, such as Partial Segments (EXT-X-PART), Preload Hinting (EXT-X-PRELOAD-HINT), and Server Control.',
-        isoRef: 'HLS 2nd Ed: Appendices A, B, C',
-        version: 9,
-    },
-    {
-        name: 'Playlist Delta Updates',
-        category: 'Live & Dynamic',
-        desc: 'The server can provide partial playlist updates using the #EXT-X-SKIP tag, reducing download size for live streams.',
-        isoRef: 'HLS 2nd Ed: 4.4.5.2, 6.2.5.1',
-        version: 9,
-    },
-    {
-        name: 'Variable Substitution',
-        category: 'Live & Dynamic',
-        desc: 'Uses #EXT-X-DEFINE to create playlist variables, allowing for dynamic generation of URIs and attributes.',
-        isoRef: 'HLS 2nd Ed: 4.4.2.3',
-        version: 8,
-    },
-    {
-        name: 'Content Steering',
-        category: 'Live & Dynamic',
-        desc: 'Provides a mechanism for servers to steer clients to alternate servers for redundancy and load balancing.',
-        isoRef: 'HLS 2nd Ed: 4.4.6.6',
-        version: 11,
-    },
-    {
-        name: 'I-Frame Playlists',
-        category: 'Advanced Content',
-        desc: 'Provides special, I-Frame only playlists to enable efficient fast-forward and rewind.',
-        isoRef: 'HLS 2nd Ed: 4.4.6.3',
-        version: 4,
-    },
-    {
-        name: 'Advanced Metadata & Rendition Selection',
-        category: 'Advanced Content',
-        desc: 'Utilizes advanced attributes (e.g., SCORE, STABLE-VARIANT-ID) and semantic tags (e.g., Interstitials) to provide richer context for client ABR and UI logic.',
-        isoRef: 'HLS 2nd Ed: Appendices D, G',
-        version: 9,
-    },
-    {
-        name: 'Immersive Video (REQ-VIDEO-LAYOUT)',
-        category: 'Advanced Content',
-        desc: 'Specifies video projection for immersive experiences (e.g., equirectangular, Apple Immersive Video).',
-        isoRef: 'HLS 2nd Ed: 4.4.6.2',
-        version: 12,
-    },
-    {
-        name: 'Generalized INSTREAM-ID',
-        category: 'Advanced Content',
-        desc: 'Allows INSTREAM-ID to be used for all media types, not just closed captions, for identifying tracks within a segment.',
-        isoRef: 'HLS 2nd Ed: 4.4.6.1',
-        version: 13,
-    },
-    {
-        name: 'Session Data',
-        category: 'Client Guidance & Optimization',
-        desc: 'The multivariant playlist carries arbitrary session data using #EXT-X-SESSION-DATA, which can be used for things like analytics or custom configuration.',
-        isoRef: 'HLS 2nd Ed: 4.4.6.4',
-        version: 1,
-    },
-    {
-        name: 'Start Offset',
-        category: 'Client Guidance & Optimization',
-        desc: 'The playlist uses #EXT-X-START to indicate a preferred starting point, for example to start playback closer to the live edge.',
-        isoRef: 'HLS 2nd Ed: 4.4.2.2',
-        version: 1,
-    },
-    {
-        name: 'Bitrate Hinting',
-        category: 'Client Guidance & Optimization',
-        desc: 'Provides the approximate segment bit rate of media segments using the EXT-X-BITRATE tag.',
-        isoRef: 'HLS 2nd Ed: 4.4.4.8',
-        version: 8,
-    },
-    {
-        name: 'HDCP Level',
-        category: 'Client Guidance & Optimization',
-        desc: 'Advises that the Variant Stream may fail to play unless the output is protected by HDCP.',
-        isoRef: 'HLS 2nd Ed: 4.4.6.2',
-        version: 1,
-    },
-    {
-        name: 'Stable Variant/Rendition IDs',
-        category: 'Client Guidance & Optimization',
-        desc: 'Provides stable identifiers for Variant Streams and Renditions, allowing their URIs to change between playlist reloads.',
-        isoRef: 'HLS 2nd Ed: 4.4.6.1, 4.4.6.2',
-        version: 10,
-    },
-    {
-        name: 'Alternative Renditions',
-        category: 'Accessibility & Metadata',
-        desc: 'Uses #EXT-X-MEDIA to provide alternative tracks for language, commentary, or camera angles.',
-        isoRef: 'HLS 2nd Ed: 4.4.6.1',
-        version: 4,
-    },
-    {
-        name: 'Associated Language',
-        category: 'Accessibility & Metadata',
-        desc: 'The ASSOC-LANGUAGE attribute links renditions with different roles, like spoken vs. written language.',
-        isoRef: 'HLS 2nd Ed: 4.4.6.1',
-        version: 4,
-    },
-    {
-        name: 'Forced Subtitles',
-        category: 'Accessibility & Metadata',
-        desc: 'The FORCED=YES attribute on a SUBTITLES rendition indicates content considered essential to play (e.g., translating foreign dialogue).',
-        isoRef: 'HLS 2nd Ed: 4.4.6.1',
-        version: 4,
-    },
-    {
-        name: 'Rendition Characteristics',
-        category: 'Accessibility & Metadata',
-        desc: 'The CHARACTERISTICS attribute provides detailed properties of a rendition (e.g., for accessibility).',
-        isoRef: 'HLS 2nd Ed: 4.4.6.1',
-        version: 4,
-    },
-    {
-        name: 'Machine-Generated Content Flag',
-        category: 'Accessibility & Metadata',
-        desc: 'The "public.machine-generated" characteristic indicates a rendition was authored or translated programmatically.',
-        isoRef: 'HLS 2nd Ed: 4.4.6.1',
-        version: 13,
-    },
-    {
-        name: 'Subtitles & Captions',
-        category: 'Accessibility & Metadata',
-        desc: 'Provides text-based tracks for subtitles or closed captions via #EXT-X-MEDIA.',
-        isoRef: 'HLS 2nd Ed: 4.4.6.1',
-        version: 4,
-    },
-    {
-        name: 'Advanced Spatial Audio (CHANNELS)',
-        category: 'Accessibility & Metadata',
-        desc: 'Provides enhanced descriptors for spatial audio, including channel beds (BED-*) and degrees of freedom (DOF-*).',
-        isoRef: 'HLS 2nd Ed: 4.4.6.1',
-        version: 13,
-    },
-    {
-        name: 'Video Range (SDR/PQ/HLG)',
-        category: 'Accessibility & Metadata',
-        desc: 'Specifies the dynamic range of the video content using the VIDEO-RANGE attribute.',
-        isoRef: 'HLS 2nd Ed: 4.4.6.2',
-        version: 9,
-    },
-];
diff --git a/js/infrastructure/manifest/hls/index.js b/js/infrastructure/manifest/hls/index.js
deleted file mode 100644
index a843c97..0000000
--- a/js/infrastructure/manifest/hls/index.js
+++ /dev/null
@@ -1,17 +0,0 @@
-import { parseManifest as parse } from './parser.js';
-
-/**
- * Parses an HLS Manifest string and returns a structured object.
- * This is the public entry point for the HLS manifest parsing module.
- * @param {string} manifestString The raw HLS playlist.
- * @param {string} baseUrl The URL from which the playlist was fetched.
- * @returns {Promise<{manifest: import('../../../app/types.js').Manifest, definedVariables: Map<string, {value: string, source: string}>, baseUrl: string}>}
- */
-export async function parseManifest(manifestString, baseUrl) {
-    const {
-        manifest,
-        definedVariables,
-        baseUrl: finalBaseUrl,
-    } = await parse(manifestString, baseUrl);
-    return { manifest, definedVariables, baseUrl: finalBaseUrl };
-}
diff --git a/js/infrastructure/manifest/hls/parser.js b/js/infrastructure/manifest/hls/parser.js
deleted file mode 100644
index 641504e..0000000
--- a/js/infrastructure/manifest/hls/parser.js
+++ /dev/null
@@ -1,384 +0,0 @@
-import { adaptHlsToIr } from './adapter.js';
-
-/**
- * @typedef {object} HlsSegment
- * @property {number} duration
- * @property {string} title
- * @property {any[]} tags
- * @property {Record<string, string|number> | null} key
- * @property {object[]} parts
- * @property {number|null} bitrate
- * @property {boolean} gap
- * @property {string} [uri]
- * @property {string} [resolvedUrl]
- * @property {boolean} [discontinuity]
- * @property {string} [dateTime]
- * @property {string} type
- * @property {number} extinfLineNumber
- * @property {number} [uriLineNumber]
- */
-
-/**
- * Parses an attribute list string (e.g., 'BANDWIDTH=1280000,CODECS="..."')
- * into a key-value object.
- * @param {string} attrString
- * @returns {Record<string, string | number>}
- */
-function parseAttributeList(attrString) {
-    /** @type {Record<string, string | number>} */
-    const attributes = {};
-    const regex = /([A-Z0-9-]+)=("[^"]*"|[^,]+)/g;
-    let match;
-
-    while ((match = regex.exec(attrString)) !== null) {
-        const key = match[1];
-        let value = match[2];
-
-        if (value.startsWith('"') && value.endsWith('"')) {
-            value = value.substring(1, value.length - 1);
-        }
-
-        const numValue = /^-?\d+(\.\d+)?$/.test(value)
-            ? parseFloat(value)
-            : value;
-        attributes[key] = numValue;
-    }
-    return attributes;
-}
-
-/**
- * Pre-processes manifest lines to handle variable substitution.
- * @param {string[]} lines - The raw lines from the manifest.
- * @param {string} playlistUrl - The URL from which the manifest was fetched.
- * @param {Map<string, {value: string, source: string}>=} parentVariables - Variables inherited from a master playlist.
- * @returns {{substitutedLines: string[], definedVariables: Map<string, {value: string, source: string}>}} The lines after substitution and any new variables defined.
- */
-function applyVariableSubstitution(
-    lines,
-    playlistUrl,
-    parentVariables = new Map()
-) {
-    const variables = new Map(parentVariables);
-    const urlParams = new URL(playlistUrl).searchParams;
-
-    // First pass: define variables
-    lines.forEach((line) => {
-        if (line.startsWith('#EXT-X-DEFINE:')) {
-            const attrs = parseAttributeList(line.substring(14));
-            if (attrs.NAME && attrs.VALUE !== undefined) {
-                variables.set(String(attrs.NAME), {
-                    value: String(attrs.VALUE),
-                    source: 'VALUE',
-                });
-            } else if (attrs.QUERYPARAM) {
-                const paramName = String(attrs.QUERYPARAM);
-                const paramValue = urlParams.get(paramName);
-                if (paramValue !== null) {
-                    variables.set(paramName, {
-                        value: paramValue,
-                        source: `QUERYPARAM (${paramName})`,
-                    });
-                }
-            } else if (attrs.IMPORT) {
-                const importName = String(attrs.IMPORT);
-                if (parentVariables.has(importName)) {
-                    variables.set(importName, {
-                        value: parentVariables.get(importName).value,
-                        source: `IMPORT (${importName})`,
-                    });
-                }
-            }
-        }
-    });
-
-    if (variables.size === 0) {
-        return { substitutedLines: lines, definedVariables: variables };
-    }
-
-    // Second pass: substitute
-    const substitutedLines = lines.map((line) => {
-        return line.replace(/{\$[a-zA-Z0-9_-]+}/g, (match) => {
-            const varName = match.substring(2, match.length - 1);
-            return variables.has(varName)
-                ? variables.get(varName).value
-                : match;
-        });
-    });
-
-    return { substitutedLines, definedVariables: variables };
-}
-
-/**
- * Parses an HLS Manifest string and returns a structured object.
- * @param {string} manifestString The raw HLS playlist.
- * @param {string} baseUrl The URL from which the playlist was fetched.
- * @param {Map<string, {value: string, source: string}>=} parentVariables - Variables inherited from a master playlist.
- * @returns {Promise<{manifest: import('../../../app/types.js').Manifest, definedVariables: Map<string, {value: string, source: string}>, baseUrl: string}>}
- */
-export async function parseManifest(manifestString, baseUrl, parentVariables) {
-    let linesForParsing = manifestString.split(/\r?\n/);
-
-    if (!manifestString.trim().startsWith('#EXTM3U')) {
-        // Leniency: Prepend #EXTM3U if missing to allow parsing to continue.
-        // The original `manifestString` is preserved in `parsed.raw`,
-        // so the compliance rule will still correctly catch the omission.
-        const newLines = [].concat(linesForParsing);
-        newLines.unshift('#EXTM3U');
-        linesForParsing = newLines;
-    }
-
-    const { substitutedLines: lines, definedVariables } =
-        applyVariableSubstitution(linesForParsing, baseUrl, parentVariables);
-
-    const isMaster = lines.some((line) => line.startsWith('#EXT-X-STREAM-INF'));
-    const isLive = !lines.some((line) => line.startsWith('#EXT-X-ENDLIST'));
-
-    const parsed = {
-        isMaster: isMaster,
-        version: 1,
-        tags: [],
-        segments: [],
-        variants: [],
-        media: [],
-        raw: manifestString, // Use the original, unmodified manifest for compliance checks
-        baseUrl: baseUrl,
-        isLive: isLive,
-        preloadHints: [],
-        renditionReports: [],
-    };
-
-    /** @type {HlsSegment | null} */
-    let currentSegment = null;
-    let currentKey = null;
-    let currentBitrate = null;
-
-    for (let i = 1; i < lines.length; i++) {
-        const line = lines[i].trim();
-        if (!line) continue;
-
-        if (line.startsWith('#EXT')) {
-            const separatorIndex = line.indexOf(':');
-            let tagName, tagValue;
-
-            if (separatorIndex === -1) {
-                tagName = line.substring(1);
-                tagValue = null;
-            } else {
-                tagName = line.substring(1, separatorIndex);
-                tagValue = line.substring(separatorIndex + 1);
-            }
-
-            switch (tagName) {
-                case 'EXT-X-STREAM-INF': {
-                    parsed.isMaster = true;
-                    const attributes = parseAttributeList(tagValue);
-                    const uri = lines[++i].trim();
-                    parsed.variants.push({
-                        attributes,
-                        uri,
-                        resolvedUri: new URL(uri, baseUrl).href,
-                        lineNumber: i,
-                    });
-                    break;
-                }
-                case 'EXT-X-MEDIA':
-                    parsed.isMaster = true;
-                    parsed.media.push({
-                        ...parseAttributeList(tagValue),
-                        lineNumber: i,
-                    });
-                    break;
-                case 'EXT-X-I-FRAME-STREAM-INF':
-                    parsed.isMaster = true;
-                    parsed.tags.push({
-                        name: tagName,
-                        value: parseAttributeList(tagValue),
-                        lineNumber: i,
-                    });
-                    break;
-                case 'EXTINF': {
-                    const [durationStr, title] = tagValue.split(',');
-                    let duration = parseFloat(durationStr);
-                    if (isNaN(duration)) {
-                        duration = 0;
-                    }
-                    currentSegment = {
-                        duration,
-                        title: title || '',
-                        tags: [],
-                        key: currentKey,
-                        parts: [],
-                        bitrate: currentBitrate,
-                        gap: false,
-                        type: 'Media',
-                        extinfLineNumber: i,
-                    };
-                    break;
-                }
-                case 'EXT-X-GAP':
-                    if (currentSegment) {
-                        currentSegment.gap = true;
-                        currentSegment.uri = null;
-                        currentSegment.resolvedUrl = null;
-                        parsed.segments.push(currentSegment);
-                        currentSegment = null;
-                    }
-                    break;
-                case 'EXT-X-BITRATE':
-                    currentBitrate = parseInt(tagValue, 10);
-                    break;
-                case 'EXT-X-BYTERANGE':
-                    if (currentSegment)
-                        currentSegment.tags.push({
-                            name: tagName,
-                            value: tagValue,
-                            lineNumber: i,
-                        }); // Store byterange as a generic tag for now
-                    break;
-                case 'EXT-X-DISCONTINUITY':
-                    if (currentSegment) currentSegment.discontinuity = true;
-                    break;
-                case 'EXT-X-KEY': {
-                    const keyAttributes = parseAttributeList(tagValue);
-                    currentKey = keyAttributes;
-                    if (keyAttributes.METHOD === 'NONE') {
-                        currentKey = null;
-                    }
-                    parsed.tags.push({
-                        name: tagName,
-                        value: keyAttributes,
-                        lineNumber: i,
-                    });
-                    break;
-                }
-                case 'EXT-X-MAP':
-                    parsed.map = {
-                        ...parseAttributeList(tagValue),
-                        lineNumber: i,
-                    };
-                    break;
-                case 'EXT-X-PROGRAM-DATE-TIME':
-                    if (currentSegment) currentSegment.dateTime = tagValue;
-                    break;
-                case 'EXT-X-TARGETDURATION':
-                    parsed.targetDuration = parseInt(tagValue, 10);
-                    break;
-                case 'EXT-X-MEDIA-SEQUENCE':
-                    parsed.mediaSequence = parseInt(tagValue, 10);
-                    break;
-                case 'EXT-X-PLAYLIST-TYPE':
-                    parsed.playlistType = tagValue;
-                    if (tagValue === 'VOD') {
-                        parsed.isLive = false;
-                    } else if (tagValue === 'EVENT') {
-                        parsed.isLive = true;
-                    }
-                    break;
-                case 'EXT-X-ENDLIST':
-                    parsed.isLive = false;
-                    parsed.tags.push({
-                        name: tagName,
-                        value: null,
-                        lineNumber: i,
-                    });
-                    break;
-                case 'EXT-X-VERSION':
-                    parsed.version = parseInt(tagValue, 10);
-                    parsed.tags.push({
-                        name: tagName,
-                        value: parsed.version,
-                        lineNumber: i,
-                    });
-                    break;
-                // --- Low Latency HLS Tags ---
-                case 'EXT-X-PART-INF':
-                    parsed.partInf = parseAttributeList(tagValue);
-                    parsed.tags.push({
-                        name: tagName,
-                        value: parsed.partInf,
-                        lineNumber: i,
-                    });
-                    break;
-                case 'EXT-X-SERVER-CONTROL':
-                    parsed.serverControl = parseAttributeList(tagValue);
-                    parsed.tags.push({
-                        name: tagName,
-                        value: parsed.serverControl,
-                        lineNumber: i,
-                    });
-                    break;
-                case 'EXT-X-PART':
-                    if (currentSegment) {
-                        const partAttrs = parseAttributeList(tagValue);
-                        currentSegment.parts.push({
-                            ...partAttrs,
-                            resolvedUri: new URL(String(partAttrs.URI), baseUrl)
-                                .href,
-                            lineNumber: i,
-                        });
-                    }
-                    break;
-                case 'EXT-X-PRELOAD-HINT':
-                    parsed.preloadHints.push({
-                        ...parseAttributeList(tagValue),
-                        lineNumber: i,
-                    });
-                    parsed.tags.push({
-                        name: tagName,
-                        value: parsed.preloadHints.at(-1),
-                        lineNumber: i,
-                    });
-                    break;
-                case 'EXT-X-RENDITION-REPORT':
-                    parsed.renditionReports.push({
-                        ...parseAttributeList(tagValue),
-                        lineNumber: i,
-                    });
-                    parsed.tags.push({
-                        name: tagName,
-                        value: parsed.renditionReports.at(-1),
-                        lineNumber: i,
-                    });
-                    break;
-                // --- Other Modern Tags ---
-                case 'EXT-X-DEFINE': // Handled in pre-pass, but store it for inspection
-                case 'EXT-X-SKIP':
-                case 'EXT-X-CONTENT-STEERING':
-                case 'EXT-X-DATERANGE':
-                case 'EXT-X-SESSION-DATA':
-                    parsed.tags.push({
-                        name: tagName,
-                        value: parseAttributeList(tagValue),
-                        lineNumber: i,
-                    });
-                    break;
-                default:
-                    if (currentSegment) {
-                        currentSegment.tags.push({
-                            name: tagName,
-                            value: tagValue,
-                            lineNumber: i,
-                        });
-                    } else {
-                        parsed.tags.push({
-                            name: tagName,
-                            value: tagValue,
-                            lineNumber: i,
-                        });
-                    }
-                    break;
-            }
-        } else if (!line.startsWith('#')) {
-            if (currentSegment) {
-                currentSegment.uri = line;
-                currentSegment.resolvedUrl = new URL(line, baseUrl).href;
-                currentSegment.uriLineNumber = i;
-                parsed.segments.push(currentSegment);
-                currentSegment = null;
-            }
-        }
-    }
-
-    const manifest = adaptHlsToIr(parsed);
-    return { manifest, definedVariables, baseUrl };
-}
diff --git a/js/infrastructure/manifest/hls/segment-parser.js b/js/infrastructure/manifest/hls/segment-parser.js
deleted file mode 100644
index 8fcf2b6..0000000
--- a/js/infrastructure/manifest/hls/segment-parser.js
+++ /dev/null
@@ -1,54 +0,0 @@
-/**
- * Parses segment URLs from a parsed HLS media playlist object.
- * @param {object} parsedMediaPlaylist The parsed HLS media playlist data.
- * @param {number} [startTime=0] The starting time in seconds for the first segment.
- * @returns {Record<string, object[]>} A map of a single key to the segment list.
- */
-export function parseAllSegmentUrls(parsedMediaPlaylist, startTime = 0) {
-    if (!parsedMediaPlaylist || !parsedMediaPlaylist.segments) {
-        return {};
-    }
-
-    const segments = [];
-    const mediaSequence = parsedMediaPlaylist.mediaSequence || 0;
-    let currentTime = startTime;
-    const hlsTimescale = 90000; // HLS uses a 90kHz clock
-
-    // Handle initialization segment if present
-    if (parsedMediaPlaylist.map) {
-        segments.push({
-            repId: 'hls-media',
-            type: 'Init',
-            number: 0,
-            resolvedUrl: new URL(
-                parsedMediaPlaylist.map.URI,
-                parsedMediaPlaylist.baseUrl
-            ).href,
-            template: parsedMediaPlaylist.map.URI,
-            time: -1,
-            duration: 0,
-            timescale: hlsTimescale,
-        });
-    }
-
-    parsedMediaPlaylist.segments.forEach((seg, index) => {
-        segments.push({
-            repId: 'hls-media',
-            type: seg.type || 'Media',
-            number: mediaSequence + index,
-            resolvedUrl: seg.resolvedUri,
-            template: seg.uri,
-            time: Math.round(currentTime * hlsTimescale),
-            duration: Math.round(seg.duration * hlsTimescale),
-            timescale: hlsTimescale,
-            dateTime: seg.dateTime,
-            gap: seg.gap,
-        });
-        currentTime += seg.duration;
-    });
-
-    // A single media playlist is treated as one "Representation" in our model
-    return {
-        'media-playlist': segments,
-    };
-}
diff --git a/js/infrastructure/manifest/hls/summary-generator.js b/js/infrastructure/manifest/hls/summary-generator.js
deleted file mode 100644
index 24f2120..0000000
--- a/js/infrastructure/manifest/hls/summary-generator.js
+++ /dev/null
@@ -1,163 +0,0 @@
-/**
- * @typedef {import('../../../app/types.js').Manifest} Manifest
- * @typedef {import('../../../app/types.js').PeriodSummary} PeriodSummary
- */
-
-import { formatBitrate } from '../../../shared/utils/format.js';
-
-/**
- * Creates a protocol-agnostic summary view-model from an HLS manifest.
- * @param {Manifest} manifestIR - The adapted manifest IR.
- * @returns {import('../../../app/types.js').ManifestSummary}
- */
-export function generateHlsSummary(manifestIR) {
-    const { serializedManifest: rawElement } = manifestIR;
-    const isMaster = /** @type {any} */ (rawElement).isMaster;
-
-    const allAdaptationSets = manifestIR.periods.flatMap(
-        (p) => p.adaptationSets
-    );
-
-    const videoTracks = allAdaptationSets
-        .filter((as) => as.contentType === 'video')
-        .flatMap((as) =>
-            as.representations.map((rep) => ({
-                id: rep.stableVariantId || rep.id,
-                profiles: null,
-                bitrateRange: formatBitrate(rep.bandwidth),
-                resolutions: rep.width ? [`${rep.width}x${rep.height}`] : [],
-                codecs: [rep.codecs],
-                scanType: null,
-                videoRange: rep.videoRange || null,
-                roles: [],
-            }))
-        );
-
-    const audioTracks = allAdaptationSets
-        .filter((as) => as.contentType === 'audio')
-        .map((as) => ({
-            id: as.stableRenditionId || as.id,
-            lang: as.lang,
-            codecs: [],
-            channels: as.channels,
-            isDefault:
-                /** @type {any} */ (as.serializedManifest).DEFAULT === 'YES',
-            isForced: as.forced,
-            roles: [],
-        }));
-
-    const textTracks = allAdaptationSets
-        .filter(
-            (as) => as.contentType === 'text' || as.contentType === 'subtitles'
-        )
-        .map((as) => ({
-            id: as.stableRenditionId || as.id,
-            lang: as.lang,
-            codecsOrMimeTypes: [],
-            isDefault:
-                /** @type {any} */ (as.serializedManifest).DEFAULT === 'YES',
-            isForced: as.forced,
-            roles: [],
-        }));
-
-    const protectionSchemes = new Set();
-    const kids = new Set();
-    let mediaPlaylistDetails = null;
-
-    if (isMaster) {
-        const sessionKey = /** @type {any} */ (rawElement).tags.find(
-            (t) => t.name === 'EXT-X-SESSION-KEY'
-        );
-        if (sessionKey && sessionKey.value.METHOD !== 'NONE') {
-            protectionSchemes.add(sessionKey.value.METHOD);
-        }
-    } else {
-        const keyTag = /** @type {any} */ (rawElement).segments.find(
-            (s) => s.key
-        )?.key;
-        if (keyTag && keyTag.METHOD !== 'NONE') {
-            protectionSchemes.add(keyTag.METHOD);
-        }
-
-        const segmentCount = /** @type {any} */ (rawElement).segments.length;
-        const totalDuration = /** @type {any} */ (rawElement).segments.reduce(
-            (sum, seg) => sum + seg.duration,
-            0
-        );
-
-        mediaPlaylistDetails = {
-            segmentCount: segmentCount,
-            averageSegmentDuration:
-                segmentCount > 0 ? totalDuration / segmentCount : 0,
-            hasDiscontinuity: /** @type {any} */ (rawElement).segments.some(
-                (s) => s.discontinuity
-            ),
-            isIFrameOnly: /** @type {any} */ (rawElement).tags.some(
-                (t) => t.name === 'EXT-X-I-FRAMES-ONLY'
-            ),
-        };
-    }
-
-    const iFramePlaylists = /** @type {any} */ (rawElement).tags.filter(
-        (t) => t.name === 'EXT-X-I-FRAME-STREAM-INF'
-    ).length;
-
-    /** @type {import('../../../app/types.js').ManifestSummary} */
-    const summary = {
-        general: {
-            protocol: 'HLS',
-            streamType:
-                manifestIR.type === 'dynamic'
-                    ? 'Live / Dynamic'
-                    : 'VOD / Static',
-            streamTypeColor:
-                manifestIR.type === 'dynamic'
-                    ? 'text-red-400'
-                    : 'text-blue-400',
-            duration: manifestIR.duration,
-            segmentFormat: manifestIR.segmentFormat.toUpperCase(),
-            title: null,
-            locations: [],
-            segmenting: 'Segment List',
-        },
-        dash: null,
-        hls: {
-            version: /** @type {any} */ (rawElement).version,
-            targetDuration: /** @type {any} */ (rawElement).targetDuration,
-            iFramePlaylists: iFramePlaylists,
-            mediaPlaylistDetails,
-        },
-        lowLatency: {
-            isLowLatency: !!(/** @type {any} */ (rawElement).partInf),
-            partTargetDuration:
-                /** @type {any} */ (rawElement).partInf?.['PART-TARGET'] ||
-                null,
-            partHoldBack: manifestIR.serverControl?.['PART-HOLD-BACK'] || null,
-            canBlockReload:
-                manifestIR.serverControl?.['CAN-BLOCK-RELOAD'] === 'YES',
-            targetLatency: null,
-            minLatency: null,
-            maxLatency: null,
-        },
-        content: {
-            totalPeriods: 1, // HLS is conceptually a single period
-            totalVideoTracks: videoTracks.length,
-            totalAudioTracks: audioTracks.length,
-            totalTextTracks: textTracks.length,
-            mediaPlaylists: isMaster
-                ? /** @type {any} */ ((rawElement).variants || []).length
-                : 1,
-            periods: [], // HLS does not have periods, so this is empty.
-        },
-        videoTracks,
-        audioTracks,
-        textTracks,
-        security: {
-            isEncrypted: protectionSchemes.size > 0,
-            systems: Array.from(protectionSchemes),
-            kids: Array.from(kids),
-        },
-    };
-
-    return summary;
-}
diff --git a/js/infrastructure/metadata/scte35/parser.js b/js/infrastructure/metadata/scte35/parser.js
deleted file mode 100644
index 027b6db..0000000
--- a/js/infrastructure/metadata/scte35/parser.js
+++ /dev/null
@@ -1,264 +0,0 @@
-/**
- * A bit-level reader for parsing non-byte-aligned data structures.
- */
-class Bitstream {
-    constructor(data) {
-        this.data = data;
-        this.bytePosition = 0;
-        this.bitPosition = 0;
-    }
-
-    readBits(n) {
-        let result = 0;
-        for (let i = 0; i < n; i++) {
-            const byte = this.data[this.bytePosition];
-            const bit = (byte >> (7 - this.bitPosition)) & 1;
-            result = (result << 1) | bit;
-            this.bitPosition++;
-            if (this.bitPosition === 8) {
-                this.bitPosition = 0;
-                this.bytePosition++;
-            }
-        }
-        return result;
-    }
-
-    readBigBits(n) {
-        let result = 0n;
-        for (let i = 0; i < n; i++) {
-            const byte = this.data[this.bytePosition];
-            const bit = (byte >> (7 - this.bitPosition)) & 1;
-            result = (result << 1n) | BigInt(bit);
-            this.bitPosition++;
-            if (this.bitPosition === 8) {
-                this.bitPosition = 0;
-                this.bytePosition++;
-            }
-        }
-        return result;
-    }
-
-    readBytes(n) {
-        const result = this.data.subarray(
-            this.bytePosition,
-            this.bytePosition + n
-        );
-        this.bytePosition += n;
-        return result;
-    }
-
-    skipBits(n) {
-        this.bytePosition += Math.floor((this.bitPosition + n) / 8);
-        this.bitPosition = (this.bitPosition + n) % 8;
-    }
-
-    alignToByte() {
-        if (this.bitPosition !== 0) {
-            this.bitPosition = 0;
-            this.bytePosition++;
-        }
-    }
-
-    hasMoreData() {
-        return this.bytePosition < this.data.length;
-    }
-}
-
-const SPLICE_COMMAND_TYPES = {
-    0x00: 'Splice Null',
-    0x04: 'Splice Schedule',
-    0x05: 'Splice Insert',
-    0x06: 'Time Signal',
-    0x07: 'Bandwidth Reservation',
-    0xff: 'Private Command',
-};
-
-const SEGMENTATION_TYPE_IDS = {
-    0x10: 'Program Start',
-    0x11: 'Program End',
-    0x20: 'Chapter Start',
-    0x21: 'Chapter End',
-    0x30: 'Provider Advertisement Start',
-    0x31: 'Provider Advertisement End',
-    0x32: 'Distributor Advertisement Start',
-    0x33: 'Distributor Advertisement End',
-    0x34: 'Provider Placement Opportunity Start',
-    0x35: 'Provider Placement Opportunity End',
-    0x36: 'Distributor Placement Opportunity Start',
-    0x37: 'Distributor Placement Opportunity End',
-    0x50: 'Network Start',
-    0x51: 'Network End',
-};
-
-function parseSpliceTime(bs) {
-    const time_specified_flag = bs.readBits(1);
-    if (time_specified_flag) {
-        bs.skipBits(6); // reserved
-        return {
-            time_specified: true,
-            pts_time: Number(bs.readBigBits(33)),
-        };
-    } else {
-        bs.skipBits(7); // reserved
-        return { time_specified: false };
-    }
-}
-
-function parseBreakDuration(bs) {
-    const auto_return = bs.readBits(1);
-    bs.skipBits(6); // reserved
-    return {
-        auto_return: auto_return === 1,
-        duration: Number(bs.readBigBits(33)),
-    };
-}
-
-function parseSpliceInsert(bs) {
-    const command = {};
-    command.type = 'Splice Insert';
-    command.splice_event_id = bs.readBits(32);
-    command.splice_event_cancel_indicator = bs.readBits(1);
-    bs.skipBits(7); // reserved
-
-    if (!command.splice_event_cancel_indicator) {
-        command.out_of_network_indicator = bs.readBits(1);
-        command.program_splice_flag = bs.readBits(1);
-        command.duration_flag = bs.readBits(1);
-        command.splice_immediate_flag = bs.readBits(1);
-        bs.skipBits(4); // reserved
-
-        if (command.program_splice_flag && !command.splice_immediate_flag) {
-            command.splice_time = parseSpliceTime(bs);
-        }
-        if (command.duration_flag) {
-            command.break_duration = parseBreakDuration(bs);
-        }
-        command.unique_program_id = bs.readBits(16);
-        command.avail_num = bs.readBits(8);
-        command.avails_expected = bs.readBits(8);
-    }
-    return command;
-}
-
-function parseTimeSignal(bs) {
-    return {
-        type: 'Time Signal',
-        splice_time: parseSpliceTime(bs),
-    };
-}
-
-function parseSegmentationDescriptor(bs, length) {
-    const descriptor = {};
-    const startPos = bs.bytePosition;
-
-    descriptor.segmentation_event_id = bs.readBits(32);
-    descriptor.segmentation_event_cancel_indicator = bs.readBits(1);
-    bs.skipBits(7); // reserved
-
-    if (!descriptor.segmentation_event_cancel_indicator) {
-        descriptor.program_segmentation_flag = bs.readBits(1);
-        descriptor.segmentation_duration_flag = bs.readBits(1);
-        descriptor.delivery_not_restricted_flag = bs.readBits(1);
-        bs.skipBits(5); // reserved
-
-        if (descriptor.segmentation_duration_flag) {
-            descriptor.segmentation_duration = Number(bs.readBigBits(40));
-        }
-
-        descriptor.segmentation_upid_type = bs.readBits(8);
-        const upidLength = bs.readBits(8);
-        if (upidLength > 0) {
-            descriptor.segmentation_upid = new TextDecoder().decode(
-                bs.readBytes(upidLength)
-            );
-        }
-        const typeId = bs.readBits(8);
-        descriptor.segmentation_type_id =
-            SEGMENTATION_TYPE_IDS[typeId] || `Unknown (${typeId})`;
-        descriptor.segment_num = bs.readBits(8);
-        descriptor.segments_expected = bs.readBits(8);
-    }
-    // Skip any remaining bytes in the descriptor
-    const bytesRead = bs.bytePosition - startPos;
-    if (length > bytesRead) {
-        bs.skipBits((length - bytesRead) * 8);
-    }
-
-    return descriptor;
-}
-
-function parseSpliceInfoSection(bs) {
-    const section = {};
-    section.table_id = bs.readBits(8);
-    if (section.table_id !== 0xfc)
-        return { error: 'Invalid table_id for SCTE-35 message' };
-
-    section.section_syntax_indicator = bs.readBits(1);
-    section.private_indicator = bs.readBits(1);
-    bs.skipBits(2); // reserved
-    const section_length = bs.readBits(12);
-    const endOfSection = bs.bytePosition + section_length;
-
-    section.protocol_version = bs.readBits(8);
-    section.encrypted_packet = bs.readBits(1);
-    section.encryption_algorithm = bs.readBits(6);
-    section.pts_adjustment = Number(bs.readBigBits(33));
-    section.cw_index = bs.readBits(8);
-    section.tier = bs.readBits(12);
-
-    const splice_command_length = bs.readBits(12);
-    const splice_command_type = bs.readBits(8);
-    section.splice_command_type =
-        SPLICE_COMMAND_TYPES[splice_command_type] ||
-        `Unknown (${splice_command_type})`;
-
-    switch (splice_command_type) {
-        case 0x05:
-            section.splice_command = parseSpliceInsert(bs);
-            break;
-        case 0x06:
-            section.splice_command = parseTimeSignal(bs);
-            break;
-        default:
-            bs.skipBits(splice_command_length * 8);
-            section.splice_command = { type: 'Unsupported' };
-            break;
-    }
-
-    const descriptor_loop_length = bs.readBits(16);
-    let descriptorsBytesRead = 0;
-    section.descriptors = [];
-    while (descriptorsBytesRead < descriptor_loop_length) {
-        const tag = bs.readBits(8);
-        const length = bs.readBits(8);
-        if (tag === 0x02) {
-            // segmentation_descriptor
-            section.descriptors.push(parseSegmentationDescriptor(bs, length));
-        } else {
-            bs.skipBits(length * 8); // Skip unknown descriptors
-        }
-        descriptorsBytesRead += 2 + length;
-    }
-
-    bs.alignToByte();
-    // Move to end of section, skipping potential E_CRC_32 and stuffing
-    bs.bytePosition = endOfSection - 4;
-    section.crc_32 = bs.readBits(32);
-
-    return section;
-}
-
-/**
- * Parses a binary SCTE-35 splice_info_section.
- * @param {Uint8Array} data The binary data of the SCTE-35 message.
- * @returns {object} The parsed SCTE-35 structure.
- */
-export function parseScte35(data) {
-    try {
-        const bitstream = new Bitstream(data);
-        return parseSpliceInfoSection(bitstream);
-    } catch (e) {
-        console.error('SCTE-35 parsing error:', e);
-        return { error: e.message };
-    }
-}
diff --git a/js/infrastructure/segment/isobmff/index.js b/js/infrastructure/segment/isobmff/index.js
deleted file mode 100644
index 67adc79..0000000
--- a/js/infrastructure/segment/isobmff/index.js
+++ /dev/null
@@ -1,203 +0,0 @@
-import { parseFtypStyp, ftypStypTooltip } from './parsers/ftyp.js';
-import { parseMvhd, mvhdTooltip } from './parsers/mvhd.js';
-import { parseMfhd, mfhdTooltip } from './parsers/mfhd.js';
-import { parseTfhd, tfhdTooltip } from './parsers/tfhd.js';
-import { parseTfdt, tfdtTooltip } from './parsers/tfdt.js';
-import { parseTrun, trunTooltip } from './parsers/trun.js';
-import { parseSidx, sidxTooltip } from './parsers/sidx.js';
-import { parseTkhd, tkhdTooltip } from './parsers/tkhd.js';
-import { parseMdhd, mdhdTooltip } from './parsers/mdhd.js';
-import { parseHdlr, hdlrTooltip } from './parsers/hdlr.js';
-import { parseVmhd, vmhdTooltip } from './parsers/vmhd.js';
-import { parseStsd, stsdTooltip } from './parsers/stsd.js';
-import { parseStts, sttsTooltip } from './parsers/stts.js';
-import { parseStsc, stscTooltip } from './parsers/stsc.js';
-import { parseStsz, stszTooltip } from './parsers/stsz.js';
-import { parseStco, stcoTooltip } from './parsers/stco.js';
-import { parseElst, elstTooltip } from './parsers/elst.js';
-import { parseTrex, trexTooltip } from './parsers/trex.js';
-import { groupTooltipData } from './parsers/groups/default.js';
-import { parseAvcc, avccTooltip } from './parsers/avcc.js';
-import { parseEsds, esdsTooltip } from './parsers/esds.js';
-import { parseSmhd, smhdTooltip } from './parsers/smhd.js';
-import { parsePssh, psshTooltip } from './parsers/pssh.js';
-import { parseCtts, cttsTooltip } from './parsers/ctts.js';
-import { parseStz2, stz2Tooltip } from './parsers/stz2.js';
-import { parseSbgp, sbgpTooltip } from './parsers/sbgp.js';
-import { parseTref, trefTypeParsers, trefTooltip } from './parsers/tref.js';
-import { parseSubs, subsTooltip } from './parsers/subs.js';
-import { parseSaiz, saizTooltip } from './parsers/saiz.js';
-import { parseSaio, saioTooltip } from './parsers/saio.js';
-import { parseSinf, sinfTooltip } from './parsers/sinf.js';
-import { parseFrma, frmaTooltip } from './parsers/frma.js';
-import { parseSchm, schmTooltip } from './parsers/schm.js';
-import { parseSchi, schiTooltip } from './parsers/schi.js';
-import { parseStss, stssTooltip } from './parsers/stss.js';
-import { parseSgpd, sgpdTooltip } from './parsers/sgpd.js';
-import { parseMehd, mehdTooltip } from './parsers/mehd.js';
-import { parseSdtp, sdtpTooltip } from './parsers/sdtp.js';
-import { parseMfra, mfraTooltip } from './parsers/mfra.js';
-import { parseTfra, tfraTooltip } from './parsers/tfra.js';
-import { parseMfro, mfroTooltip } from './parsers/mfro.js';
-import { parsePdin, pdinTooltip } from './parsers/pdin.js';
-import { parseCprt, cprtTooltip } from './parsers/cprt.js';
-import { parseCslg, cslgTooltip } from './parsers/cslg.js';
-import { parseStdp, stdpTooltip } from './parsers/stdp.js';
-import { parseUrl, parseUrn, drefTooltip } from './parsers/dref.js';
-import { parseAvc1, avc1Tooltip } from './parsers/avc1.js';
-import { parseMp4a, mp4aTooltip } from './parsers/mp4a.js';
-import { parseBtrt, btrtTooltip } from './parsers/btrt.js';
-import { parseFree, freeTooltip } from './parsers/free.js';
-import { parseIods, iodsTooltip } from './parsers/iods.js';
-import { parseTrep, trepTooltip } from './parsers/trep.js';
-import { parsePasp, paspTooltip } from './parsers/pasp.js';
-import { parseColr, colrTooltip } from './parsers/colr.js';
-import { parseMeta, metaTooltip } from './parsers/meta.js';
-import { parseEncv, encvTooltip } from './parsers/encv.js';
-import { parseSenc, sencTooltip } from './parsers/senc.js';
-import { parseEnca, encaTooltip } from './parsers/enca.js';
-import { parseTenc, tencTooltip } from './parsers/tenc.js';
-import { parseId32, id32Tooltip } from './parsers/id32.js';
-import { parseEmsg, emsgTooltip } from './parsers/emsg.js';
-import { stppParsers, stppTooltip } from './parsers/stpp.js';
-
-export const boxParsers = {
-    ftyp: parseFtypStyp,
-    styp: parseFtypStyp,
-    mvhd: parseMvhd,
-    mfhd: parseMfhd,
-    tfhd: parseTfhd,
-    tfdt: parseTfdt,
-    trun: parseTrun,
-    sidx: parseSidx,
-    tkhd: parseTkhd,
-    mdhd: parseMdhd,
-    hdlr: parseHdlr,
-    vmhd: parseVmhd,
-    smhd: parseSmhd,
-    stsd: parseStsd,
-    stts: parseStts,
-    ctts: parseCtts,
-    stsc: parseStsc,
-    stsz: parseStsz,
-    stz2: parseStz2,
-    stco: parseStco,
-    elst: parseElst,
-    trex: parseTrex,
-    pssh: parsePssh,
-    avcC: parseAvcc,
-    avc1: parseAvc1,
-    mp4a: parseMp4a,
-    esds: parseEsds,
-    btrt: parseBtrt,
-    sbgp: parseSbgp,
-    tref: parseTref,
-    ...trefTypeParsers,
-    subs: parseSubs,
-    saiz: parseSaiz,
-    saio: parseSaio,
-    sinf: parseSinf,
-    frma: parseFrma,
-    schm: parseSchm,
-    schi: parseSchi,
-    stss: parseStss,
-    sgpd: parseSgpd,
-    mehd: parseMehd,
-    sdtp: parseSdtp,
-    mfra: parseMfra,
-    tfra: parseTfra,
-    mfro: parseMfro,
-    pdin: parsePdin,
-    cprt: parseCprt,
-    cslg: parseCslg,
-    stdp: parseStdp,
-    'url ': parseUrl,
-    'urn ': parseUrn,
-    free: parseFree,
-    skip: parseFree,
-    iods: parseIods,
-    trep: parseTrep,
-    pasp: parsePasp,
-    colr: parseColr,
-    meta: parseMeta,
-    encv: parseEncv,
-    senc: parseSenc,
-    enca: parseEnca,
-    tenc: parseTenc,
-    ID32: parseId32,
-    emsg: parseEmsg,
-    ...stppParsers,
-};
-
-const tooltipData = {
-    ...groupTooltipData,
-    ...ftypStypTooltip,
-    ...elstTooltip,
-    ...hdlrTooltip,
-    ...mvhdTooltip,
-    ...mfhdTooltip,
-    ...mehdTooltip,
-    ...tfhdTooltip,
-    ...tfdtTooltip,
-    ...trunTooltip,
-    ...sidxTooltip,
-    ...tkhdTooltip,
-    ...mdhdTooltip,
-    ...vmhdTooltip,
-    ...smhdTooltip,
-    ...stsdTooltip,
-    ...sttsTooltip,
-    ...cttsTooltip,
-    ...stscTooltip,
-    ...stszTooltip,
-    ...stz2Tooltip,
-    ...stcoTooltip,
-    ...stssTooltip,
-    ...sgpdTooltip,
-    ...trexTooltip,
-    ...psshTooltip,
-    ...avccTooltip,
-    ...avc1Tooltip,
-    ...mp4aTooltip,
-    ...esdsTooltip,
-    ...btrtTooltip,
-    ...sbgpTooltip,
-    ...trefTooltip,
-    ...subsTooltip,
-    ...saizTooltip,
-    ...saioTooltip,
-    ...sinfTooltip,
-    ...frmaTooltip,
-    ...schmTooltip,
-    ...schiTooltip,
-    ...sdtpTooltip,
-    ...mfraTooltip,
-    ...tfraTooltip,
-    ...mfroTooltip,
-    ...pdinTooltip,
-    ...cprtTooltip,
-    ...cslgTooltip,
-    ...stdpTooltip,
-    ...drefTooltip,
-    ...freeTooltip,
-    ...iodsTooltip,
-    ...trepTooltip,
-    ...paspTooltip,
-    ...colrTooltip,
-    ...metaTooltip,
-    ...encvTooltip,
-    ...sencTooltip,
-    ...encaTooltip,
-    ...tencTooltip,
-    ...id32Tooltip,
-    ...emsgTooltip,
-    ...stppTooltip,
-};
-
-/**
- * Retrieves the tooltip data for all implemented ISOBMFF elements.
- * @returns {object}
- */
-export function getTooltipData() {
-    return tooltipData;
-}
diff --git a/js/infrastructure/segment/isobmff/parser.js b/js/infrastructure/segment/isobmff/parser.js
deleted file mode 100644
index f897e35..0000000
--- a/js/infrastructure/segment/isobmff/parser.js
+++ /dev/null
@@ -1,221 +0,0 @@
-import { boxParsers } from './index.js';
-
-/**
- * @typedef {object} Box
- * @property {string} type
- * @property {number} size
- * @property {number} offset
- * @property {number} contentOffset
- * @property {number} headerSize
- * @property {Record<string, {value: any, offset: number, length: number}>} details
- * @property {Box[]} children
- * @property {object[]=} samples
- * @property {{type: 'error' | 'warn', message: string}[]=} issues
- * @property {boolean=} isChunk - Dynamically added property for view model
- * @property {object=} color - Dynamically added property for view model
- */
-
-const knownContainerBoxes = new Set([
-    'moof',
-    'traf',
-    'moov',
-    'trak',
-    'mdia',
-    'minf',
-    'dinf',
-    'dref',
-    'stbl',
-    'mvex',
-    'edts',
-    'avc1',
-    'mp4a',
-    'stsd',
-    'sinf',
-    'schi',
-    'mfra',
-    'tref',
-    'udta',
-    'encv',
-    'meta',
-    'trep',
-    'enca',
-]);
-
-/**
- * @param {ArrayBuffer} buffer
- * @param {number} baseOffset
- * @returns {{boxes: Box[], issues: {type: 'error' | 'warn', message: string}[], events: object[]}}
- */
-export function parseISOBMFF(buffer, baseOffset = 0) {
-    const result = {
-        boxes: [],
-        issues: [],
-        events: [],
-    };
-    const dataView = new DataView(buffer);
-    let offset = 0;
-
-    while (offset < dataView.byteLength) {
-        if (offset + 8 > dataView.byteLength) {
-            const remaining = dataView.byteLength - offset;
-            if (remaining > 0) {
-                result.issues.push({
-                    type: 'warn',
-                    message: `Trailing ${remaining} bytes at offset ${
-                        baseOffset + offset
-                    } could not be parsed as a box.`,
-                });
-            }
-            break;
-        }
-
-        let size = dataView.getUint32(offset);
-        const type = String.fromCharCode(
-            dataView.getUint8(offset + 4),
-            dataView.getUint8(offset + 5),
-            dataView.getUint8(offset + 6),
-            dataView.getUint8(offset + 7)
-        );
-
-        let headerSize = 8;
-        if (size === 1) {
-            if (offset + 16 > dataView.byteLength) {
-                result.issues.push({
-                    type: 'error',
-                    message: `Incomplete largesize box header for type '${type}' at offset ${
-                        baseOffset + offset
-                    }. Requires 16 bytes, found ${
-                        dataView.byteLength - offset
-                    }.`,
-                });
-                break;
-            }
-            size = Number(dataView.getBigUint64(offset + 8));
-            headerSize = 16;
-        } else if (size === 0) {
-            size = dataView.byteLength - offset;
-        }
-
-        if (size < headerSize || offset + size > dataView.byteLength) {
-            result.issues.push({
-                type: 'error',
-                message: `Invalid size ${size} for box '${type}' at offset ${
-                    baseOffset + offset
-                }. Box claims to extend beyond buffer limits.`,
-            });
-            break;
-        }
-
-        /** @type {Box} */
-        const box = {
-            type,
-            size,
-            offset: baseOffset + offset,
-            contentOffset: baseOffset + offset + headerSize,
-            headerSize,
-            children: [],
-            details: {},
-            issues: [],
-        };
-
-        box.details['size'] = {
-            value: `${size} bytes`,
-            offset: box.offset,
-            length: headerSize > 8 ? 8 : 4,
-        };
-        box.details['type'] = {
-            value: type,
-            offset: box.offset + 4,
-            length: 4,
-        };
-
-        const boxDataView = new DataView(buffer, offset, size);
-        parseBoxDetails(box, boxDataView);
-
-        if (type === 'emsg') {
-            result.events.push(box);
-        }
-
-        if (knownContainerBoxes.has(type) && size > headerSize) {
-            let childrenStart = headerSize;
-            let childrenBase = box.contentOffset;
-
-            // Handle special container box cases that have fields before their children
-            if (
-                type === 'avc1' ||
-                type === 'mp4a' ||
-                type === 'encv' ||
-                type === 'enca'
-            ) {
-                const sampleEntryHeaderSize =
-                    type === 'avc1' || type === 'encv' ? 78 : 28;
-                childrenStart += sampleEntryHeaderSize;
-                childrenBase += sampleEntryHeaderSize;
-            } else if (type === 'stsd' || type === 'dref' || type === 'trep') {
-                childrenStart += 8; // version, flags, and entry_count/track_id
-                childrenBase += 8;
-            } else if (type === 'meta') {
-                childrenStart += 4; // version, flags
-                childrenBase += 4;
-            }
-
-            if (size > childrenStart) {
-                const childrenBuffer = buffer.slice(
-                    offset + childrenStart,
-                    offset + size
-                );
-                if (childrenBuffer.byteLength > 0) {
-                    const childResult = parseISOBMFF(
-                        childrenBuffer,
-                        childrenBase
-                    );
-                    box.children = childResult.boxes;
-                    if (childResult.events.length > 0) {
-                        result.events.push(...childResult.events);
-                    }
-                    if (childResult.issues.length > 0) {
-                        box.issues.push(...childResult.issues);
-                    }
-                }
-            }
-        }
-
-        if (type !== 'emsg') {
-            result.boxes.push(box);
-        }
-        offset += size;
-    }
-    return result;
-}
-
-/**
- * @param {Box} box
- * @param {DataView} view
- */
-function parseBoxDetails(box, view) {
-    try {
-        const parser = boxParsers[box.type];
-        if (parser) {
-            parser(box, view);
-        } else if (box.type === 'mdat') {
-            box.details['info'] = {
-                value: 'Contains raw media data for samples.',
-                offset: box.contentOffset,
-                length: box.size - box.headerSize,
-            };
-        } else if (!knownContainerBoxes.has(box.type)) {
-            box.issues = box.issues || [];
-            box.issues.push({
-                type: 'warn',
-                message: `No parser implemented for box type '${box.type}'. Box content not parsed.`,
-            });
-        }
-    } catch (e) {
-        box.issues = box.issues || [];
-        box.issues.push({
-            type: 'error',
-            message: `Unhandled parser exception: ${e.message}`,
-        });
-        console.error(`Error parsing ISOBMFF box "${box.type}":`, e);
-    }
-}
diff --git a/js/infrastructure/segment/isobmff/parsers/avc1.js b/js/infrastructure/segment/isobmff/parsers/avc1.js
deleted file mode 100644
index 4a95fde..0000000
--- a/js/infrastructure/segment/isobmff/parsers/avc1.js
+++ /dev/null
@@ -1,105 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'avc1' (AVC Sample Entry) box, which is a type of VisualSampleEntry.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseAvc1(box, view) {
-    const p = new BoxParser(box, view);
-
-    // From SampleEntry
-    p.skip(6, 'reserved_sample_entry');
-    p.readUint16('data_reference_index');
-
-    // From VisualSampleEntry
-    p.skip(2, 'pre_defined_1');
-    p.skip(2, 'reserved_2');
-    p.skip(12, 'pre_defined_2');
-    p.readUint16('width');
-    p.readUint16('height');
-
-    const horizresolution = p.readUint32('horizresolution_fixed_point');
-    if (horizresolution !== null) {
-        box.details['horizresolution'] = {
-            ...box.details['horizresolution_fixed_point'],
-            value: (horizresolution / 65536).toFixed(2) + ' dpi',
-        };
-        delete box.details['horizresolution_fixed_point'];
-    }
-
-    const vertresolution = p.readUint32('vertresolution_fixed_point');
-    if (vertresolution !== null) {
-        box.details['vertresolution'] = {
-            ...box.details['vertresolution_fixed_point'],
-            value: (vertresolution / 65536).toFixed(2) + ' dpi',
-        };
-        delete box.details['vertresolution_fixed_point'];
-    }
-
-    p.readUint32('reserved_3');
-    p.readUint16('frame_count');
-
-    const nameStartOffset = p.offset;
-    if (p.checkBounds(32)) {
-        const nameLength = p.view.getUint8(p.offset);
-        const nameBytes = new Uint8Array(
-            p.view.buffer,
-            p.view.byteOffset + p.offset + 1,
-            nameLength
-        );
-        const name = new TextDecoder().decode(nameBytes);
-        box.details['compressorname'] = {
-            value: name,
-            offset: p.box.offset + nameStartOffset,
-            length: 32,
-        };
-        p.offset += 32;
-    }
-
-    p.readUint16('depth');
-    p.readInt16('pre_defined_3');
-
-    // Child boxes (like avcC) will be parsed by the main parser.
-    // Do not call p.finalize() here.
-}
-
-export const avc1Tooltip = {
-    avc1: {
-        name: 'AVC Sample Entry',
-        text: 'Defines the coding type and initialization information for an H.264/AVC video track.',
-        ref: 'ISO/IEC 14496-12, 12.1.3',
-    },
-    'avc1@data_reference_index': {
-        text: 'Index to the Data Reference Box, indicating where the media data is stored.',
-        ref: 'ISO/IEC 14496-12, 8.5.2.2',
-    },
-    'avc1@width': {
-        text: 'The width of the video in pixels.',
-        ref: 'ISO/IEC 14496-12, 12.1.3.2',
-    },
-    'avc1@height': {
-        text: 'The height of the video in pixels.',
-        ref: 'ISO/IEC 14496-12, 12.1.3.2',
-    },
-    'avc1@horizresolution': {
-        text: 'Horizontal resolution of the image in pixels-per-inch (16.16 fixed point). Default is 72 dpi.',
-        ref: 'ISO/IEC 14496-12, 12.1.3.2',
-    },
-    'avc1@vertresolution': {
-        text: 'Vertical resolution of the image in pixels-per-inch (16.16 fixed point). Default is 72 dpi.',
-        ref: 'ISO/IEC 14496-12, 12.1.3.2',
-    },
-    'avc1@frame_count': {
-        text: 'The number of frames of compressed video stored in each sample. Typically 1.',
-        ref: 'ISO/IEC 14496-12, 12.1.3.2',
-    },
-    'avc1@compressorname': {
-        text: 'An informative name for the compressor used. A Pascal-style string within a 32-byte field.',
-        ref: 'ISO/IEC 14496-12, 12.1.3.2',
-    },
-    'avc1@depth': {
-        text: 'The color depth of the video. 0x0018 (24) is typical for color with no alpha.',
-        ref: 'ISO/IEC 14496-12, 12.1.3.2',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/avcc.js b/js/infrastructure/segment/isobmff/parsers/avcc.js
deleted file mode 100644
index 68b19d0..0000000
--- a/js/infrastructure/segment/isobmff/parsers/avcc.js
+++ /dev/null
@@ -1,123 +0,0 @@
-import { BoxParser } from '../utils.js';
-import { parseSPS } from './sps.js';
-
-/**
- * Parses the 'avcC' (AVC Configuration) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseAvcc(box, view) {
-    const p = new BoxParser(box, view);
-
-    p.readUint8('configurationVersion');
-    const profile = p.readUint8('AVCProfileIndication');
-    p.readUint8('profile_compatibility');
-    p.readUint8('AVCLevelIndication');
-
-    const lengthSizeByte = p.readUint8('length_size_byte');
-    if (lengthSizeByte !== null) {
-        delete box.details['length_size_byte'];
-        box.details['lengthSizeMinusOne'] = {
-            value: lengthSizeByte & 0x03,
-            offset: box.offset + p.offset - 1,
-            length: 0.25,
-        };
-        box.details['reserved_6_bits'] = {
-            value: (lengthSizeByte >> 2) & 0x3f,
-            offset: box.offset + p.offset - 1,
-            length: 0.75,
-        };
-    }
-
-    const spsCountByte = p.readUint8('sps_count_byte');
-    if (spsCountByte !== null) {
-        delete box.details['sps_count_byte'];
-
-        const spsCount = spsCountByte & 0x1f;
-        box.details['numOfSequenceParameterSets'] = {
-            value: spsCount,
-            offset: box.offset + p.offset - 1,
-            length: 0.625,
-        };
-        box.details['reserved_3_bits'] = {
-            value: (spsCountByte >> 5) & 0x07,
-            offset: box.offset + p.offset - 1,
-            length: 0.375,
-        };
-
-        for (let i = 0; i < spsCount; i++) {
-            const spsLength = p.readUint16(`sps_${i + 1}_length`);
-            if (spsLength === null) break;
-
-            const spsStartOffset = p.offset;
-            if (p.checkBounds(spsLength)) {
-                const spsNalUnit = new Uint8Array(
-                    p.view.buffer,
-                    p.view.byteOffset + spsStartOffset,
-                    spsLength
-                );
-                const parsedSPS = parseSPS(spsNalUnit);
-                if (parsedSPS) {
-                    box.details[`sps_${i + 1}_decoded_profile`] = {
-                        value: parsedSPS.profile_idc,
-                        offset: 0,
-                        length: 0,
-                    };
-                    box.details[`sps_${i + 1}_decoded_level`] = {
-                        value: parsedSPS.level_idc,
-                        offset: 0,
-                        length: 0,
-                    };
-                    box.details[`sps_${i + 1}_decoded_resolution`] = {
-                        value: parsedSPS.resolution,
-                        offset: 0,
-                        length: 0,
-                    };
-                }
-                p.skip(spsLength, `sps_${i + 1}_nal_unit`);
-            }
-        }
-    }
-
-    const ppsCount = p.readUint8('numOfPictureParameterSets');
-    if (ppsCount !== null) {
-        for (let i = 0; i < ppsCount; i++) {
-            const ppsLength = p.readUint16(`pps_${i + 1}_length`);
-            if (ppsLength === null) break;
-            p.skip(ppsLength, `pps_${i + 1}_nal_unit`);
-        }
-    }
-
-    if (
-        p.offset < box.size &&
-        (profile === 100 ||
-            profile === 110 ||
-            profile === 122 ||
-            profile === 144)
-    ) {
-        // Handle profile-specific extensions, skipping for now to keep focus
-        p.readRemainingBytes('profile_specific_extensions');
-    }
-
-    p.finalize();
-}
-
-export const avccTooltip = {
-    avcC: {
-        name: 'AVC Configuration',
-        text: 'Contains the decoder configuration information for an H.264/AVC video track, including SPS and PPS.',
-        ref: 'ISO/IEC 14496-15, 5.3.3.1.2',
-    },
-    'avcC@AVCProfileIndication': {
-        text: 'Specifies the profile to which the stream conforms (e.g., 66=Baseline, 77=Main, 100=High).',
-        ref: 'ISO/IEC 14496-10',
-    },
-    'avcC@AVCLevelIndication': {
-        text: 'Specifies the level to which the stream conforms.',
-        ref: 'ISO/IEC 14496-10',
-    },
-    'avcC@sps_1_decoded_resolution': {
-        text: 'The video resolution (width x height) decoded from the Sequence Parameter Set.',
-        ref: 'ISO/IEC 14496-10, 7.3.2.1.1',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/btrt.js b/js/infrastructure/segment/isobmff/parsers/btrt.js
deleted file mode 100644
index bc657dc..0000000
--- a/js/infrastructure/segment/isobmff/parsers/btrt.js
+++ /dev/null
@@ -1,34 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'btrt' (Bit Rate) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseBtrt(box, view) {
-    const p = new BoxParser(box, view);
-    p.readUint32('bufferSizeDB');
-    p.readUint32('maxBitrate');
-    p.readUint32('avgBitrate');
-    p.finalize();
-}
-
-export const btrtTooltip = {
-    btrt: {
-        name: 'Bit Rate Box',
-        text: 'Provides bitrate information for the stream, found within a Sample Entry.',
-        ref: 'ISO/IEC 14496-12, 8.5.2.2',
-    },
-    'btrt@bufferSizeDB': {
-        text: 'The size of the decoding buffer for the elementary stream in bytes.',
-        ref: 'ISO/IEC 14496-12, 8.5.2.2',
-    },
-    'btrt@maxBitrate': {
-        text: 'The maximum rate in bits/second over any one-second window.',
-        ref: 'ISO/IEC 14496-12, 8.5.2.2',
-    },
-    'btrt@avgBitrate': {
-        text: 'The average rate in bits/second over the entire presentation.',
-        ref: 'ISO/IEC 14496-12, 8.5.2.2',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/colr.js b/js/infrastructure/segment/isobmff/parsers/colr.js
deleted file mode 100644
index b38fa9c..0000000
--- a/js/infrastructure/segment/isobmff/parsers/colr.js
+++ /dev/null
@@ -1,41 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'colr' (Colour Information) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseColr(box, view) {
-    const p = new BoxParser(box, view);
-    const colourType = p.readString(4, 'colour_type');
-
-    if (colourType === 'nclx') {
-        p.readUint16('colour_primaries');
-        p.readUint16('transfer_characteristics');
-        p.readUint16('matrix_coefficients');
-        const rangeByte = p.readUint8('full_range_flag_byte');
-        if (rangeByte !== null) {
-            delete box.details['full_range_flag_byte'];
-            box.details['full_range_flag'] = {
-                value: (rangeByte >> 7) & 1,
-                offset: p.box.offset + p.offset - 1,
-                length: 0.125,
-            };
-        }
-    } else if (colourType === 'rICC' || colourType === 'prof') {
-        p.readRemainingBytes('ICC_profile');
-    }
-    p.finalize();
-}
-
-export const colrTooltip = {
-    colr: {
-        name: 'Colour Information Box',
-        text: 'Provides information about the colour representation of the video, such as primaries and transfer characteristics.',
-        ref: 'ISO/IEC 14496-12, 12.1.5',
-    },
-    'colr@colour_type': {
-        text: 'The type of color information provided (e.g., "nclx", "rICC", "prof").',
-        ref: 'ISO/IEC 14496-12, 12.1.5.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/cprt.js b/js/infrastructure/segment/isobmff/parsers/cprt.js
deleted file mode 100644
index b80a31b..0000000
--- a/js/infrastructure/segment/isobmff/parsers/cprt.js
+++ /dev/null
@@ -1,45 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'cprt' (Copyright) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseCprt(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-
-    const langBits = p.readUint16('language_bits');
-    if (langBits !== null) {
-        const langValue = String.fromCharCode(
-            ((langBits >> 10) & 0x1f) + 0x60,
-            ((langBits >> 5) & 0x1f) + 0x60,
-            (langBits & 0x1f) + 0x60
-        );
-        box.details['language'] = {
-            value: langValue,
-            offset: box.details['language_bits'].offset,
-            length: 2,
-        };
-        delete box.details['language_bits'];
-    }
-
-    p.readNullTerminatedString('notice');
-    p.finalize();
-}
-
-export const cprtTooltip = {
-    cprt: {
-        name: 'Copyright Box',
-        text: 'Contains a copyright declaration for the track or presentation.',
-        ref: 'ISO/IEC 14496-12, 8.10.2',
-    },
-    'cprt@language': {
-        text: 'The ISO-639-2/T language code for the notice text.',
-        ref: 'ISO/IEC 14496-12, 8.10.2.3',
-    },
-    'cprt@notice': {
-        text: 'The copyright notice text.',
-        ref: 'ISO/IEC 14496-12, 8.10.2.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/cslg.js b/js/infrastructure/segment/isobmff/parsers/cslg.js
deleted file mode 100644
index 0235ad8..0000000
--- a/js/infrastructure/segment/isobmff/parsers/cslg.js
+++ /dev/null
@@ -1,47 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'cslg' (Composition to Decode Box).
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseCslg(box, view) {
-    const p = new BoxParser(box, view);
-    const { version } = p.readVersionAndFlags();
-
-    if (version === null) {
-        p.finalize();
-        return;
-    }
-
-    if (version === 1) {
-        p.readBigUint64('compositionToDTSShift');
-        p.readBigUint64('leastDecodeToDisplayDelta');
-        p.readBigUint64('greatestDecodeToDisplayDelta');
-        p.readBigUint64('compositionStartTime');
-        p.readBigUint64('compositionEndTime');
-    } else {
-        p.readUint32('compositionToDTSShift');
-        p.readUint32('leastDecodeToDisplayDelta');
-        p.readUint32('greatestDecodeToDisplayDelta');
-        p.readUint32('compositionStartTime');
-        p.readUint32('compositionEndTime');
-    }
-    p.finalize();
-}
-
-export const cslgTooltip = {
-    cslg: {
-        name: 'Composition to Decode',
-        text: 'Provides a mapping from the composition timeline to the decoding timeline.',
-        ref: 'ISO/IEC 14496-12, 8.6.1.4',
-    },
-    'cslg@compositionToDTSShift': {
-        text: 'A shift value that, when added to composition times, guarantees CTS >= DTS.',
-        ref: 'ISO/IEC 14496-12, 8.6.1.4.3',
-    },
-    'cslg@leastDecodeToDisplayDelta': {
-        text: 'The smallest composition time offset found in the track.',
-        ref: 'ISO/IEC 14496-12, 8.6.1.4.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/ctts.js b/js/infrastructure/segment/isobmff/parsers/ctts.js
deleted file mode 100644
index 5ad69c6..0000000
--- a/js/infrastructure/segment/isobmff/parsers/ctts.js
+++ /dev/null
@@ -1,71 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'ctts' (Composition Time to Sample) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseCtts(box, view) {
-    const p = new BoxParser(box, view);
-    const { version } = p.readVersionAndFlags();
-
-    if (version === null) {
-        p.finalize();
-        return;
-    }
-
-    const entryCount = p.readUint32('entry_count');
-
-    if (entryCount !== null && entryCount > 0) {
-        const maxEntriesToShow = 10;
-        for (let i = 0; i < entryCount; i++) {
-            if (p.stopped) break;
-            if (i < maxEntriesToShow) {
-                const entryPrefix = `entry_${i + 1}`;
-                p.readUint32(`${entryPrefix}_sample_count`);
-                if (version === 1) {
-                    p.readInt32(`${entryPrefix}_sample_offset`);
-                } else {
-                    p.readUint32(`${entryPrefix}_sample_offset`);
-                }
-            } else {
-                p.offset += 8; // Skip 8 bytes for each remaining entry
-            }
-        }
-
-        if (entryCount > maxEntriesToShow) {
-            box.details['...more_entries'] = {
-                value: `${
-                    entryCount - maxEntriesToShow
-                } more entries not shown but parsed`,
-                offset: 0,
-                length: 0,
-            };
-        }
-    }
-    p.finalize();
-}
-
-export const cttsTooltip = {
-    ctts: {
-        name: 'Composition Time to Sample',
-        text: 'Provides the offset between decoding time and composition time for each sample. Essential for B-frames.',
-        ref: 'ISO/IEC 14496-12, 8.6.1.3',
-    },
-    'ctts@version': {
-        text: 'Version of this box (0 or 1). Version 1 allows for signed sample offsets.',
-        ref: 'ISO/IEC 14496-12, 8.6.1.3.3',
-    },
-    'ctts@entry_count': {
-        text: 'The number of entries in the composition time-to-sample table.',
-        ref: 'ISO/IEC 14496-12, 8.6.1.3.3',
-    },
-    'ctts@entry_1_sample_count': {
-        text: 'The number of consecutive samples with the same composition offset.',
-        ref: 'ISO/IEC 14496-12, 8.6.1.3.3',
-    },
-    'ctts@entry_1_sample_offset': {
-        text: 'The composition time offset for this run of samples (CT = DT + offset).',
-        ref: 'ISO/IEC 14496-12, 8.6.1.3.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/dref.js b/js/infrastructure/segment/isobmff/parsers/dref.js
deleted file mode 100644
index de11fcd..0000000
--- a/js/infrastructure/segment/isobmff/parsers/dref.js
+++ /dev/null
@@ -1,52 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses a 'url ' (Data Entry URL) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseUrl(box, view) {
-    const p = new BoxParser(box, view);
-    const { flags } = p.readVersionAndFlags();
-
-    if (flags !== null && (flags & 1) === 0) {
-        p.readNullTerminatedString('location');
-    }
-    p.finalize();
-}
-
-/**
- * Parses a 'urn ' (Data Entry URN) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseUrn(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-
-    p.readNullTerminatedString('name');
-    p.readNullTerminatedString('location');
-    p.finalize();
-}
-
-export const drefTooltip = {
-    dref: {
-        name: 'Data Reference Box',
-        text: 'A container for data references (e.g., URLs) that declare the location of media data.',
-        ref: 'ISO/IEC 14496-12, 8.7.2',
-    },
-    'url ': {
-        name: 'Data Entry URL Box',
-        text: 'An entry in the Data Reference Box containing a URL.',
-        ref: 'ISO/IEC 14496-12, 8.7.2.1',
-    },
-    'url @location': {
-        text: 'The URL where the media data is located. If the "self-contained" flag is set, this field is absent.',
-        ref: 'ISO/IEC 14496-12, 8.7.2.3',
-    },
-    'urn ': {
-        name: 'Data Entry URN Box',
-        text: 'An entry in the Data Reference Box containing a URN.',
-        ref: 'ISO/IEC 14496-12, 8.7.2.1',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/elst.js b/js/infrastructure/segment/isobmff/parsers/elst.js
deleted file mode 100644
index a6613c0..0000000
--- a/js/infrastructure/segment/isobmff/parsers/elst.js
+++ /dev/null
@@ -1,76 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseElst(box, view) {
-    const p = new BoxParser(box, view);
-    const { version } = p.readVersionAndFlags();
-
-    if (version === null) {
-        p.finalize();
-        return;
-    }
-
-    const entryCount = p.readUint32('entry_count');
-
-    if (entryCount !== null && entryCount > 0) {
-        const maxEntriesToShow = 5;
-        const entrySize = version === 1 ? 20 : 12;
-
-        for (let i = 0; i < entryCount; i++) {
-            if (p.stopped) break;
-
-            if (i < maxEntriesToShow) {
-                const entryPrefix = `entry_${i + 1}`;
-                if (version === 1) {
-                    p.readBigUint64(`${entryPrefix}_segment_duration`);
-                    p.readBigInt64(`${entryPrefix}_media_time`); // Corrected to signed
-                } else {
-                    p.readUint32(`${entryPrefix}_segment_duration`);
-                    p.readInt32(`${entryPrefix}_media_time`);
-                }
-                p.readInt16(`${entryPrefix}_media_rate_integer`);
-                p.readInt16(`${entryPrefix}_media_rate_fraction`);
-            } else {
-                p.offset += entrySize;
-            }
-        }
-
-        if (entryCount > maxEntriesToShow) {
-            box.details['...more_entries'] = {
-                value: `${
-                    entryCount - maxEntriesToShow
-                } more entries not shown but parsed`,
-                offset: 0,
-                length: 0,
-            };
-        }
-    }
-    p.finalize();
-}
-
-export const elstTooltip = {
-    elst: {
-        name: 'Edit List',
-        text: 'Maps the media time-line to the presentation time-line.',
-        ref: 'ISO/IEC 14496-12, 8.6.6',
-    },
-    'elst@version': {
-        text: 'Version of this box (0 or 1). Affects the size of duration and time fields.',
-        ref: 'ISO/IEC 14496-12, 8.6.6.3',
-    },
-    'elst@entry_count': {
-        text: 'The number of entries in the edit list.',
-        ref: 'ISO/IEC 14496-12, 8.6.6.3',
-    },
-    'elst@entry_1_segment_duration': {
-        text: 'The duration of this edit segment in movie timescale units.',
-        ref: 'ISO/IEC 14496-12, 8.6.6.3',
-    },
-    'elst@entry_1_media_time': {
-        text: 'The starting time within the media of this edit segment. A value of -1 indicates an empty edit.',
-        ref: 'ISO/IEC 14496-12, 8.6.6.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/emsg.js b/js/infrastructure/segment/isobmff/parsers/emsg.js
deleted file mode 100644
index ccc7ff4..0000000
--- a/js/infrastructure/segment/isobmff/parsers/emsg.js
+++ /dev/null
@@ -1,81 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'emsg' (Event Message) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseEmsg(box, view) {
-    const p = new BoxParser(box, view);
-    const { version } = p.readVersionAndFlags();
-
-    if (version === null) {
-        p.finalize();
-        return;
-    }
-
-    if (version === 1) {
-        p.readUint32('timescale');
-        p.readBigUint64('presentation_time');
-    } else {
-        // version 0
-        p.readUint32('timescale');
-        p.readUint32('presentation_time_delta');
-    }
-
-    p.readUint32('event_duration');
-    p.readUint32('id');
-    p.readNullTerminatedString('scheme_id_uri');
-    p.readNullTerminatedString('value');
-
-    const remainingBytes = box.size - p.offset;
-    if (remainingBytes > 0) {
-        p.skip(remainingBytes, 'message_data');
-    }
-
-    p.finalize();
-}
-
-export const emsgTooltip = {
-    emsg: {
-        name: 'Event Message Box',
-        text: 'Contains an event message for in-band signaling, such as SCTE-35 ad markers.',
-        ref: 'ISO/IEC 23009-1, Clause 5.10.3.3',
-    },
-    'emsg@version': {
-        text: 'Version of this box (0 or 1). Version 1 uses a 64-bit absolute presentation_time.',
-        ref: 'ISO/IEC 23009-1, Clause 5.10.3.3.2',
-    },
-    'emsg@presentation_time': {
-        text: '(Version 1) The absolute presentation time of the event on the media timeline, in timescale units.',
-        ref: 'ISO/IEC 23009-1, Clause 5.10.3.3.2',
-    },
-    'emsg@presentation_time_delta': {
-        text: '(Version 0) The presentation time delta of the event relative to the earliest presentation time in the segment.',
-        ref: 'ISO/IEC 23009-1, Clause 5.10.3.3.2',
-    },
-    'emsg@timescale': {
-        text: 'The timescale for this event, in ticks per second.',
-        ref: 'ISO/IEC 23009-1, Clause 5.10.3.3.2',
-    },
-    'emsg@event_duration': {
-        text: 'The duration of the event in timescale units.',
-        ref: 'ISO/IEC 23009-1, Clause 5.10.3.3.2',
-    },
-    'emsg@id': {
-        text: 'A unique identifier for this event instance.',
-        ref: 'ISO/IEC 23009-1, Clause 5.10.3.3.2',
-    },
-    'emsg@scheme_id_uri': {
-        text: 'A URI identifying the scheme of the event message (e.g., "urn:scte:scte35:2014:xml+bin").',
-        ref: 'ISO/IEC 23009-1, Clause 5.10.3.3.2',
-    },
-    'emsg@value': {
-        text: 'A value that distinguishes this event stream from others with the same scheme.',
-        ref: 'ISO/IEC 23009-1, Clause 5.10.3.3.2',
-    },
-    'emsg@message_data': {
-        text: 'The payload of the event message, with syntax defined by the scheme.',
-        ref: 'ISO/IEC 23009-1, Clause 5.10.3.3.2',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/enca.js b/js/infrastructure/segment/isobmff/parsers/enca.js
deleted file mode 100644
index 05c769d..0000000
--- a/js/infrastructure/segment/isobmff/parsers/enca.js
+++ /dev/null
@@ -1,40 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'enca' (Encrypted Audio Sample Entry) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseEnca(box, view) {
-    const p = new BoxParser(box, view);
-
-    // From SampleEntry
-    p.skip(6, 'reserved_sample_entry');
-    p.readUint16('data_reference_index');
-
-    // From AudioSampleEntry
-    p.skip(8, 'reserved_audio_entry_1');
-    p.readUint16('channelcount');
-    p.readUint16('samplesize');
-    p.skip(2, 'pre_defined');
-    p.skip(2, 'reserved_audio_entry_2');
-
-    const samplerateFixedPoint = p.readUint32('samplerate_fixed_point');
-    if (samplerateFixedPoint !== null) {
-        box.details['samplerate'] = {
-            ...box.details['samplerate_fixed_point'],
-            value: samplerateFixedPoint >> 16,
-        };
-        delete box.details['samplerate_fixed_point'];
-    }
-
-    // Child boxes (like sinf) will be parsed by the main parser.
-}
-
-export const encaTooltip = {
-    enca: {
-        name: 'Encrypted Audio Sample Entry',
-        text: 'A sample entry wrapper indicating that the audio stream is encrypted. It contains a Protection Scheme Information (`sinf`) box.',
-        ref: 'ISO/IEC 14496-12, 8.12',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/encv.js b/js/infrastructure/segment/isobmff/parsers/encv.js
deleted file mode 100644
index ccdc7a3..0000000
--- a/js/infrastructure/segment/isobmff/parsers/encv.js
+++ /dev/null
@@ -1,36 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'encv' (Encrypted Video Sample Entry) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseEncv(box, view) {
-    const p = new BoxParser(box, view);
-
-    // From SampleEntry
-    p.skip(6, 'reserved_sample_entry');
-    p.readUint16('data_reference_index');
-
-    // From VisualSampleEntry
-    p.skip(16, 'pre_defined_and_reserved');
-    p.readUint16('width');
-    p.readUint16('height');
-    p.readUint32('horizresolution');
-    p.readUint32('vertresolution');
-    p.readUint32('reserved_3');
-    p.readUint16('frame_count');
-    p.skip(32, 'compressorname');
-    p.readUint16('depth');
-    p.readInt16('pre_defined_3');
-
-    // Child boxes (sinf) will be parsed by the main parser.
-}
-
-export const encvTooltip = {
-    encv: {
-        name: 'Encrypted Video Sample Entry',
-        text: 'A sample entry wrapper indicating that the video stream is encrypted. It contains a Protection Scheme Information (`sinf`) box.',
-        ref: 'ISO/IEC 14496-12, 8.12',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/esds.js b/js/infrastructure/segment/isobmff/parsers/esds.js
deleted file mode 100644
index fbe8644..0000000
--- a/js/infrastructure/segment/isobmff/parsers/esds.js
+++ /dev/null
@@ -1,229 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-const AUDIO_OBJECT_TYPES = {
-    1: 'AAC Main',
-    2: 'AAC LC',
-    3: 'AAC SSR',
-    4: 'AAC LTP',
-    5: 'SBR',
-    6: 'AAC Scalable',
-};
-const SAMPLING_FREQUENCIES = {
-    0: '96000 Hz',
-    1: '88200 Hz',
-    2: '64000 Hz',
-    3: '48000 Hz',
-    4: '44100 Hz',
-    5: '32000 Hz',
-    6: '24000 Hz',
-    7: '22050 Hz',
-    8: '16000 Hz',
-    9: '12000 Hz',
-    10: '11025 Hz',
-    11: '8000 Hz',
-    12: '7350 Hz',
-};
-const CHANNEL_CONFIGURATIONS = [
-    'Custom',
-    'Mono (Center)',
-    'Stereo (L, R)',
-    '3 (L, C, R)',
-    '4 (L, C, R, Sur)',
-    '5 (L, C, R, Ls, Rs)',
-    '5.1 (L, C, R, Ls, Rs, LFE)',
-    '7.1 (L, C, R, Ls, Rs, Lcs, Rcs, LFE)',
-];
-
-function parseDescriptorSize(p, fieldName) {
-    const startOffset = p.offset;
-    let size = 0;
-    let byte;
-    let bytesRead = 0;
-    do {
-        byte = p.readUint8(`size_byte_${bytesRead}`);
-        if (byte === null) return null;
-        size = (size << 7) | (byte & 0x7f);
-        bytesRead++;
-    } while (byte & 0x80 && bytesRead < 4);
-
-    p.box.details[fieldName] = {
-        value: size,
-        offset: p.box.offset + startOffset,
-        length: bytesRead,
-    };
-    for (let i = 0; i < bytesRead; i++) {
-        delete p.box.details[`size_byte_${i}`];
-    }
-    return size;
-}
-
-export function parseEsds(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-
-    // --- ES_Descriptor ---
-    const esDescrTag = p.readUint8('ES_Descriptor_tag');
-    if (esDescrTag !== 0x03) {
-        p.addIssue(
-            'warn',
-            `Expected ES_Descriptor tag (0x03), but found ${esDescrTag}.`
-        );
-        p.finalize();
-        return;
-    }
-    const esDescrSize = parseDescriptorSize(p, 'ES_Descriptor_size');
-    if (esDescrSize === null) {
-        p.finalize();
-        return;
-    }
-    const esDescrEndOffset = p.offset + esDescrSize;
-
-    p.readUint16('ES_ID');
-    p.readUint8('streamDependence_and_priority');
-
-    // --- DecoderConfigDescriptor ---
-    if (p.offset < esDescrEndOffset) {
-        const decConfDescrTag = p.readUint8('DecoderConfigDescriptor_tag');
-        if (decConfDescrTag === 0x04) {
-            const decConfDescrSize = parseDescriptorSize(
-                p,
-                'DecoderConfigDescriptor_size'
-            );
-            const decConfEndOffset = p.offset + decConfDescrSize;
-
-            p.readUint8('objectTypeIndication');
-            p.readUint8('streamType_and_upStream');
-            p.skip(3, 'bufferSizeDB');
-            p.readUint32('maxBitrate');
-            p.readUint32('avgBitrate');
-
-            if (p.offset < decConfEndOffset) {
-                const decSpecificInfoTag = p.readUint8(
-                    'DecoderSpecificInfo_tag'
-                );
-                if (decSpecificInfoTag === 0x05) {
-                    const decSpecificInfoSize = parseDescriptorSize(
-                        p,
-                        'DecoderSpecificInfo_size'
-                    );
-                    if (
-                        decSpecificInfoSize !== null &&
-                        decSpecificInfoSize >= 2
-                    ) {
-                        const audioConfigStartOffset = p.offset;
-                        const bits = (
-                            p.readUint16('AudioSpecificConfig_bits') >>> 0
-                        )
-                            .toString(2)
-                            .padStart(16, '0');
-                        delete box.details['AudioSpecificConfig_bits'];
-
-                        const audioObjectType = parseInt(
-                            bits.substring(0, 5),
-                            2
-                        );
-                        const samplingFrequencyIndex = parseInt(
-                            bits.substring(5, 9),
-                            2
-                        );
-                        const channelConfiguration = parseInt(
-                            bits.substring(9, 13),
-                            2
-                        );
-
-                        box.details['decoded_audio_object_type'] = {
-                            value: `${
-                                AUDIO_OBJECT_TYPES[audioObjectType] || 'Unknown'
-                            } (${audioObjectType})`,
-                            offset: p.box.offset + audioConfigStartOffset,
-                            length: 0.625, // 5 bits
-                        };
-                        box.details['decoded_sampling_frequency'] = {
-                            value: `${
-                                SAMPLING_FREQUENCIES[samplingFrequencyIndex] ||
-                                'Unknown'
-                            } (${samplingFrequencyIndex})`,
-                            offset:
-                                p.box.offset + audioConfigStartOffset + 0.625,
-                            length: 0.5, // 4 bits
-                        };
-                        box.details['decoded_channel_configuration'] = {
-                            value: `${
-                                CHANNEL_CONFIGURATIONS[channelConfiguration] ||
-                                'Unknown'
-                            } (${channelConfiguration})`,
-                            offset:
-                                p.box.offset + audioConfigStartOffset + 1.125,
-                            length: 0.5, // 4 bits
-                        };
-
-                        p.skip(
-                            decSpecificInfoSize - 2,
-                            'decoder_specific_info_remains'
-                        );
-                    } else if (decSpecificInfoSize > 0) {
-                        p.skip(
-                            decSpecificInfoSize,
-                            'decoder_specific_info_data'
-                        );
-                    }
-                }
-            }
-        }
-    }
-
-    // --- SLConfigDescriptor ---
-    if (p.offset < esDescrEndOffset) {
-        const slConfigDescrTag = p.readUint8('SLConfigDescriptor_tag');
-        if (slConfigDescrTag === 0x06) {
-            const slConfigDescrSize = parseDescriptorSize(
-                p,
-                'SLConfigDescriptor_size'
-            );
-            if (slConfigDescrSize !== null) {
-                // For a typical size of 1, the only field is predefined.
-                if (slConfigDescrSize === 1) {
-                    p.readUint8('predefined');
-                } else {
-                    p.skip(slConfigDescrSize, 'sl_config_data');
-                }
-            }
-        }
-    }
-
-    p.finalize();
-}
-
-export const esdsTooltip = {
-    esds: {
-        name: 'Elementary Stream Descriptor',
-        text: 'Contains information about the elementary stream, such as the audio object type for AAC.',
-        ref: 'ISO/IEC 14496-1, 7.2.6.5',
-    },
-    'esds@objectTypeIndication': {
-        text: 'Specifies the audio coding profile (e.g., 64 = AAC LC, 5 = SBR). The value 0x40 corresponds to 64.',
-        ref: 'ISO/IEC 14496-1, Table 5',
-    },
-    'esds@decoded_audio_object_type': {
-        text: 'The specific type of audio coding, decoded from the DecoderSpecificInfo. This is the definitive audio profile.',
-        ref: 'ISO/IEC 14496-3, 1.5.1.1',
-    },
-    'esds@decoded_sampling_frequency': {
-        text: 'The audio sampling frequency, decoded from the DecoderSpecificInfo.',
-        ref: 'ISO/IEC 14496-3, 1.5.1.1',
-    },
-    'esds@decoded_channel_configuration': {
-        text: 'The speaker channel layout, decoded from the DecoderSpecificInfo.',
-        ref: 'ISO/IEC 14496-3, 1.5.1.1',
-    },
-    SLConfigDescriptor_tag: {
-        name: 'Sync Layer Config Descriptor Tag',
-        text: 'Tag identifying the Sync Layer (SL) Configuration Descriptor, which contains configuration for the synchronization layer.',
-        ref: 'ISO/IEC 14496-1, 7.2.6.8',
-    },
-    'SLConfigDescriptor_tag@predefined': {
-        name: 'Predefined',
-        text: 'A predefined value for the SL packet header configuration. A value of 2 indicates that SL packets have a 1-byte header.',
-        ref: 'ISO/IEC 14496-1, 7.2.6.8',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/free.js b/js/infrastructure/segment/isobmff/parsers/free.js
deleted file mode 100644
index ea569e7..0000000
--- a/js/infrastructure/segment/isobmff/parsers/free.js
+++ /dev/null
@@ -1,25 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'free' or 'skip' (Free Space) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseFree(box, view) {
-    const p = new BoxParser(box, view);
-    p.readRemainingBytes('data');
-    p.finalize();
-}
-
-export const freeTooltip = {
-    free: {
-        name: 'Free Space Box',
-        text: 'The contents of this box are irrelevant and may be ignored. It is used to reserve space.',
-        ref: 'ISO/IEC 14496-12, 8.1.2',
-    },
-    skip: {
-        name: 'Skip Box',
-        text: 'An alternative type for a free space box. The contents are irrelevant.',
-        ref: 'ISO/IEC 14496-12, 8.1.2',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/frma.js b/js/infrastructure/segment/isobmff/parsers/frma.js
deleted file mode 100644
index 84cd0ae..0000000
--- a/js/infrastructure/segment/isobmff/parsers/frma.js
+++ /dev/null
@@ -1,24 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'frma' (Original Format) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseFrma(box, view) {
-    const p = new BoxParser(box, view);
-    p.readString(4, 'data_format');
-    p.finalize();
-}
-
-export const frmaTooltip = {
-    frma: {
-        name: 'Original Format Box',
-        text: 'Stores the original, unencrypted four-character-code of the sample description.',
-        ref: 'ISO/IEC 14496-12, 8.12.2',
-    },
-    'frma@data_format': {
-        text: 'The original format of the sample entry (e.g., "avc1", "mp4a").',
-        ref: 'ISO/IEC 14496-12, 8.12.2.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/ftyp.js b/js/infrastructure/segment/isobmff/parsers/ftyp.js
deleted file mode 100644
index 3e99cca..0000000
--- a/js/infrastructure/segment/isobmff/parsers/ftyp.js
+++ /dev/null
@@ -1,88 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parser for the 'ftyp' (File Type Box) and 'styp' (Segment Type Box).
- * ISO/IEC 14496-12
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseFtypStyp(box, view) {
-    const p = new BoxParser(box, view);
-
-    p.readString(4, 'majorBrand');
-    p.readUint32('minorVersion');
-
-    const compatibleBrands = [];
-    const cmafBrands = [];
-    const compatibleBrandsOffset = p.offset;
-    while (p.offset < box.size) {
-        if (p.stopped) break;
-        const brand = p.readString(4, `brand_${compatibleBrands.length}`);
-        if (brand === null) break;
-        compatibleBrands.push(brand);
-        if (brand.startsWith('cmf')) {
-            cmafBrands.push(brand);
-        }
-        delete box.details[`brand_${compatibleBrands.length - 1}`];
-    }
-
-    if (compatibleBrands.length > 0) {
-        box.details['compatibleBrands'] = {
-            value: compatibleBrands.join(', '),
-            offset: box.offset + compatibleBrandsOffset,
-            length: p.offset - compatibleBrandsOffset,
-        };
-    }
-    if (cmafBrands.length > 0) {
-        box.details['cmafBrands'] = {
-            value: cmafBrands.join(', '),
-            offset: 0, // Not tied to a specific byte location, but derived
-            length: 0,
-        };
-    }
-    p.finalize();
-}
-
-/**
- * Tooltip metadata for 'ftyp' and 'styp'
- */
-export const ftypStypTooltip = {
-    ftyp: {
-        name: 'File Type',
-        text: 'File Type Box: declares the major brand, minor version, and compatible brands for the file.',
-        ref: 'ISO/IEC 14496-12:2022, Section 4.3',
-    },
-    'ftyp@majorBrand': {
-        text: 'The major brand of the file, indicating its primary specification.',
-        ref: 'ISO/IEC 14496-12:2022, Section 4.3',
-    },
-    'ftyp@minorVersion': {
-        text: 'The minor version of the major brand.',
-        ref: 'ISO/IEC 14496-12:2022, Section 4.3',
-    },
-    'ftyp@compatibleBrands': {
-        text: 'Other brands that the file is compatible with.',
-        ref: 'ISO/IEC 14496-12:2022, Section 4.3',
-    },
-    'ftyp@cmafBrands': {
-        text: 'A list of CMAF-specific structural or media profile brands detected in this box.',
-        ref: 'ISO/IEC 23000-19:2020(E), Clause 7.2',
-    },
-    styp: {
-        name: 'Segment Type',
-        text: "Declares the segment's brand and compatibility.",
-        ref: 'ISO/IEC 14496-12, 8.16.2',
-    },
-    'styp@majorBrand': {
-        text: "The 'best use' specification for the segment.",
-        ref: 'ISO/IEC 14496-12, 4.3.3',
-    },
-    'styp@minorVersion': {
-        text: 'An informative integer for the minor version of the major brand.',
-        ref: 'ISO/IEC 14496-12, 4.3.3',
-    },
-    'styp@compatibleBrands': {
-        text: 'A list of other specifications to which the segment complies.',
-        ref: 'ISO/IEC 14496-12, 4.3.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/groups/default.js b/js/infrastructure/segment/isobmff/parsers/groups/default.js
deleted file mode 100644
index d0acc8a..0000000
--- a/js/infrastructure/segment/isobmff/parsers/groups/default.js
+++ /dev/null
@@ -1,75 +0,0 @@
-export const groupTooltipData = {
-    moov: {
-        name: 'Movie',
-        text: 'Container for all metadata defining the presentation.',
-        ref: 'ISO/IEC 14496-12, 8.2.1',
-    },
-
-    trak: {
-        name: 'Track',
-        text: 'Container for a single track.',
-        ref: 'ISO/IEC 14496-12, 8.3.1',
-    },
-
-    meta: {
-        name: 'Metadata',
-        text: 'A container for metadata.',
-        ref: 'ISO/IEC 14496-12, 8.11.1',
-    },
-    mdia: {
-        name: 'Media',
-        text: 'Container for media data information.',
-        ref: 'ISO/IEC 14496-12, 8.4.1',
-    },
-    minf: {
-        name: 'Media Information',
-        text: 'Container for characteristic information of the media.',
-        ref: 'ISO/IEC 14496-12, 8.4.4',
-    },
-
-    dinf: {
-        name: 'Data Information',
-        text: 'Container for objects that declare where media data is located.',
-        ref: 'ISO/IEC 14496-12, 8.7.1',
-    },
-    stbl: {
-        name: 'Sample Table',
-        text: 'Contains all time and data indexing for samples.',
-        ref: 'ISO/IEC 14496-12, 8.5.1',
-    },
-
-    edts: {
-        name: 'Edit Box',
-        text: 'A container for an edit list.',
-        ref: 'ISO/IEC 14496-12, 8.6.5',
-    },
-
-    mvex: {
-        name: 'Movie Extends',
-        text: 'Signals that the movie may contain fragments.',
-        ref: 'ISO/IEC 14496-12, 8.8.1',
-    },
-
-    moof: {
-        name: 'Movie Fragment',
-        text: 'Container for all metadata for a single fragment.',
-        ref: 'ISO/IEC 14496-12, 8.8.4',
-    },
-
-    traf: {
-        name: 'Track Fragment',
-        text: "Container for metadata for a single track's fragment.",
-        ref: 'ISO/IEC 14496-12, 8.8.6',
-    },
-
-    pssh: {
-        name: 'Protection System Specific Header',
-        text: 'Contains DRM initialization data.',
-        ref: 'ISO/IEC 23001-7',
-    },
-    mdat: {
-        name: 'Media Data',
-        text: 'Contains the actual audio/video sample data.',
-        ref: 'ISO/IEC 14496-12, 8.1.1',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/hdlr.js b/js/infrastructure/segment/isobmff/parsers/hdlr.js
deleted file mode 100644
index ef71535..0000000
--- a/js/infrastructure/segment/isobmff/parsers/hdlr.js
+++ /dev/null
@@ -1,31 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseHdlr(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-    p.skip(4, 'pre_defined');
-    p.readString(4, 'handler_type');
-    p.skip(12, 'reserved');
-    p.readNullTerminatedString('name');
-    p.finalize();
-}
-
-export const hdlrTooltip = {
-    hdlr: {
-        name: 'Handler Reference',
-        text: "Declares the media type of the track (e.g., 'vide', 'soun').",
-        ref: 'ISO/IEC 14496-12, 8.4.3',
-    },
-    'hdlr@handler_type': {
-        text: "A four-character code identifying the media type (e.g., 'vide', 'soun', 'hint').",
-        ref: 'ISO/IEC 14496-12, 8.4.3.3',
-    },
-    'hdlr@name': {
-        text: 'A human-readable name for the track type (for debugging and inspection purposes).',
-        ref: 'ISO/IEC 14496-12, 8.4.3.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/id32.js b/js/infrastructure/segment/isobmff/parsers/id32.js
deleted file mode 100644
index 1b8e546..0000000
--- a/js/infrastructure/segment/isobmff/parsers/id32.js
+++ /dev/null
@@ -1,24 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'ID32' (ID3v2 Metadata) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseId32(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-
-    // The language code is sometimes packed into the flags, but we will treat
-    // the rest of the box as an opaque payload containing the ID3v2 tag data.
-    p.readRemainingBytes('id3v2_data');
-    p.finalize();
-}
-
-export const id32Tooltip = {
-    ID32: {
-        name: 'ID3v2 Metadata Box',
-        text: 'A box containing ID3 version 2 metadata tags. This is a common but non-standard box often found in files created by tools like FFmpeg, typically within a `udta` or `meta` box.',
-        ref: 'User-defined',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/iods.js b/js/infrastructure/segment/isobmff/parsers/iods.js
deleted file mode 100644
index 422ac41..0000000
--- a/js/infrastructure/segment/isobmff/parsers/iods.js
+++ /dev/null
@@ -1,87 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses a variable-length descriptor size field.
- * @param {BoxParser} p The BoxParser instance.
- * @param {string} fieldName The name to use for the calculated size field.
- * @returns {number | null} The size of the descriptor payload.
- */
-function parseDescriptorSize(p, fieldName) {
-    const startOffset = p.offset;
-    let size = 0;
-    let byte;
-    let bytesRead = 0;
-    do {
-        byte = p.readUint8(`size_byte_${bytesRead}`);
-        if (byte === null) return null;
-        size = (size << 7) | (byte & 0x7f);
-        bytesRead++;
-    } while (byte & 0x80 && bytesRead < 4);
-
-    p.box.details[fieldName] = {
-        value: size,
-        offset: p.box.offset + startOffset,
-        length: bytesRead,
-    };
-    for (let i = 0; i < bytesRead; i++) {
-        delete p.box.details[`size_byte_${i}`];
-    }
-    return size;
-}
-
-/**
- * Parses the 'iods' (Initial Object Descriptor) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseIods(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-
-    // --- InitialObjectDescriptor ---
-    const iodTag = p.readUint8('InitialObjectDescriptor_tag');
-    // FIX: Allow IOD (0x02), ES (0x03), or MP4_IOD (0x10) tags.
-    if (iodTag !== 0x02 && iodTag !== 0x03 && iodTag !== 0x10) {
-        p.addIssue(
-            'warn',
-            `Expected IOD tag (0x02, 0x03, or 0x10), but found ${iodTag}.`
-        );
-        p.readRemainingBytes('unknown_descriptor_data');
-        p.finalize();
-        return;
-    }
-
-    const iodSize = parseDescriptorSize(p, 'InitialObjectDescriptor_size');
-    if (iodSize === null) {
-        p.finalize();
-        return;
-    }
-
-    p.readUint16('objectDescriptorID');
-    p.readUint8('ODProfileLevelIndication');
-    p.readUint8('sceneProfileLevelIndication');
-    p.readUint8('audioProfileLevelIndication');
-    p.readUint8('visualProfileLevelIndication');
-    p.readUint8('graphicsProfileLevelIndication');
-
-    // The rest of the IOD contains a list of other descriptors.
-    // We will skip this for now but mark it as such.
-    p.readRemainingBytes('other_descriptors_data');
-    p.finalize();
-}
-
-export const iodsTooltip = {
-    iods: {
-        name: 'Initial Object Descriptor',
-        text: 'Contains the Initial Object Descriptor as defined in MPEG-4 Systems (ISO/IEC 14496-1). This descriptor is a container for the elementary stream descriptors and other information.',
-        ref: 'ISO/IEC 14496-14, 5.5',
-    },
-    'iods@objectDescriptorID': {
-        text: 'A 10-bit ID for this Object Descriptor. The top 6 bits are flags.',
-        ref: 'ISO/IEC 14496-1, 8.2.2',
-    },
-    'iods@ODProfileLevelIndication': {
-        text: 'Indicates the profile and level of the Object Descriptor stream.',
-        ref: 'ISO/IEC 14496-1, 8.2.2',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/mdhd.js b/js/infrastructure/segment/isobmff/parsers/mdhd.js
deleted file mode 100644
index 2c8e8e2..0000000
--- a/js/infrastructure/segment/isobmff/parsers/mdhd.js
+++ /dev/null
@@ -1,72 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseMdhd(box, view) {
-    const p = new BoxParser(box, view);
-    const { version } = p.readVersionAndFlags();
-
-    if (version === null) {
-        p.finalize();
-        return;
-    }
-
-    if (version === 1) {
-        p.readBigUint64('creation_time');
-        p.readBigUint64('modification_time');
-    } else {
-        p.readUint32('creation_time');
-        p.readUint32('modification_time');
-    }
-
-    p.readUint32('timescale');
-
-    if (version === 1) {
-        p.readBigUint64('duration');
-    } else {
-        p.readUint32('duration');
-    }
-
-    const langBits = p.readUint16('language_bits');
-    if (langBits !== null) {
-        const langValue = String.fromCharCode(
-            ((langBits >> 10) & 0x1f) + 0x60,
-            ((langBits >> 5) & 0x1f) + 0x60,
-            (langBits & 0x1f) + 0x60
-        );
-        box.details['language'] = {
-            value: langValue,
-            offset: box.details['language_bits'].offset,
-            length: 2,
-        };
-        delete box.details['language_bits'];
-    }
-    p.skip(2, 'pre-defined');
-    p.finalize();
-}
-
-export const mdhdTooltip = {
-    mdhd: {
-        name: 'Media Header',
-        text: 'Declares media information (timescale, language).',
-        ref: 'ISO/IEC 14496-12, 8.4.2',
-    },
-    'mdhd@version': {
-        text: 'Version of this box (0 or 1). Affects the size of time and duration fields.',
-        ref: 'ISO/IEC 14496-12, 8.4.2.3',
-    },
-    'mdhd@timescale': {
-        text: "The number of time units that pass in one second for this track's media.",
-        ref: 'ISO/IEC 14496-12, 8.4.2.3',
-    },
-    'mdhd@duration': {
-        text: "The duration of this track's media in units of its own timescale.",
-        ref: 'ISO/IEC 14496-12, 8.4.2.3',
-    },
-    'mdhd@language': {
-        text: 'The ISO-639-2/T language code for this media.',
-        ref: 'ISO/IEC 14496-12, 8.4.2.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/mehd.js b/js/infrastructure/segment/isobmff/parsers/mehd.js
deleted file mode 100644
index a2247a2..0000000
--- a/js/infrastructure/segment/isobmff/parsers/mehd.js
+++ /dev/null
@@ -1,35 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'mehd' (Movie Extends Header) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseMehd(box, view) {
-    const p = new BoxParser(box, view);
-    const { version } = p.readVersionAndFlags();
-
-    if (version === null) {
-        p.finalize();
-        return;
-    }
-
-    if (version === 1) {
-        p.readBigUint64('fragment_duration');
-    } else {
-        p.readUint32('fragment_duration');
-    }
-    p.finalize();
-}
-
-export const mehdTooltip = {
-    mehd: {
-        name: 'Movie Extends Header',
-        text: 'Provides the overall duration of a fragmented movie, including all fragments.',
-        ref: 'ISO/IEC 14496-12, 8.8.2',
-    },
-    'mehd@fragment_duration': {
-        text: "The total duration of the movie in the movie's timescale, including all movie fragments.",
-        ref: 'ISO/IEC 14496-12, 8.8.2.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/meta.js b/js/infrastructure/segment/isobmff/parsers/meta.js
deleted file mode 100644
index 17e5abb..0000000
--- a/js/infrastructure/segment/isobmff/parsers/meta.js
+++ /dev/null
@@ -1,20 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'meta' (Metadata) container box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseMeta(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-    // This is a container box. Its children ('hdlr' and others) will be parsed by the main parser.
-}
-
-export const metaTooltip = {
-    meta: {
-        name: 'Metadata Box',
-        text: 'A container for descriptive or annotative metadata.',
-        ref: 'ISO/IEC 14496-12, 8.11.1',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/mfhd.js b/js/infrastructure/segment/isobmff/parsers/mfhd.js
deleted file mode 100644
index 8e168ab..0000000
--- a/js/infrastructure/segment/isobmff/parsers/mfhd.js
+++ /dev/null
@@ -1,23 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseMfhd(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-    p.readUint32('sequence_number');
-}
-
-export const mfhdTooltip = {
-    mfhd: {
-        name: 'Movie Fragment Header',
-        text: 'Contains the sequence number of this fragment.',
-        ref: 'ISO/IEC 14496-12, 8.8.5',
-    },
-    'mfhd@sequence_number': {
-        text: 'The ordinal number of this fragment, in increasing order.',
-        ref: 'ISO/IEC 14496-12, 8.8.5.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/mfra.js b/js/infrastructure/segment/isobmff/parsers/mfra.js
deleted file mode 100644
index 42c60ef..0000000
--- a/js/infrastructure/segment/isobmff/parsers/mfra.js
+++ /dev/null
@@ -1,17 +0,0 @@
-/**
- * Parses the 'mfra' (Movie Fragment Random Access) container box.
- * This box is a container for 'tfra' and 'mfro' boxes.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseMfra(box, view) {
-    // This is a container box. Its children ('tfra', 'mfro') will be parsed by the main parser.
-}
-
-export const mfraTooltip = {
-    mfra: {
-        name: 'Movie Fragment Random Access',
-        text: 'A container for random access information for movie fragments, often found at the end of the file.',
-        ref: 'ISO/IEC 14496-12, 8.8.9',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/mfro.js b/js/infrastructure/segment/isobmff/parsers/mfro.js
deleted file mode 100644
index 92504f8..0000000
--- a/js/infrastructure/segment/isobmff/parsers/mfro.js
+++ /dev/null
@@ -1,25 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'mfro' (Movie Fragment Random Access Offset) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseMfro(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-    p.readUint32('size');
-    p.finalize();
-}
-
-export const mfroTooltip = {
-    mfro: {
-        name: 'Movie Fragment Random Access Offset',
-        text: 'Contains the size of the enclosing `mfra` box to aid in locating it by scanning from the end of the file.',
-        ref: 'ISO/IEC 14496-12, 8.8.11',
-    },
-    'mfro@size': {
-        text: 'The size of the `mfra` box in bytes.',
-        ref: 'ISO/IEC 14496-12, 8.8.11.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/mp4a.js b/js/infrastructure/segment/isobmff/parsers/mp4a.js
deleted file mode 100644
index 4614562..0000000
--- a/js/infrastructure/segment/isobmff/parsers/mp4a.js
+++ /dev/null
@@ -1,55 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'mp4a' (MP4 Audio Sample Entry) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseMp4a(box, view) {
-    const p = new BoxParser(box, view);
-
-    // SampleEntry fields
-    p.skip(6, 'reserved_sample_entry');
-    p.readUint16('data_reference_index');
-
-    // AudioSampleEntry fields
-    p.skip(8, 'reserved_audio_entry_1');
-    p.readUint16('channelcount');
-    p.readUint16('samplesize');
-    p.skip(2, 'pre_defined');
-    p.skip(2, 'reserved_audio_entry_2');
-
-    const samplerateFixedPoint = p.readUint32('samplerate_fixed_point');
-    if (samplerateFixedPoint !== null) {
-        box.details['samplerate'] = {
-            ...box.details['samplerate_fixed_point'],
-            value: samplerateFixedPoint >> 16,
-        };
-        delete box.details['samplerate_fixed_point'];
-    }
-    // Children (e.g. esds) are parsed by main parser. Do not call finalize().
-}
-
-export const mp4aTooltip = {
-    mp4a: {
-        name: 'MP4 Audio Sample Entry',
-        text: 'Defines the coding type and initialization information for an MPEG-4 audio track, typically AAC.',
-        ref: 'ISO/IEC 14496-12, 12.2.3',
-    },
-    'mp4a@data_reference_index': {
-        text: 'Index to the Data Reference Box, indicating where the media data is stored.',
-        ref: 'ISO/IEC 14496-12, 8.5.2.2',
-    },
-    'mp4a@channelcount': {
-        text: 'The number of audio channels (e.g., 2 for stereo).',
-        ref: 'ISO/IEC 14496-12, 12.2.3.2',
-    },
-    'mp4a@samplesize': {
-        text: 'The size of each audio sample in bits. Typically 16.',
-        ref: 'ISO/IEC 14496-12, 12.2.3.2',
-    },
-    'mp4a@samplerate': {
-        text: 'The sampling rate of the audio in samples per second (the integer part of a 16.16 fixed-point number).',
-        ref: 'ISO/IEC 14496-12, 12.2.3.2',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/mvhd.js b/js/infrastructure/segment/isobmff/parsers/mvhd.js
deleted file mode 100644
index d1fca51..0000000
--- a/js/infrastructure/segment/isobmff/parsers/mvhd.js
+++ /dev/null
@@ -1,84 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseMvhd(box, view) {
-    const p = new BoxParser(box, view);
-    const { version } = p.readVersionAndFlags();
-
-    if (version === 1) {
-        p.readBigUint64('creation_time');
-        p.readBigUint64('modification_time');
-        p.readUint32('timescale');
-        p.readBigUint64('duration');
-    } else {
-        p.readUint32('creation_time');
-        p.readUint32('modification_time');
-        p.readUint32('timescale');
-        p.readUint32('duration');
-    }
-
-    p.readInt32('rate'); // Actually a 16.16 fixed point
-    p.readInt16('volume'); // Actually a 8.8 fixed point
-    p.skip(10, 'reserved');
-
-    const matrixValues = [];
-    for (let i = 0; i < 9; i++) {
-        matrixValues.push(p.readInt32(`matrix_val_${i}`));
-    }
-    box.details['matrix'] = {
-        value: `[${matrixValues.join(', ')}]`,
-        offset: box.details['matrix_val_0'].offset,
-        length: 36,
-    };
-    for (let i = 0; i < 9; i++) delete box.details[`matrix_val_${i}`];
-
-    p.skip(24, 'pre_defined');
-    p.readUint32('next_track_ID');
-}
-
-export const mvhdTooltip = {
-    mvhd: {
-        name: 'Movie Header',
-        text: 'Contains global information for the presentation (timescale, duration).',
-        ref: 'ISO/IEC 14496-12, 8.2.2',
-    },
-    'mvhd@version': {
-        text: 'Version of this box (0 or 1). Affects the size of time and duration fields.',
-        ref: 'ISO/IEC 14496-12, 8.2.2.3',
-    },
-    'mvhd@creation_time': {
-        text: 'The creation time of the presentation (in seconds since midnight, Jan. 1, 1904, UTC).',
-        ref: 'ISO/IEC 14496-12, 8.2.2.3',
-    },
-    'mvhd@modification_time': {
-        text: 'The most recent time the presentation was modified.',
-        ref: 'ISO/IEC 14496-12, 8.2.2.3',
-    },
-    'mvhd@timescale': {
-        text: 'The number of time units that pass in one second for the presentation.',
-        ref: 'ISO/IEC 14496-12, 8.2.2.3',
-    },
-    'mvhd@duration': {
-        text: 'The duration of the presentation in units of the timescale.',
-        ref: 'ISO/IEC 14496-12, 8.2.2.3',
-    },
-    'mvhd@rate': {
-        text: 'A fixed-point 16.16 number that specifies the preferred playback rate (1.0 is normal speed).',
-        ref: 'ISO/IEC 14496-12, 8.2.2.3',
-    },
-    'mvhd@volume': {
-        text: 'A fixed-point 8.8 number that specifies the preferred playback volume (1.0 is full volume).',
-        ref: 'ISO/IEC 14496-12, 8.2.2.3',
-    },
-    'mvhd@matrix': {
-        text: 'A transformation matrix for the video, mapping points from video coordinates to display coordinates.',
-        ref: 'ISO/IEC 14496-12, 8.2.2.3',
-    },
-    'mvhd@next_track_ID': {
-        text: 'A non-zero integer indicating a value for the track ID of the next track to be added to this presentation.',
-        ref: 'ISO/IEC 14496-12, 8.2.2.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/pasp.js b/js/infrastructure/segment/isobmff/parsers/pasp.js
deleted file mode 100644
index e2952db..0000000
--- a/js/infrastructure/segment/isobmff/parsers/pasp.js
+++ /dev/null
@@ -1,29 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'pasp' (Pixel Aspect Ratio) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parsePasp(box, view) {
-    const p = new BoxParser(box, view);
-    p.readUint32('hSpacing');
-    p.readUint32('vSpacing');
-    p.finalize();
-}
-
-export const paspTooltip = {
-    pasp: {
-        name: 'Pixel Aspect Ratio Box',
-        text: 'Specifies the pixel aspect ratio of the video.',
-        ref: 'ISO/IEC 14496-12, 12.1.4',
-    },
-    'pasp@hSpacing': {
-        text: 'The horizontal spacing of a pixel.',
-        ref: 'ISO/IEC 14496-12, 12.1.4.1',
-    },
-    'pasp@vSpacing': {
-        text: 'The vertical spacing of a pixel.',
-        ref: 'ISO/IEC 14496-12, 12.1.4.1',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/pdin.js b/js/infrastructure/segment/isobmff/parsers/pdin.js
deleted file mode 100644
index 5b1514e..0000000
--- a/js/infrastructure/segment/isobmff/parsers/pdin.js
+++ /dev/null
@@ -1,47 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'pdin' (Progressive Download Information) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parsePdin(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-
-    let entryIndex = 1;
-    while (p.offset < box.size) {
-        if (p.stopped) break;
-        if (entryIndex > 5) {
-            // To avoid cluttering UI, show first few and summarize
-            box.details['...more_entries'] = {
-                value: 'More entries not shown.',
-                offset: 0,
-                length: 0,
-            };
-            break;
-        }
-
-        const entryPrefix = `entry_${entryIndex}`;
-        p.readUint32(`${entryPrefix}_rate`);
-        p.readUint32(`${entryPrefix}_initial_delay`);
-        entryIndex++;
-    }
-    p.finalize();
-}
-
-export const pdinTooltip = {
-    pdin: {
-        name: 'Progressive Download Info',
-        text: 'Contains pairs of download rates and suggested initial playback delays to aid progressive downloading.',
-        ref: 'ISO/IEC 14496-12, 8.1.3',
-    },
-    'pdin@entry_1_rate': {
-        text: 'The download rate in bytes/second for the first entry.',
-        ref: 'ISO/IEC 14496-12, 8.1.3.3',
-    },
-    'pdin@entry_1_initial_delay': {
-        text: 'The suggested initial playback delay in milliseconds for the first entry.',
-        ref: 'ISO/IEC 14496-12, 8.1.3.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/pssh.js b/js/infrastructure/segment/isobmff/parsers/pssh.js
deleted file mode 100644
index 648e9b9..0000000
--- a/js/infrastructure/segment/isobmff/parsers/pssh.js
+++ /dev/null
@@ -1,71 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parsePssh(box, view) {
-    const p = new BoxParser(box, view);
-    const { version } = p.readVersionAndFlags();
-
-    if (version === null) {
-        p.finalize();
-        return;
-    }
-
-    // Read System ID as raw bytes and format as UUID
-    const systemIdBytes = [];
-    for (let i = 0; i < 16; i++) {
-        const byte = p.readUint8(`system_id_byte_${i}`);
-        if (byte === null) {
-            p.finalize();
-            return;
-        }
-        systemIdBytes.push(byte.toString(16).padStart(2, '0'));
-    }
-    const baseOffset = box.details['system_id_byte_0'].offset;
-    for (let i = 0; i < 16; i++) delete box.details[`system_id_byte_${i}`];
-    box.details['System ID'] = {
-        value: systemIdBytes.join('-'),
-        offset: baseOffset,
-        length: 16,
-    };
-
-    if (version > 0) {
-        const keyIdCount = p.readUint32('Key ID Count');
-        if (keyIdCount !== null) {
-            p.skip(keyIdCount * 16, 'Key IDs');
-        }
-    }
-
-    const dataSize = p.readUint32('Data Size');
-    if (dataSize !== null) {
-        p.skip(dataSize, 'Data');
-    }
-
-    p.finalize();
-}
-
-export const psshTooltip = {
-    pssh: {
-        name: 'Protection System Specific Header',
-        text: 'Contains DRM initialization data.',
-        ref: 'ISO/IEC 23001-7',
-    },
-    'pssh@System ID': {
-        text: 'A 16-byte UUID that uniquely identifies the DRM system (e.g., Widevine, PlayReady).',
-        ref: 'ISO/IEC 23001-7, 5.1.2',
-    },
-    'pssh@Data Size': {
-        text: 'The size of the system-specific initialization data that follows.',
-        ref: 'ISO/IEC 23001-7, 5.1.2',
-    },
-    'pssh@version': {
-        text: 'Version of this box (0 or 1). Version 1 includes key IDs.',
-        ref: 'ISO/IEC 23001-7, 5.1.2',
-    },
-    'pssh@Key ID Count': {
-        text: 'The number of key IDs present in the box (only for version 1).',
-        ref: 'ISO/IEC 23001-7, 5.1.2',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/saio.js b/js/infrastructure/segment/isobmff/parsers/saio.js
deleted file mode 100644
index 85d04fb..0000000
--- a/js/infrastructure/segment/isobmff/parsers/saio.js
+++ /dev/null
@@ -1,47 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'saio' (Sample Auxiliary Information Offsets) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseSaio(box, view) {
-    const p = new BoxParser(box, view);
-    const { version, flags } = p.readVersionAndFlags();
-
-    if (version === null) {
-        p.finalize();
-        return;
-    }
-
-    if ((flags & 1) !== 0) {
-        p.skip(8, 'aux_info_type_and_param');
-    }
-
-    const entryCount = p.readUint32('entry_count');
-
-    if (entryCount !== null && entryCount > 0) {
-        if (version === 1) {
-            p.readBigUint64('offset_1');
-        } else {
-            p.readUint32('offset_1');
-        }
-    }
-    p.finalize();
-}
-
-export const saioTooltip = {
-    saio: {
-        name: 'Sample Auxiliary Information Offsets',
-        text: 'Provides the location of auxiliary information for samples, such as CENC Initialization Vectors.',
-        ref: 'ISO/IEC 14496-12, 8.7.9',
-    },
-    'saio@entry_count': {
-        text: 'The number of offset entries.',
-        ref: 'ISO/IEC 14496-12, 8.7.9.3',
-    },
-    'saio@offset_1': {
-        text: 'The offset of the auxiliary information for the first chunk or run.',
-        ref: 'ISO/IEC 14496-12, 8.7.9.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/saiz.js b/js/infrastructure/segment/isobmff/parsers/saiz.js
deleted file mode 100644
index 3406276..0000000
--- a/js/infrastructure/segment/isobmff/parsers/saiz.js
+++ /dev/null
@@ -1,62 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'saiz' (Sample Auxiliary Information Sizes) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseSaiz(box, view) {
-    const p = new BoxParser(box, view);
-    const { flags } = p.readVersionAndFlags();
-
-    if (flags !== null && (flags & 1) !== 0) {
-        p.readUint32('aux_info_type');
-        p.readUint32('aux_info_type_parameter');
-    }
-
-    const defaultSampleInfoSize = p.readUint8('default_sample_info_size');
-    const sampleCount = p.readUint32('sample_count');
-
-    if (
-        defaultSampleInfoSize === 0 &&
-        sampleCount !== null &&
-        sampleCount > 0
-    ) {
-        const maxEntriesToShow = 10;
-        for (let i = 0; i < sampleCount; i++) {
-            if (p.stopped) break;
-            if (i < maxEntriesToShow) {
-                p.readUint8(`sample_info_size_${i + 1}`);
-            } else {
-                p.offset += 1;
-            }
-        }
-
-        if (sampleCount > maxEntriesToShow) {
-            box.details['...more_entries'] = {
-                value: `${
-                    sampleCount - maxEntriesToShow
-                } more entries not shown but parsed`,
-                offset: 0,
-                length: 0,
-            };
-        }
-    }
-    p.finalize();
-}
-
-export const saizTooltip = {
-    saiz: {
-        name: 'Sample Auxiliary Information Sizes',
-        text: 'Provides the size of auxiliary information for each sample, used for CENC encryption parameters.',
-        ref: 'ISO/IEC 14496-12, 8.7.8',
-    },
-    'saiz@default_sample_info_size': {
-        text: 'Default size of the auxiliary info. If 0, sizes are in the table.',
-        ref: 'ISO/IEC 14496-12, 8.7.8.3',
-    },
-    'saiz@sample_count': {
-        text: 'The number of samples for which size information is provided.',
-        ref: 'ISO/IEC 14496-12, 8.7.8.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/sbgp.js b/js/infrastructure/segment/isobmff/parsers/sbgp.js
deleted file mode 100644
index b28488f..0000000
--- a/js/infrastructure/segment/isobmff/parsers/sbgp.js
+++ /dev/null
@@ -1,50 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'sbgp' (Sample to Group) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseSbgp(box, view) {
-    const p = new BoxParser(box, view);
-    const { version } = p.readVersionAndFlags();
-
-    if (version === null) {
-        p.finalize();
-        return;
-    }
-
-    p.readString(4, 'grouping_type');
-
-    if (version === 1) {
-        p.readUint32('grouping_type_parameter');
-    }
-
-    const entryCount = p.readUint32('entry_count');
-
-    if (entryCount !== null && entryCount > 0) {
-        p.readUint32('entry_1_sample_count');
-        p.readUint32('entry_1_group_description_index');
-    }
-    p.finalize();
-}
-
-export const sbgpTooltip = {
-    sbgp: {
-        name: 'Sample to Group',
-        text: 'Assigns samples to a specific group, described in the Sample Group Description Box (sgpd).',
-        ref: 'ISO/IEC 14496-12, 8.9.2',
-    },
-    'sbgp@grouping_type': {
-        text: 'A code indicating the criterion used to group the samples (e.g., "rap " for random access points).',
-        ref: 'ISO/IEC 14496-12, 8.9.2.3',
-    },
-    'sbgp@grouping_type_parameter': {
-        text: 'A parameter providing additional information for the grouping (only in version 1).',
-        ref: 'ISO/IEC 14496-12, 8.9.2.3',
-    },
-    'sbgp@entry_count': {
-        text: 'The number of entries mapping sample runs to group descriptions.',
-        ref: 'ISO/IEC 14496-12, 8.9.2.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/schi.js b/js/infrastructure/segment/isobmff/parsers/schi.js
deleted file mode 100644
index 8062231..0000000
--- a/js/infrastructure/segment/isobmff/parsers/schi.js
+++ /dev/null
@@ -1,17 +0,0 @@
-/**
- * Parses the 'schi' (Scheme Information) container box.
- * This box is a container for scheme-specific data.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseSchi(box, view) {
-    // This is a container box. Its children will be parsed by the main parser.
-}
-
-export const schiTooltip = {
-    schi: {
-        name: 'Scheme Information Box',
-        text: 'A container for boxes with scheme-specific data needed by the protection system.',
-        ref: 'ISO/IEC 14496-12, 8.12.6',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/schm.js b/js/infrastructure/segment/isobmff/parsers/schm.js
deleted file mode 100644
index 647f1cf..0000000
--- a/js/infrastructure/segment/isobmff/parsers/schm.js
+++ /dev/null
@@ -1,39 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'schm' (Scheme Type) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseSchm(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-    p.readString(4, 'scheme_type');
-
-    const schemeVersion = p.readUint32('scheme_version_raw');
-    if (schemeVersion !== null) {
-        box.details['scheme_version'] = {
-            value: `0x${schemeVersion.toString(16)}`,
-            offset: box.details['scheme_version_raw'].offset,
-            length: 4,
-        };
-        delete box.details['scheme_version_raw'];
-    }
-    p.finalize();
-}
-
-export const schmTooltip = {
-    schm: {
-        name: 'Scheme Type Box',
-        text: 'Identifies the protection scheme (e.g., "cenc" for Common Encryption).',
-        ref: 'ISO/IEC 14496-12, 8.12.5',
-    },
-    'schm@scheme_type': {
-        text: 'A four-character code identifying the protection scheme.',
-        ref: 'ISO/IEC 14496-12, 8.12.5.3',
-    },
-    'schm@scheme_version': {
-        text: 'The version of the scheme used to create the content.',
-        ref: 'ISO/IEC 14496-12, 8.12.5.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/sdtp.js b/js/infrastructure/segment/isobmff/parsers/sdtp.js
deleted file mode 100644
index 9c65edb..0000000
--- a/js/infrastructure/segment/isobmff/parsers/sdtp.js
+++ /dev/null
@@ -1,90 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'sdtp' (Sample Dependency Type) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseSdtp(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-
-    const sampleCount = box.size - p.offset;
-    box.details['sample_count'] = {
-        value: sampleCount,
-        offset: 0,
-        length: 0,
-    };
-
-    if (sampleCount > 0) {
-        const maxEntriesToShow = 10;
-        for (let i = 0; i < sampleCount; i++) {
-            if (p.stopped) break;
-            const entryPrefix = `sample_${i + 1}`;
-
-            if (i < maxEntriesToShow) {
-                const byte = p.readUint8(`${entryPrefix}_flags_byte`);
-                if (byte === null) break;
-
-                delete box.details[`${entryPrefix}_flags_byte`];
-
-                box.details[`${entryPrefix}_is_leading`] = {
-                    value: (byte >> 6) & 0x03,
-                    offset: box.offset + p.offset - 1,
-                    length: 0.25,
-                };
-                box.details[`${entryPrefix}_sample_depends_on`] = {
-                    value: (byte >> 4) & 0x03,
-                    offset: box.offset + p.offset - 1,
-                    length: 0.25,
-                };
-                box.details[`${entryPrefix}_sample_is_depended_on`] = {
-                    value: (byte >> 2) & 0x03,
-                    offset: box.offset + p.offset - 1,
-                    length: 0.25,
-                };
-                box.details[`${entryPrefix}_sample_has_redundancy`] = {
-                    value: byte & 0x03,
-                    offset: box.offset + p.offset - 1,
-                    length: 0.25,
-                };
-            } else {
-                p.offset += 1;
-            }
-        }
-        if (sampleCount > maxEntriesToShow) {
-            box.details['...more_entries'] = {
-                value: `${
-                    sampleCount - maxEntriesToShow
-                } more entries not shown but parsed`,
-                offset: 0,
-                length: 0,
-            };
-        }
-    }
-    p.finalize();
-}
-
-export const sdtpTooltip = {
-    sdtp: {
-        name: 'Independent and Disposable Samples',
-        text: 'Provides detailed dependency information for each sample in the track.',
-        ref: 'ISO/IEC 14496-12, 8.6.4',
-    },
-    'sdtp@sample_1_is_leading': {
-        text: 'Leading nature of the sample (0:unknown, 1:leading with dependency, 2:not leading, 3:leading without dependency).',
-        ref: 'ISO/IEC 14496-12, 8.6.4.3',
-    },
-    'sdtp@sample_1_sample_depends_on': {
-        text: 'Sample dependency (0:unknown, 1:depends on others (not I-frame), 2:does not depend on others (I-frame)).',
-        ref: 'ISO/IEC 14496-12, 8.6.4.3',
-    },
-    'sdtp@sample_1_sample_is_depended_on': {
-        text: 'Whether other samples depend on this one (0:unknown, 1:others may depend, 2:disposable).',
-        ref: 'ISO/IEC 14496-12, 8.6.4.3',
-    },
-    'sdtp@sample_1_sample_has_redundancy': {
-        text: 'Redundant coding (0:unknown, 1:has redundant coding, 2:no redundant coding).',
-        ref: 'ISO/IEC 14496-12, 8.6.4.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/senc.js b/js/infrastructure/segment/isobmff/parsers/senc.js
deleted file mode 100644
index 4dd0ae0..0000000
--- a/js/infrastructure/segment/isobmff/parsers/senc.js
+++ /dev/null
@@ -1,107 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'senc' (Sample Encryption) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseSenc(box, view) {
-    const p = new BoxParser(box, view);
-    const { flags } = p.readVersionAndFlags();
-
-    if (flags === null) {
-        p.finalize();
-        return;
-    }
-
-    const sampleCount = p.readUint32('sample_count');
-    box.samples = []; // Initialize for detailed sample data
-
-    if (sampleCount !== null) {
-        // NOTE: The IV size is defined in the associated Track Encryption ('tenc') box.
-        // This context-free parser cannot access it. We assume a default IV size of 8 bytes,
-        // which is common for CENC ('cbcs', 'cenc'). This is a known limitation.
-        // The validation logic, which has more context, will perform the final checks.
-        const assumedIvSize = 8;
-
-        for (let i = 0; i < sampleCount; i++) {
-            if (p.stopped) break;
-
-            const sampleEntry = {
-                iv: null,
-                subsamples: [],
-            };
-
-            // --- Parse Initialization Vector ---
-            if (p.checkBounds(assumedIvSize)) {
-                const ivBytes = new Uint8Array(
-                    p.view.buffer,
-                    p.view.byteOffset + p.offset,
-                    assumedIvSize
-                );
-                sampleEntry.iv = ivBytes;
-                p.offset += assumedIvSize;
-            } else {
-                break; // Not enough data for even an IV
-            }
-
-            // --- Parse subsample data if flag is set ---
-            if ((flags & 2) !== 0) {
-                // use_subsample_encryption
-                if (p.checkBounds(2)) {
-                    const subSampleCount = p.view.getUint16(p.offset);
-                    sampleEntry.subsample_count = subSampleCount;
-                    p.offset += 2;
-
-                    for (let j = 0; j < subSampleCount; j++) {
-                        if (p.checkBounds(6)) {
-                            const clearBytes = p.view.getUint16(p.offset);
-                            const protectedBytes = p.view.getUint32(
-                                p.offset + 2
-                            );
-                            sampleEntry.subsamples.push({
-                                BytesOfClearData: clearBytes,
-                                BytesOfProtectedData: protectedBytes,
-                            });
-                            p.offset += 6;
-                        } else {
-                            p.stopped = true;
-                            break;
-                        }
-                    }
-                }
-            }
-            box.samples.push(sampleEntry);
-        }
-    }
-
-    p.finalize();
-}
-
-export const sencTooltip = {
-    senc: {
-        name: 'Sample Encryption Box',
-        text: 'Contains sample-specific encryption information, such as Initialization Vectors (IVs) and sub-sample encryption data for Common Encryption (CENC).',
-        ref: 'ISO/IEC 23001-7, 7.1',
-    },
-    'senc@sample_count': {
-        text: 'The number of samples described in this box.',
-        ref: 'ISO/IEC 23001-7, 7.1',
-    },
-    'senc@sample_1_iv': {
-        text: "The Initialization Vector for the first sample. Its size is defined in the 'tenc' box (typically 8 or 16 bytes).",
-        ref: 'ISO/IEC 23001-7, 7.2',
-    },
-    'senc@sample_1_subsample_count': {
-        text: 'The number of subsamples (clear/encrypted pairs) in the first sample.',
-        ref: 'ISO/IEC 23001-7, 7.1',
-    },
-    'senc@sample_1_subsample_1_clear_bytes': {
-        text: 'The number of unencrypted bytes in the first subsample.',
-        ref: 'ISO/IEC 23001-7, 7.1',
-    },
-    'senc@sample_1_subsample_1_encrypted_bytes': {
-        text: 'The number of encrypted bytes in the first subsample.',
-        ref: 'ISO/IEC 23001-7, 7.1',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/sgpd.js b/js/infrastructure/segment/isobmff/parsers/sgpd.js
deleted file mode 100644
index 5e38105..0000000
--- a/js/infrastructure/segment/isobmff/parsers/sgpd.js
+++ /dev/null
@@ -1,94 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'sgpd' (Sample Group Description) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseSgpd(box, view) {
-    const p = new BoxParser(box, view);
-    const { version } = p.readVersionAndFlags();
-
-    if (version === null) {
-        p.finalize();
-        return;
-    }
-
-    const groupingType = p.readString(4, 'grouping_type');
-
-    let defaultLength = 0;
-    if (version === 1) {
-        defaultLength = p.readUint32('default_length');
-    }
-
-    if (version >= 2) {
-        p.readUint32('default_sample_description_index');
-    }
-
-    const entryCount = p.readUint32('entry_count');
-
-    if (entryCount !== null) {
-        for (let i = 0; i < entryCount; i++) {
-            if (p.stopped) break;
-
-            let descriptionLength = defaultLength;
-            if (version === 1 && defaultLength === 0) {
-                const len = p.readUint32(`entry_${i + 1}_description_length`);
-                if (len === null) break;
-                descriptionLength = len;
-            }
-
-            const entryPrefix = `entry_${i + 1}`;
-            const entryStartOffset = p.offset;
-
-            // --- DEEP PARSING LOGIC ---
-            switch (groupingType) {
-                case 'roll':
-                    // VisualRollRecoveryEntry or AudioRollRecoveryEntry
-                    p.readInt16(`${entryPrefix}_roll_distance`);
-                    if (version === 0) descriptionLength = 2; // Implicit size for v0
-                    break;
-                // Add other known group types here in the future
-                default:
-                    // Fallback for unknown types
-                    if (version === 0) {
-                        p.addIssue(
-                            'warn',
-                            `Cannot determine entry size for unknown grouping_type '${groupingType}' with version 0. Parsing of this box may be incomplete.`
-                        );
-                        p.readRemainingBytes('unparsed_sgpd_entries');
-                        // Use a break that exits the for-loop
-                        i = entryCount;
-                    }
-                    break;
-            }
-
-            if (descriptionLength > 0 && p.offset === entryStartOffset) {
-                // If we didn't parse a known type, skip the bytes
-                p.skip(descriptionLength, `${entryPrefix}_description_data`);
-            }
-        }
-    }
-
-    p.finalize();
-}
-
-export const sgpdTooltip = {
-    sgpd: {
-        name: 'Sample Group Description',
-        text: 'Contains a sample group entry for each sample group, describing its properties.',
-        ref: 'ISO/IEC 14496-12, 8.9.3',
-    },
-    'sgpd@grouping_type': {
-        text: 'The type of grouping that these descriptions apply to. Must match the type in the `sbgp` box.',
-        ref: 'ISO/IEC 14496-12, 8.9.3.3',
-    },
-    'sgpd@entry_count': {
-        text: 'The number of sample group description entries that follow.',
-        ref: 'ISO/IEC 14496-12, 8.9.3.3',
-    },
-    'sgpd@entry_1_roll_distance': {
-        text: 'For "roll" groups, a signed integer indicating the number of samples (before or after) needed for a clean random access point.',
-        ref: 'ISO/IEC 14496-12, 10.1.1.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/sidx.js b/js/infrastructure/segment/isobmff/parsers/sidx.js
deleted file mode 100644
index 52cf01a..0000000
--- a/js/infrastructure/segment/isobmff/parsers/sidx.js
+++ /dev/null
@@ -1,114 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseSidx(box, view) {
-    const p = new BoxParser(box, view);
-    const { version } = p.readVersionAndFlags();
-
-    if (version === null) {
-        p.finalize();
-        return;
-    }
-
-    p.readUint32('reference_ID');
-    p.readUint32('timescale');
-
-    if (version === 1) {
-        p.readBigUint64('earliest_presentation_time');
-        p.readBigUint64('first_offset');
-    } else {
-        p.readUint32('earliest_presentation_time');
-        p.readUint32('first_offset');
-    }
-
-    p.skip(2, 'reserved');
-
-    const referenceCount = p.readUint16('reference_count');
-    if (referenceCount === null) {
-        p.finalize();
-        return;
-    }
-
-    for (let i = 0; i < referenceCount; i++) {
-        const refTypeAndSize = p.readUint32(`ref_${i + 1}_type_and_size`);
-        if (refTypeAndSize === null) break;
-
-        const refType = (refTypeAndSize >> 31) & 1;
-        const refSize = refTypeAndSize & 0x7fffffff;
-
-        const baseOffset =
-            box.details[`ref_${i + 1}_type_and_size`]?.offset || 0;
-        delete box.details[`ref_${i + 1}_type_and_size`];
-
-        box.details[`reference_${i + 1}_type`] = {
-            value: refType === 1 ? 'sidx' : 'media',
-            offset: baseOffset,
-            length: 4,
-        };
-        box.details[`reference_${i + 1}_size`] = {
-            value: refSize,
-            offset: baseOffset,
-            length: 4,
-        };
-
-        p.readUint32(`reference_${i + 1}_duration`);
-
-        const sapInfo = p.readUint32(`sap_info_dword_${i + 1}`);
-        if (sapInfo !== null) {
-            delete box.details[`sap_info_dword_${i + 1}`];
-            box.details[`reference_${i + 1}_sap_info`] = {
-                value: `0x${sapInfo.toString(16)}`,
-                offset: baseOffset + 8,
-                length: 4,
-            };
-        }
-    }
-    p.finalize();
-}
-
-export const sidxTooltip = {
-    sidx: {
-        name: 'Segment Index',
-        text: 'Provides a compact index of media stream chunks within a segment.',
-        ref: 'ISO/IEC 14496-12, 8.16.3',
-    },
-    'sidx@version': {
-        text: 'Version of this box (0 or 1). Affects the size of time and offset fields.',
-        ref: 'ISO/IEC 14496-12, 8.16.3.2',
-    },
-    'sidx@reference_ID': {
-        text: 'The stream ID for the reference stream (typically the track ID).',
-        ref: 'ISO/IEC 14496-12, 8.16.3.3',
-    },
-    'sidx@timescale': {
-        text: 'The timescale for time and duration fields in this box, in ticks per second.',
-        ref: 'ISO/IEC 14496-12, 8.16.3.3',
-    },
-    'sidx@earliest_presentation_time': {
-        text: 'The earliest presentation time of any access unit in the first subsegment.',
-        ref: 'ISO/IEC 14496-12, 8.16.3.3',
-    },
-    'sidx@first_offset': {
-        text: 'The byte offset from the end of this box to the first byte of the indexed material.',
-        ref: 'ISO/IEC 14496-12, 8.16.3.3',
-    },
-    'sidx@reference_count': {
-        text: 'The number of subsegment references that follow.',
-        ref: 'ISO/IEC 14496-12, 8.16.3.3',
-    },
-    'sidx@reference_1_type': {
-        text: 'The type of the first reference (0 = media, 1 = sidx box).',
-        ref: 'ISO/IEC 14496-12, 8.16.3.3',
-    },
-    'sidx@reference_1_size': {
-        text: 'The size in bytes of the referenced item.',
-        ref: 'ISO/IEC 14496-12, 8.16.3.3',
-    },
-    'sidx@reference_1_duration': {
-        text: 'The duration of the referenced subsegment in the timescale.',
-        ref: 'ISO/IEC 14496-12, 8.16.3.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/sinf.js b/js/infrastructure/segment/isobmff/parsers/sinf.js
deleted file mode 100644
index 84e28af..0000000
--- a/js/infrastructure/segment/isobmff/parsers/sinf.js
+++ /dev/null
@@ -1,17 +0,0 @@
-/**
- * Parses the 'sinf' (Protection Scheme Information) container box.
- * This box is a container for protection-related boxes like 'frma', 'schm', and 'schi'.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseSinf(box, view) {
-    // This is a container box. Its children will be parsed by the main parser.
-}
-
-export const sinfTooltip = {
-    sinf: {
-        name: 'Protection Scheme Information',
-        text: 'A container for all information required to understand the encryption transform applied.',
-        ref: 'ISO/IEC 14496-12, 8.12.1',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/smhd.js b/js/infrastructure/segment/isobmff/parsers/smhd.js
deleted file mode 100644
index 0c6f404..0000000
--- a/js/infrastructure/segment/isobmff/parsers/smhd.js
+++ /dev/null
@@ -1,29 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseSmhd(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-    p.readInt16('balance');
-    p.skip(2, 'reserved');
-    p.finalize();
-}
-
-export const smhdTooltip = {
-    smhd: {
-        name: 'Sound Media Header',
-        text: 'Contains header information specific to sound media.',
-        ref: 'ISO/IEC 14496-12, 8.4.5.3',
-    },
-    'smhd@balance': {
-        text: 'A fixed-point 8.8 number that places mono audio tracks in a stereo space (0 = center).',
-        ref: 'ISO/IEC 14496-12, 8.4.5.3.2',
-    },
-    'smhd@version': {
-        text: 'Version of this box, always 0.',
-        ref: 'ISO/IEC 14496-12, 8.4.5.3.2',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/sps.js b/js/infrastructure/segment/isobmff/parsers/sps.js
deleted file mode 100644
index a975648..0000000
--- a/js/infrastructure/segment/isobmff/parsers/sps.js
+++ /dev/null
@@ -1,152 +0,0 @@
-/**
- * A bit-level reader for parsing H.264 structures like SPS.
- */
-class BitReader {
-    constructor(buffer) {
-        this.buffer = buffer;
-        this.bytePosition = 0;
-        this.bitPosition = 0;
-    }
-
-    readBits(n) {
-        let result = 0;
-        for (let i = 0; i < n; i++) {
-            const byte = this.buffer[this.bytePosition];
-            const bit = (byte >> (7 - this.bitPosition)) & 1;
-            result = (result << 1) | bit;
-            this.bitPosition++;
-            if (this.bitPosition === 8) {
-                this.bitPosition = 0;
-                this.bytePosition++;
-            }
-        }
-        return result;
-    }
-
-    // Parses an unsigned exponential-Golomb coded integer.
-    readUE() {
-        let leadingZeroBits = 0;
-        while (
-            this.bytePosition < this.buffer.length &&
-            this.readBits(1) === 0
-        ) {
-            leadingZeroBits++;
-        }
-        if (leadingZeroBits === 0) {
-            return 0;
-        }
-        const codeNum = this.readBits(leadingZeroBits);
-        return (1 << leadingZeroBits) - 1 + codeNum;
-    }
-}
-
-/**
- * Parses a raw H.264 Sequence Parameter Set (SPS) NAL unit.
- * Skips over many fields to extract the most critical information for analysis:
- * profile, level, and resolution.
- * @param {Uint8Array} spsNalUnit - The raw bytes of the SPS NAL unit.
- * @returns {object | null} An object with parsed SPS info, or null on error.
- */
-export function parseSPS(spsNalUnit) {
-    if (spsNalUnit.length < 4) {
-        return null; // Not a valid SPS
-    }
-    const reader = new BitReader(spsNalUnit);
-    reader.readBits(8); // NAL header (forbidden_zero_bit, nal_ref_idc, nal_unit_type)
-
-    const profile_idc = reader.readBits(8);
-    reader.readBits(16); // constraint_set flags and reserved bits
-    const level_idc = reader.readBits(8);
-
-    reader.readUE(); // seq_parameter_set_id
-
-    if (
-        profile_idc === 100 ||
-        profile_idc === 110 ||
-        profile_idc === 122 ||
-        profile_idc === 244 ||
-        profile_idc === 44 ||
-        profile_idc === 83 ||
-        profile_idc === 86 ||
-        profile_idc === 118 ||
-        profile_idc === 128 ||
-        profile_idc === 138
-    ) {
-        const chroma_format_idc = reader.readUE();
-        if (chroma_format_idc === 3) {
-            reader.readBits(1); // separate_colour_plane_flag
-        }
-        reader.readUE(); // bit_depth_luma_minus8
-        reader.readUE(); // bit_depth_chroma_minus8
-        reader.readBits(1); // qpprime_y_zero_transform_bypass_flag
-        const seq_scaling_matrix_present_flag = reader.readBits(1);
-        if (seq_scaling_matrix_present_flag) {
-            const limit = chroma_format_idc !== 3 ? 8 : 12;
-            for (let i = 0; i < limit; i++) {
-                if (reader.readBits(1)) {
-                    // seq_scaling_list_present_flag[i]
-                    // This is complex, just skip for now
-                    return {
-                        profile_idc,
-                        level_idc,
-                        error: 'SPS with scaling matrix not fully parsed.',
-                    };
-                }
-            }
-        }
-    }
-
-    reader.readUE(); // log2_max_frame_num_minus4
-    const pic_order_cnt_type = reader.readUE();
-    if (pic_order_cnt_type === 0) {
-        reader.readUE(); // log2_max_pic_order_cnt_lsb_minus4
-    } else if (pic_order_cnt_type === 1) {
-        reader.readBits(1); // delta_pic_order_always_zero_flag
-        reader.readUE(); // offset_for_non_ref_pic (signed)
-        reader.readUE(); // offset_for_top_to_bottom_field (signed)
-        const num_ref_frames_in_pic_order_cnt_cycle = reader.readUE();
-        for (let i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {
-            reader.readUE(); // offset_for_ref_frame (signed)
-        }
-    }
-    reader.readUE(); // max_num_ref_frames
-    reader.readBits(1); // gaps_in_frame_num_value_allowed_flag
-
-    const pic_width_in_mbs_minus1 = reader.readUE();
-    const pic_height_in_map_units_minus1 = reader.readUE();
-    const frame_mbs_only_flag = reader.readBits(1);
-
-    const width = (pic_width_in_mbs_minus1 + 1) * 16;
-    let height =
-        (2 - frame_mbs_only_flag) * (pic_height_in_map_units_minus1 + 1) * 16;
-
-    if (frame_mbs_only_flag === 0) {
-        reader.readBits(1); // mb_adaptive_frame_field_flag
-    }
-
-    reader.readBits(1); // direct_8x8_inference_flag
-    const frame_cropping_flag = reader.readBits(1);
-    if (frame_cropping_flag) {
-        const frame_crop_left_offset = reader.readUE();
-        const frame_crop_right_offset = reader.readUE();
-        const frame_crop_top_offset = reader.readUE();
-        const frame_crop_bottom_offset = reader.readUE();
-
-        const cropUnitX = 1; // Assuming chroma_format_idc is not 4:2:2 or 4:4:4
-        const cropUnitY = 2 - frame_mbs_only_flag; // Y multiplier for field coding
-
-        const _croppedWidth =
-            width -
-            (frame_crop_left_offset + frame_crop_right_offset) * cropUnitX;
-        const croppedHeight =
-            height -
-            (frame_crop_top_offset + frame_crop_bottom_offset) * cropUnitY;
-        height = croppedHeight;
-    }
-
-    return {
-        profile_idc,
-        level_idc,
-        resolution: `${width}x${height}`,
-    };
-}
diff --git a/js/infrastructure/segment/isobmff/parsers/stco.js b/js/infrastructure/segment/isobmff/parsers/stco.js
deleted file mode 100644
index 5f106da..0000000
--- a/js/infrastructure/segment/isobmff/parsers/stco.js
+++ /dev/null
@@ -1,56 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseStco(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-
-    const entryCount = p.readUint32('entry_count');
-
-    if (entryCount !== null && entryCount > 0) {
-        const maxEntriesToShow = 10;
-        for (let i = 0; i < entryCount; i++) {
-            if (p.stopped) break;
-
-            if (i < maxEntriesToShow) {
-                p.readUint32(`chunk_offset_${i + 1}`);
-            } else {
-                p.offset += 4; // Skip 4 bytes for each remaining entry
-            }
-        }
-
-        if (entryCount > maxEntriesToShow) {
-            box.details['...more_entries'] = {
-                value: `${
-                    entryCount - maxEntriesToShow
-                } more entries not shown but parsed`,
-                offset: 0,
-                length: 0,
-            };
-        }
-    }
-    p.finalize();
-}
-
-export const stcoTooltip = {
-    stco: {
-        name: 'Chunk Offset',
-        text: 'Specifies the offset of each chunk into the file.',
-        ref: 'ISO/IEC 14496-12, 8.7.5',
-    },
-    'stco@version': {
-        text: 'Version of this box, always 0.',
-        ref: 'ISO/IEC 14496-12, 8.7.5.3',
-    },
-    'stco@entry_count': {
-        text: 'The number of entries in the chunk offset table.',
-        ref: 'ISO/IEC 14496-12, 8.7.5.3',
-    },
-    'stco@chunk_offset_1': {
-        text: 'The file offset of the first chunk.',
-        ref: 'ISO/IEC 14496-12, 8.7.5.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/stdp.js b/js/infrastructure/segment/isobmff/parsers/stdp.js
deleted file mode 100644
index f4f5bd0..0000000
--- a/js/infrastructure/segment/isobmff/parsers/stdp.js
+++ /dev/null
@@ -1,53 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'stdp' (Degradation Priority) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseStdp(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-
-    const sampleCount = (box.size - p.offset) / 2;
-    box.details['sample_count'] = {
-        value: sampleCount,
-        offset: 0,
-        length: 0,
-    };
-
-    if (sampleCount > 0) {
-        const maxEntriesToShow = 10;
-        for (let i = 0; i < sampleCount; i++) {
-            if (p.stopped) break;
-            if (i < maxEntriesToShow) {
-                p.readUint16(`priority_${i + 1}`);
-            } else {
-                p.offset += 2;
-            }
-        }
-
-        if (sampleCount > maxEntriesToShow) {
-            box.details['...more_entries'] = {
-                value: `${
-                    sampleCount - maxEntriesToShow
-                } more entries not shown but parsed`,
-                offset: 0,
-                length: 0,
-            };
-        }
-    }
-    p.finalize();
-}
-
-export const stdpTooltip = {
-    stdp: {
-        name: 'Degradation Priority',
-        text: 'Contains the degradation priority for each sample in the track.',
-        ref: 'ISO/IEC 14496-12, 8.5.3',
-    },
-    'stdp@priority_1': {
-        text: 'The priority for the first sample. Lower values are typically more important.',
-        ref: 'ISO/IEC 14496-12, 8.5.3.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/stpp.js b/js/infrastructure/segment/isobmff/parsers/stpp.js
deleted file mode 100644
index eba2d49..0000000
--- a/js/infrastructure/segment/isobmff/parsers/stpp.js
+++ /dev/null
@@ -1,69 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'mime' (MIME Type) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-function parseMime(box, view) {
-    const p = new BoxParser(box, view);
-    p.readNullTerminatedString('content_type');
-    if (p.offset < box.size) {
-        p.readNullTerminatedString('content_encoding');
-    }
-    p.finalize();
-}
-
-/**
- * Parses the 'stpp' (XML Subtitle Sample Entry) box. This is a container.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseStpp(box, view) {
-    const p = new BoxParser(box, view);
-
-    // From SampleEntry
-    p.skip(6, 'reserved_sample_entry');
-    p.readUint16('data_reference_index');
-
-    // stpp-specific fields
-    p.readNullTerminatedString('namespace');
-    p.readNullTerminatedString('schema_location');
-    p.readNullTerminatedString('auxiliary_mime_types');
-
-    // Children (like 'mime') are parsed by the main parser loop.
-}
-
-export const stppParsers = {
-    stpp: parseStpp,
-    mime: parseMime,
-};
-
-export const stppTooltip = {
-    stpp: {
-        name: 'XML Subtitle Sample Entry',
-        text: 'Defines the coding for an XML-based subtitle track, such as TTML/IMSC1.',
-        ref: 'ISO/IEC 14496-12, 12.4.3',
-    },
-    'stpp@namespace': {
-        text: 'A URI defining the namespace of the XML schema for the subtitle format.',
-        ref: 'ISO/IEC 14496-12, 12.4.3.2',
-    },
-    'stpp@schema_location': {
-        text: 'The location of the schema for the namespace.',
-        ref: 'ISO/IEC 14496-12, 12.4.3.2',
-    },
-    'stpp@auxiliary_mime_types': {
-        text: 'A list of MIME types for auxiliary data (e.g., images) referenced by the XML.',
-        ref: 'ISO/IEC 14496-12, 12.4.3.2',
-    },
-    mime: {
-        name: 'MIME Type Box',
-        text: 'Stores the MIME type of the subtitle document, including any codecs parameters.',
-        ref: 'ISO/IEC 14496-30',
-    },
-    'mime@content_type': {
-        text: 'The MIME type string, e.g., "application/ttml+xml;codecs=im1t".',
-        ref: 'ISO/IEC 14496-30',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/stsc.js b/js/infrastructure/segment/isobmff/parsers/stsc.js
deleted file mode 100644
index e77ad4b..0000000
--- a/js/infrastructure/segment/isobmff/parsers/stsc.js
+++ /dev/null
@@ -1,66 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseStsc(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-
-    const entryCount = p.readUint32('entry_count');
-
-    if (entryCount !== null && entryCount > 0) {
-        const maxEntriesToShow = 10;
-        for (let i = 0; i < entryCount; i++) {
-            if (p.stopped) break;
-            if (i < maxEntriesToShow) {
-                const entryPrefix = `entry_${i + 1}`;
-                p.readUint32(`${entryPrefix}_first_chunk`);
-                p.readUint32(`${entryPrefix}_samples_per_chunk`);
-                p.readUint32(`${entryPrefix}_sample_description_index`);
-            } else {
-                p.offset += 12; // Skip 12 bytes for each remaining entry
-            }
-        }
-
-        if (entryCount > maxEntriesToShow) {
-            box.details['...more_entries'] = {
-                value: `${
-                    entryCount - maxEntriesToShow
-                } more entries not shown but parsed`,
-                offset: 0,
-                length: 0,
-            };
-        }
-    }
-    p.finalize();
-}
-
-export const stscTooltip = {
-    stsc: {
-        name: 'Sample To Chunk',
-        text: 'Maps samples to chunks.',
-        ref: 'ISO/IEC 14496-12, 8.7.4',
-    },
-    'stsc@version': {
-        text: 'Version of this box, always 0.',
-        ref: 'ISO/IEC 14496-12, 8.7.4.3',
-    },
-    'stsc@entry_count': {
-        text: 'The number of entries in the sample-to-chunk table.',
-        ref: 'ISO/IEC 14496-12, 8.7.4.3',
-    },
-    'stsc@entry_1_first_chunk': {
-        text: 'The index of the first chunk in a run of chunks with the same properties.',
-        ref: 'ISO/IEC 14496-12, 8.7.4.3',
-    },
-    'stsc@entry_1_samples_per_chunk': {
-        text: 'The number of samples in each of these chunks.',
-        ref: 'ISO/IEC 14496-12, 8.7.4.3',
-    },
-    'stsc@entry_1_sample_description_index': {
-        text: 'The index of the sample description for the samples in this run.',
-        ref: 'ISO/IEC 14496-12, 8.7.4.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/stsd.js b/js/infrastructure/segment/isobmff/parsers/stsd.js
deleted file mode 100644
index 7ccda8a..0000000
--- a/js/infrastructure/segment/isobmff/parsers/stsd.js
+++ /dev/null
@@ -1,32 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'stsd' (Sample Description) box. This is a container for sample entries.
- * The sample entries themselves do not have standard box headers, so they are parsed specially.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseStsd(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-    p.readUint32('entry_count');
-    // This is a container box. The main parsing loop will handle the children (sample entries).
-    // We do not call p.finalize() here as that would incorrectly flag the children as "extra data".
-}
-
-export const stsdTooltip = {
-    stsd: {
-        name: 'Sample Description',
-        text: 'Stores information for decoding samples (codec type, initialization data). Contains one or more Sample Entry boxes.',
-        ref: 'ISO/IEC 14496-12, 8.5.2',
-    },
-    'stsd@entry_count': {
-        text: 'The number of sample entries that follow.',
-        ref: 'ISO/IEC 14496-12, 8.5.2.3',
-    },
-    'stsd@version': {
-        text: 'Version of this box, always 0.',
-        ref: 'ISO/IEC 14496-12, 8.5.2.3',
-    },
-    // Tooltips for common sample entries (avc1, mp4a) are handled via their own boxes now.
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/stss.js b/js/infrastructure/segment/isobmff/parsers/stss.js
deleted file mode 100644
index b70b69e..0000000
--- a/js/infrastructure/segment/isobmff/parsers/stss.js
+++ /dev/null
@@ -1,62 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'stss' (Sync Sample) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseStss(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-
-    const entryCount = p.readUint32('entry_count');
-
-    if (entryCount !== null && entryCount > 0) {
-        const sampleNumbers = [];
-        const maxEntriesToShow = 10;
-        for (let i = 0; i < entryCount; i++) {
-            if (p.stopped) break;
-
-            if (i < maxEntriesToShow) {
-                const sampleNum = p.readUint32(`sample_number_entry_${i + 1}`);
-                if (sampleNum !== null) {
-                    sampleNumbers.push(sampleNum);
-                    delete box.details[`sample_number_entry_${i + 1}`];
-                }
-            } else {
-                p.offset += 4;
-            }
-        }
-
-        if (entryCount > 0) {
-            box.details['sample_numbers'] = {
-                value:
-                    sampleNumbers.join(', ') +
-                    (entryCount > maxEntriesToShow
-                        ? `... (${
-                              entryCount - maxEntriesToShow
-                          } more entries not shown but parsed)`
-                        : ''),
-                offset: box.offset + p.offset, // This offset isn't quite right but the field is virtual
-                length: entryCount * 4,
-            };
-        }
-    }
-    p.finalize();
-}
-
-export const stssTooltip = {
-    stss: {
-        name: 'Sync Sample Box',
-        text: 'Provides a compact list of the sync samples (keyframes/random access points) in the track.',
-        ref: 'ISO/IEC 14496-12, 8.6.2',
-    },
-    'stss@entry_count': {
-        text: 'The number of sync samples in this track.',
-        ref: 'ISO/IEC 14496-12, 8.6.2.3',
-    },
-    'stss@sample_numbers': {
-        text: 'The sample numbers of the sync samples, in increasing order.',
-        ref: 'ISO/IEC 14496-12, 8.6.2.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/stsz.js b/js/infrastructure/segment/isobmff/parsers/stsz.js
deleted file mode 100644
index e0f9d4e..0000000
--- a/js/infrastructure/segment/isobmff/parsers/stsz.js
+++ /dev/null
@@ -1,60 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseStsz(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-
-    const sampleSize = p.readUint32('sample_size');
-    const sampleCount = p.readUint32('sample_count');
-
-    if (sampleSize === 0 && sampleCount !== null && sampleCount > 0) {
-        const maxEntriesToShow = 10;
-        for (let i = 0; i < sampleCount; i++) {
-            if (p.stopped) break;
-            if (i < maxEntriesToShow) {
-                p.readUint32(`entry_size_${i + 1}`);
-            } else {
-                p.offset += 4; // Skip 4 bytes for each remaining entry
-            }
-        }
-
-        if (sampleCount > maxEntriesToShow) {
-            box.details['...more_entries'] = {
-                value: `${
-                    sampleCount - maxEntriesToShow
-                } more entries not shown but parsed`,
-                offset: 0,
-                length: 0,
-            };
-        }
-    }
-    p.finalize();
-}
-
-export const stszTooltip = {
-    stsz: {
-        name: 'Sample Size',
-        text: 'Specifies the size of each sample.',
-        ref: 'ISO/IEC 14496-12, 8.7.3',
-    },
-    'stsz@version': {
-        text: 'Version of this box, always 0.',
-        ref: 'ISO/IEC 14496-12, 8.7.3.2.2',
-    },
-    'stsz@sample_size': {
-        text: 'Default sample size. If 0, sizes are in the entry table.',
-        ref: 'ISO/IEC 14496-12, 8.7.3.2.2',
-    },
-    'stsz@sample_count': {
-        text: 'The total number of samples in the track.',
-        ref: 'ISO/IEC 14496-12, 8.7.3.2.2',
-    },
-    'stsz@entry_size_1': {
-        text: 'The size of the first sample in bytes (if sample_size is 0).',
-        ref: 'ISO/IEC 14496-12, 8.7.3.2.2',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/stts.js b/js/infrastructure/segment/isobmff/parsers/stts.js
deleted file mode 100644
index e27c669..0000000
--- a/js/infrastructure/segment/isobmff/parsers/stts.js
+++ /dev/null
@@ -1,60 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseStts(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-
-    const entryCount = p.readUint32('entry_count');
-
-    if (entryCount !== null && entryCount > 0) {
-        const maxEntriesToShow = 10;
-        for (let i = 0; i < entryCount; i++) {
-            if (p.stopped) break;
-            if (i < maxEntriesToShow) {
-                p.readUint32(`sample_count_${i + 1}`);
-                p.readUint32(`sample_delta_${i + 1}`);
-            } else {
-                p.offset += 8; // Skip 8 bytes for each remaining entry
-            }
-        }
-
-        if (entryCount > maxEntriesToShow) {
-            box.details['...more_entries'] = {
-                value: `${
-                    entryCount - maxEntriesToShow
-                } more entries not shown but parsed`,
-                offset: 0,
-                length: 0,
-            };
-        }
-    }
-    p.finalize();
-}
-
-export const sttsTooltip = {
-    stts: {
-        name: 'Decoding Time to Sample',
-        text: 'Maps decoding times to sample numbers.',
-        ref: 'ISO/IEC 14496-12, 8.6.1.2',
-    },
-    'stts@version': {
-        text: 'Version of this box, always 0.',
-        ref: 'ISO/IEC 14496-12, 8.6.1.2.3',
-    },
-    'stts@entry_count': {
-        text: 'The number of entries in the time-to-sample table.',
-        ref: 'ISO/IEC 14496-12, 8.6.1.2.3',
-    },
-    'stts@sample_count_1': {
-        text: 'The number of consecutive samples with the same delta for the first table entry.',
-        ref: 'ISO/IEC 14496-12, 8.6.1.2.3',
-    },
-    'stts@sample_delta_1': {
-        text: 'The delta (duration) for each sample in this run for the first table entry.',
-        ref: 'ISO/IEC 14496-12, 8.6.1.2.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/stz2.js b/js/infrastructure/segment/isobmff/parsers/stz2.js
deleted file mode 100644
index d7a2716..0000000
--- a/js/infrastructure/segment/isobmff/parsers/stz2.js
+++ /dev/null
@@ -1,53 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'stz2' (Compact Sample Size) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseStz2(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-    p.skip(3, 'reserved');
-
-    const fieldSize = p.readUint8('field_size');
-    const sampleCount = p.readUint32('sample_count');
-
-    if (sampleCount !== null && sampleCount > 0) {
-        let entryValue;
-        if (fieldSize === 4) {
-            const byte = p.readUint8('entry_size_1_byte');
-            if (byte !== null) {
-                entryValue = `(nibbles) ${(byte >> 4) & 0x0f}, ${byte & 0x0f}`;
-            }
-        } else if (fieldSize === 8) {
-            entryValue = p.readUint8('entry_size_1');
-        } else if (fieldSize === 16) {
-            entryValue = p.readUint16('entry_size_1');
-        }
-        if (entryValue !== undefined) {
-            box.details['entry_size_1'].value = entryValue;
-        }
-    }
-    p.finalize();
-}
-
-export const stz2Tooltip = {
-    stz2: {
-        name: 'Compact Sample Size',
-        text: 'A compact version of the Sample Size Box for smaller, varying sample sizes.',
-        ref: 'ISO/IEC 14496-12, 8.7.3.3',
-    },
-    'stz2@field_size': {
-        text: 'The size in bits of each entry in the sample size table (4, 8, or 16).',
-        ref: 'ISO/IEC 14496-12, 8.7.3.3.2',
-    },
-    'stz2@sample_count': {
-        text: 'The total number of samples in the track.',
-        ref: 'ISO/IEC 14496-12, 8.7.3.3.2',
-    },
-    'stz2@entry_size_1': {
-        text: 'The size of the first sample, with the size determined by field_size.',
-        ref: 'ISO/IEC 14496-12, 8.7.3.3.2',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/subs.js b/js/infrastructure/segment/isobmff/parsers/subs.js
deleted file mode 100644
index d48d3cf..0000000
--- a/js/infrastructure/segment/isobmff/parsers/subs.js
+++ /dev/null
@@ -1,52 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'subs' (Sub-Sample Information) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseSubs(box, view) {
-    const p = new BoxParser(box, view);
-    const { version } = p.readVersionAndFlags();
-
-    if (version === null) {
-        p.finalize();
-        return;
-    }
-
-    const entryCount = p.readUint32('entry_count');
-
-    if (entryCount !== null && entryCount > 0) {
-        p.readUint32('entry_1_sample_delta');
-        const subsampleCount = p.readUint16('entry_1_subsample_count');
-
-        if (subsampleCount !== null && subsampleCount > 0) {
-            if (version === 1) {
-                p.readUint32('subsample_1_size');
-            } else {
-                p.readUint16('subsample_1_size');
-            }
-        }
-    }
-    p.finalize();
-}
-
-export const subsTooltip = {
-    subs: {
-        name: 'Sub-Sample Information',
-        text: 'Defines the size of sub-samples, often used in CENC to separate clear vs. encrypted parts of a sample.',
-        ref: 'ISO/IEC 14496-12, 8.7.7',
-    },
-    'subs@entry_count': {
-        text: 'The number of samples that have sub-sample information.',
-        ref: 'ISO/IEC 14496-12, 8.7.7.3',
-    },
-    'subs@entry_1_subsample_count': {
-        text: 'The number of sub-samples in the first sample.',
-        ref: 'ISO/IEC 14496-12, 8.7.7.3',
-    },
-    'subs@subsample_1_size': {
-        text: 'The size in bytes of the first sub-sample.',
-        ref: 'ISO/IEC 14496-12, 8.7.7.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/tenc.js b/js/infrastructure/segment/isobmff/parsers/tenc.js
deleted file mode 100644
index 7a7d332..0000000
--- a/js/infrastructure/segment/isobmff/parsers/tenc.js
+++ /dev/null
@@ -1,123 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'tenc' (Track Encryption) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseTenc(box, view) {
-    const p = new BoxParser(box, view);
-    const { version } = p.readVersionAndFlags();
-
-    if (version === null) {
-        p.finalize();
-        return;
-    }
-
-    if (version === 0) {
-        // CENC v3+ structure (version 0)
-        p.skip(2, 'reserved_1');
-        const isProtected = p.readUint8('default_isProtected');
-        const perSampleIVSize = p.readUint8('default_Per_Sample_IV_Size');
-
-        const kidBytes = [];
-        for (let i = 0; i < 16; i++) {
-            const byte = p.readUint8(`kid_byte_${i}`);
-            if (byte !== null) {
-                kidBytes.push(byte.toString(16).padStart(2, '0'));
-            } else {
-                p.finalize();
-                return;
-            }
-        }
-
-        const kidOffset = box.details['kid_byte_0']?.offset;
-        if (kidOffset !== undefined) {
-            box.details['default_KID'] = {
-                value: kidBytes.join(''),
-                offset: kidOffset,
-                length: 16,
-            };
-            for (let i = 0; i < 16; i++) delete box.details[`kid_byte_${i}`];
-        }
-
-        if (isProtected === 1 && perSampleIVSize === 0) {
-            const constIVSize = p.readUint8('default_constant_IV_size');
-            if (constIVSize !== null) {
-                p.skip(constIVSize, 'default_constant_IV');
-            }
-        }
-    } else if (version === 1) {
-        // Legacy CENC v1 structure (version 1)
-        p.skip(2, 'reserved_1');
-        const packedFields1 = p.readUint8('packed_fields_1');
-        if (packedFields1 !== null) {
-            delete box.details['packed_fields_1'];
-            box.details['default_crypt_byte_block'] = {
-                value: (packedFields1 >> 4) & 0x0f,
-                offset: p.box.offset + p.offset - 1,
-                length: 0.5,
-            };
-            box.details['default_skip_byte_block'] = {
-                value: packedFields1 & 0x0f,
-                offset: p.box.offset + p.offset - 1,
-                length: 0.5,
-            };
-        }
-        p.readUint8('default_isProtected');
-        p.readUint8('default_Per_Sample_IV_Size');
-
-        const kidBytes = [];
-        for (let i = 0; i < 16; i++) {
-            const byte = p.readUint8(`kid_byte_${i}`);
-            if (byte !== null) {
-                kidBytes.push(byte.toString(16).padStart(2, '0'));
-            } else {
-                p.finalize();
-                return;
-            }
-        }
-        const kidOffset = box.details['kid_byte_0']?.offset;
-        if (kidOffset !== undefined) {
-            box.details['default_KID'] = {
-                value: kidBytes.join(''),
-                offset: kidOffset,
-                length: 16,
-            };
-            for (let i = 0; i < 16; i++) delete box.details[`kid_byte_${i}`];
-        }
-    } else {
-        p.addIssue('warn', `Unsupported tenc version ${version}.`);
-        p.readRemainingBytes('unsupported_tenc_data');
-    }
-
-    p.finalize();
-}
-
-export const tencTooltip = {
-    tenc: {
-        name: 'Track Encryption Box',
-        text: 'Contains default encryption parameters for samples in a track, as defined by the Common Encryption (CENC) specification.',
-        ref: 'ISO/IEC 23001-7, 8.1',
-    },
-    'tenc@default_isProtected': {
-        text: 'Indicates if samples are encrypted by default (1) or not (0).',
-        ref: 'ISO/IEC 23001-7, 8.1',
-    },
-    'tenc@default_Per_Sample_IV_Size': {
-        text: 'The size in bytes of the Initialization Vector (IV) for each sample. If 0, a constant IV is used.',
-        ref: 'ISO/IEC 23001-7, 8.1',
-    },
-    'tenc@default_KID': {
-        text: 'The default Key ID for the samples in this track.',
-        ref: 'ISO/IEC 23001-7, 8.1',
-    },
-    'tenc@default_crypt_byte_block': {
-        text: '(Version 1) The number of encrypted blocks in a pattern.',
-        ref: 'ISO/IEC 23001-7 (First Edition)',
-    },
-    'tenc@default_skip_byte_block': {
-        text: '(Version 1) The number of clear blocks in a pattern.',
-        ref: 'ISO/IEC 23001-7 (First Edition)',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/tfdt.js b/js/infrastructure/segment/isobmff/parsers/tfdt.js
deleted file mode 100644
index 793feeb..0000000
--- a/js/infrastructure/segment/isobmff/parsers/tfdt.js
+++ /dev/null
@@ -1,38 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseTfdt(box, view) {
-    const p = new BoxParser(box, view);
-    const { version } = p.readVersionAndFlags();
-
-    if (version === null) {
-        p.finalize();
-        return;
-    }
-
-    if (version === 1) {
-        p.readBigUint64('baseMediaDecodeTime');
-    } else {
-        p.readUint32('baseMediaDecodeTime');
-    }
-    p.finalize();
-}
-
-export const tfdtTooltip = {
-    tfdt: {
-        name: 'Track Fragment Decode Time',
-        text: 'Provides the absolute decode time for the first sample.',
-        ref: 'ISO/IEC 14496-12, 8.8.12',
-    },
-    'tfdt@version': {
-        text: 'Version of this box (0 or 1). Affects the size of the decode time field.',
-        ref: 'ISO/IEC 14496-12, 8.8.12.3',
-    },
-    'tfdt@baseMediaDecodeTime': {
-        text: 'The absolute decode time, in media timescale units, for the first sample in this fragment.',
-        ref: 'ISO/IEC 14496-12, 8.8.12.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/tfhd.js b/js/infrastructure/segment/isobmff/parsers/tfhd.js
deleted file mode 100644
index 0e33ea0..0000000
--- a/js/infrastructure/segment/isobmff/parsers/tfhd.js
+++ /dev/null
@@ -1,87 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseTfhd(box, view) {
-    const p = new BoxParser(box, view);
-    const { flags } = p.readVersionAndFlags();
-
-    if (flags === null) {
-        p.finalize();
-        return;
-    }
-
-    p.readUint32('track_ID');
-
-    if (flags & 0x000001) {
-        // base_data_offset_present
-        p.readBigUint64('base_data_offset');
-    }
-    if (flags & 0x000002) {
-        // sample_description_index_present
-        p.readUint32('sample_description_index');
-    }
-    if (flags & 0x000008) {
-        // default_sample_duration_present
-        p.readUint32('default_sample_duration');
-    }
-    if (flags & 0x000010) {
-        // default_sample_size_present
-        p.readUint32('default_sample_size');
-    }
-    if (flags & 0x000020) {
-        // default_sample_flags_present
-        const defaultSampleFlags = p.readUint32('default_sample_flags_raw');
-        if (defaultSampleFlags !== null) {
-            box.details['default_sample_flags'] = {
-                value: `0x${defaultSampleFlags.toString(16)}`,
-                offset: box.details['default_sample_flags_raw'].offset,
-                length: 4,
-            };
-            delete box.details['default_sample_flags_raw'];
-        }
-    }
-    p.finalize();
-}
-
-export const tfhdTooltip = {
-    tfhd: {
-        name: 'Track Fragment Header',
-        text: 'Declares defaults for a track fragment.',
-        ref: 'ISO/IEC 14496-12, 8.8.7',
-    },
-    'tfhd@track_ID': {
-        text: 'The unique identifier of the track for this fragment.',
-        ref: 'ISO/IEC 14496-12, 8.8.7.2',
-    },
-    'tfhd@flags': {
-        text: 'A bitfield indicating which optional fields are present.',
-        ref: 'ISO/IEC 14496-12, 8.8.7.2',
-    },
-    'tfhd@base_data_offset': {
-        text: 'The base offset for data within the current mdat.',
-        ref: 'ISO/IEC 14496-12, 8.8.7.2',
-    },
-    'tfhd@sample_description_index': {
-        text: 'The index of the sample description for this fragment.',
-        ref: 'ISO/IEC 14496-12, 8.8.7.2',
-    },
-    'tfhd@version': {
-        text: 'Version of this box (0 or 1). Affects the size of the decode time field.',
-        ref: 'ISO/IEC 14496-12, 8.8.7.2',
-    },
-    'tfhd@default_sample_duration': {
-        text: 'Default duration of samples in this track fragment.',
-        ref: 'ISO/IEC 14496-12, 8.8.7.2',
-    },
-    'tfhd@default_sample_size': {
-        text: 'Default size of samples in this track fragment.',
-        ref: 'ISO/IEC 14496-12, 8.8.7.2',
-    },
-    'tfhd@default_sample_flags': {
-        text: 'Default flags for samples in this track fragment.',
-        ref: 'ISO/IEC 14496-12, 8.8.7.2',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/tfra.js b/js/infrastructure/segment/isobmff/parsers/tfra.js
deleted file mode 100644
index 07c5401..0000000
--- a/js/infrastructure/segment/isobmff/parsers/tfra.js
+++ /dev/null
@@ -1,71 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'tfra' (Track Fragment Random Access) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseTfra(box, view) {
-    const p = new BoxParser(box, view);
-    const { version } = p.readVersionAndFlags();
-
-    if (version === null) {
-        p.finalize();
-        return;
-    }
-
-    p.readUint32('track_ID');
-
-    const lengthSizes = p.readUint32('length_sizes_raw');
-    if (lengthSizes !== null) {
-        const length_size_of_traf_num = ((lengthSizes >> 4) & 0x03) + 1;
-        const length_size_of_trun_num = ((lengthSizes >> 2) & 0x03) + 1;
-        const length_size_of_sample_num = (lengthSizes & 0x03) + 1;
-        box.details['length_sizes'] = {
-            value: `traf=${length_size_of_traf_num}, trun=${length_size_of_trun_num}, sample=${length_size_of_sample_num}`,
-            offset: box.details['length_sizes_raw'].offset,
-            length: 4,
-        };
-        delete box.details['length_sizes_raw'];
-
-        const numberOfEntries = p.readUint32('number_of_entries');
-        if (numberOfEntries !== null && numberOfEntries > 0) {
-            if (version === 1) {
-                p.readBigUint64('entry_1_time');
-                p.readBigUint64('entry_1_moof_offset');
-            } else {
-                p.readUint32('entry_1_time');
-                p.readUint32('entry_1_moof_offset');
-            }
-            p.skip(length_size_of_traf_num, 'entry_1_traf_number');
-            p.skip(length_size_of_trun_num, 'entry_1_trun_number');
-            p.skip(length_size_of_sample_num, 'entry_1_sample_number');
-        }
-    }
-
-    p.finalize();
-}
-
-export const tfraTooltip = {
-    tfra: {
-        name: 'Track Fragment Random Access',
-        text: 'Contains a table mapping sync sample times to their `moof` box locations for a single track.',
-        ref: 'ISO/IEC 14496-12, 8.8.10',
-    },
-    'tfra@track_ID': {
-        text: 'The ID of the track this table refers to.',
-        ref: 'ISO/IEC 14496-12, 8.8.10.3',
-    },
-    'tfra@number_of_entries': {
-        text: 'The number of random access entries in the table.',
-        ref: 'ISO/IEC 14496-12, 8.8.10.3',
-    },
-    'tfra@entry_1_time': {
-        text: 'The presentation time of the sync sample in the first entry.',
-        ref: 'ISO/IEC 14496-12, 8.8.10.3',
-    },
-    'tfra@entry_1_moof_offset': {
-        text: 'The file offset of the `moof` box containing the sync sample for the first entry.',
-        ref: 'ISO/IEC 14496-12, 8.8.10.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/tkhd.js b/js/infrastructure/segment/isobmff/parsers/tkhd.js
deleted file mode 100644
index 516f2e4..0000000
--- a/js/infrastructure/segment/isobmff/parsers/tkhd.js
+++ /dev/null
@@ -1,163 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseTkhd(box, view) {
-    const p = new BoxParser(box, view);
-
-    const { version, flags } = p.readVersionAndFlags();
-
-    if (flags !== null) {
-        delete box.details['flags'];
-        const flagsOffset = box.details['version'].offset + 1;
-        box.details['track_enabled'] = {
-            value: (flags & 0x1) === 0x1,
-            offset: flagsOffset,
-            length: 3,
-        };
-        box.details['track_in_movie'] = {
-            value: (flags & 0x2) === 0x2,
-            offset: flagsOffset,
-            length: 3,
-        };
-        box.details['track_in_preview'] = {
-            value: (flags & 0x4) === 0x4,
-            offset: flagsOffset,
-            length: 3,
-        };
-    }
-
-    if (version === 1) {
-        p.readBigUint64('creation_time');
-        p.readBigUint64('modification_time');
-    } else {
-        p.readUint32('creation_time');
-        p.readUint32('modification_time');
-    }
-
-    p.readUint32('track_ID');
-    p.skip(4, 'reserved_1');
-
-    if (version === 1) {
-        p.readBigUint64('duration');
-    } else {
-        p.readUint32('duration');
-    }
-
-    p.skip(8, 'reserved_2');
-    p.readInt16('layer');
-    p.readInt16('alternate_group');
-
-    // Volume is a fixed-point 8.8 number
-    const volumeFixedPoint = p.readInt16('volume_fixed_point');
-    if (volumeFixedPoint !== null) {
-        box.details['volume'] = {
-            ...box.details['volume_fixed_point'],
-            value: (volumeFixedPoint / 256).toFixed(2),
-        };
-        delete box.details['volume_fixed_point'];
-    }
-
-    p.skip(2, 'reserved_3');
-
-    // Transformation Matrix (3x3)
-    const matrixValues = [];
-    for (let i = 0; i < 9; i++) {
-        matrixValues.push(p.readInt32(`matrix_val_${i}`));
-    }
-    // Consolidate matrix values into a single detail for cleaner display
-    const matrixOffset = box.details['matrix_val_0']?.offset;
-    if (matrixOffset !== undefined) {
-        box.details['matrix'] = {
-            value: `[${matrixValues.join(', ')}]`,
-            offset: matrixOffset,
-            length: 36,
-        };
-        for (let i = 0; i < 9; i++) delete box.details[`matrix_val_${i}`];
-    }
-
-    // Width and Height are fixed-point 16.16 numbers
-    const widthFixedPoint = p.readUint32('width_fixed_point');
-    if (widthFixedPoint !== null) {
-        box.details['width'] = {
-            ...box.details['width_fixed_point'],
-            value: (widthFixedPoint / 65536).toFixed(2),
-        };
-        delete box.details['width_fixed_point'];
-    }
-
-    const heightFixedPoint = p.readUint32('height_fixed_point');
-    if (heightFixedPoint !== null) {
-        box.details['height'] = {
-            ...box.details['height_fixed_point'],
-            value: (heightFixedPoint / 65536).toFixed(2),
-        };
-        delete box.details['height_fixed_point'];
-    }
-}
-
-export const tkhdTooltip = {
-    tkhd: {
-        name: 'Track Header',
-        text: 'Specifies characteristics of a single track.',
-        ref: 'ISO/IEC 14496-12, 8.3.2',
-    },
-    'tkhd@track_enabled': {
-        text: 'A flag indicating that the track is enabled. A disabled track is treated as if it were not present.',
-        ref: 'ISO/IEC 14496-12, 8.3.2.3',
-    },
-    'tkhd@track_in_movie': {
-        text: 'A flag indicating that the track is used in the presentation.',
-        ref: 'ISO/IEC 14496-12, 8.3.2.3',
-    },
-    'tkhd@track_in_preview': {
-        text: 'A flag indicating that the track is used when previewing the presentation.',
-        ref: 'ISO/IEC 14496-12, 8.3.2.3',
-    },
-    'tkhd@version': {
-        text: 'Version of this box (0 or 1). Affects the size of time and duration fields.',
-        ref: 'ISO/IEC 14496-12, 8.3.2.3',
-    },
-    'tkhd@creation_time': {
-        text: 'The creation time of this track (in seconds since midnight, Jan. 1, 1904, UTC).',
-        ref: 'ISO/IEC 14496-12, 8.3.2.3',
-    },
-    'tkhd@modification_time': {
-        text: 'The most recent time the track was modified.',
-        ref: 'ISO/IEC 14496-12, 8.3.2.3',
-    },
-    'tkhd@track_ID': {
-        text: 'A unique integer that identifies this track.',
-        ref: 'ISO/IEC 14496-12, 8.3.2.3',
-    },
-    'tkhd@duration': {
-        text: "The duration of this track in the movie's timescale.",
-        ref: 'ISO/IEC 14496-12, 8.3.2.3',
-    },
-    'tkhd@layer': {
-        text: 'Specifies the front-to-back ordering of video tracks; tracks with lower numbers are closer to the viewer.',
-        ref: 'ISO/IEC 14496-12, 8.3.2.3',
-    },
-    'tkhd@alternate_group': {
-        text: 'An integer that specifies a group of tracks that are alternatives to each other.',
-        ref: 'ISO/IEC 14496-12, 8.3.2.3',
-    },
-    'tkhd@volume': {
-        text: "For audio tracks, a fixed-point 8.8 number indicating the track's relative volume.",
-        ref: 'ISO/IEC 14496-12, 8.3.2.3',
-    },
-    'tkhd@matrix': {
-        text: 'A transformation matrix for the video in this track.',
-        ref: 'ISO/IEC 14496-12, 8.3.2.3',
-    },
-    'tkhd@width': {
-        text: 'The visual presentation width of the track as a fixed-point 16.16 number.',
-        ref: 'ISO/IEC 14496-12, 8.3.2.3',
-    },
-    'tkhd@height': {
-        text: 'The visual presentation height of the track as a fixed-point 16.16 number.',
-        ref: 'ISO/IEC 14496-12, 8.3.2.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/tref.js b/js/infrastructure/segment/isobmff/parsers/tref.js
deleted file mode 100644
index b31317d..0000000
--- a/js/infrastructure/segment/isobmff/parsers/tref.js
+++ /dev/null
@@ -1,72 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'tref' (Track Reference) container box.
- * This box does not have its own fields but contains other boxes
- * whose type indicates the reference type (e.g., 'hint', 'cdsc').
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseTref(box, view) {
-    // The tref box is a container. Its children are parsed by the main
-    // parseISOBMFF function. This function is a placeholder to define
-    // tooltip data and could be extended if tref itself had fields.
-}
-
-/**
- * A generic parser for boxes within a 'tref' box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-function parseTrefTypeBox(box, view) {
-    const p = new BoxParser(box, view);
-    const trackIDs = [];
-    while (p.offset < box.size) {
-        if (p.stopped) break;
-        const id = p.readUint32(`track_ID_${trackIDs.length + 1}`);
-        if (id !== null) {
-            trackIDs.push(id);
-        } else {
-            break; // Stop if a read fails
-        }
-    }
-    box.details['track_IDs'] = {
-        value: trackIDs.join(', '),
-        offset: box.offset + box.headerSize,
-        length: box.size - box.headerSize,
-    };
-    p.finalize();
-}
-
-// We need to export parsers for the known tref child boxes
-export const trefTypeParsers = {
-    hint: parseTrefTypeBox,
-    cdsc: parseTrefTypeBox,
-    font: parseTrefTypeBox,
-    hind: parseTrefTypeBox,
-    vdep: parseTrefTypeBox,
-    vplx: parseTrefTypeBox,
-    subt: parseTrefTypeBox,
-};
-
-export const trefTooltip = {
-    tref: {
-        name: 'Track Reference',
-        text: 'A container box that defines references from this track to other tracks in the presentation.',
-        ref: 'ISO/IEC 14496-12, 8.3.3',
-    },
-    hint: {
-        name: 'Hint Track Reference',
-        text: 'Indicates that the referenced track(s) contain the original media for this hint track.',
-        ref: 'ISO/IEC 14496-12, 8.3.3.3',
-    },
-    cdsc: {
-        name: 'Content Description Reference',
-        text: 'Indicates that this track describes the referenced track (e.g., a timed metadata track).',
-        ref: 'ISO/IEC 14496-12, 8.3.3.3',
-    },
-    'hint@track_IDs': {
-        text: 'A list of track IDs that this track references.',
-        ref: 'ISO/IEC 14496-12, 8.3.3.2',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/trep.js b/js/infrastructure/segment/isobmff/parsers/trep.js
deleted file mode 100644
index 3b78fe9..0000000
--- a/js/infrastructure/segment/isobmff/parsers/trep.js
+++ /dev/null
@@ -1,25 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * Parses the 'trep' (Track Extension Properties) box.
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseTrep(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-    p.readUint32('track_id');
-    // This is a container box, children are parsed by the main parser.
-}
-
-export const trepTooltip = {
-    trep: {
-        name: 'Track Extension Properties',
-        text: 'A container box that documents characteristics of the track in subsequent movie fragments.',
-        ref: 'ISO/IEC 14496-12, 8.8.15',
-    },
-    'trep@track_id': {
-        text: 'The ID of the track for which these extension properties are provided.',
-        ref: 'ISO/IEC 14496-12, 8.8.15.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/trex.js b/js/infrastructure/segment/isobmff/parsers/trex.js
deleted file mode 100644
index 5c88591..0000000
--- a/js/infrastructure/segment/isobmff/parsers/trex.js
+++ /dev/null
@@ -1,53 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseTrex(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-    p.readUint32('track_ID');
-    p.readUint32('default_sample_description_index');
-    p.readUint32('default_sample_duration');
-    p.readUint32('default_sample_size');
-
-    const defaultSampleFlags = p.readUint32('default_sample_flags_raw');
-    if (defaultSampleFlags !== null) {
-        box.details['default_sample_flags'] = {
-            value: `0x${defaultSampleFlags.toString(16)}`,
-            offset: box.details['default_sample_flags_raw'].offset,
-            length: 4,
-        };
-        delete box.details['default_sample_flags_raw'];
-    }
-    p.finalize();
-}
-
-export const trexTooltip = {
-    trex: {
-        name: 'Track Extends',
-        text: 'Sets default values for samples in fragments.',
-        ref: 'ISO/IEC 14496-12, 8.8.3',
-    },
-    'trex@track_ID': {
-        text: 'The track ID to which these defaults apply.',
-        ref: 'ISO/IEC 14496-12, 8.8.3.3',
-    },
-    'trex@default_sample_description_index': {
-        text: 'The default sample description index for samples in fragments.',
-        ref: 'ISO/IEC 14496-12, 8.8.3.3',
-    },
-    'trex@default_sample_duration': {
-        text: 'The default duration for samples in fragments.',
-        ref: 'ISO/IEC 14496-12, 8.8.3.3',
-    },
-    'trex@default_sample_size': {
-        text: 'The default size for samples in fragments.',
-        ref: 'ISO/IEC 14496-12, 8.8.3.3',
-    },
-    'trex@default_sample_flags': {
-        text: 'The default flags for samples in fragments.',
-        ref: 'ISO/IEC 14496-12, 8.8.3.3',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/trun.js b/js/infrastructure/segment/isobmff/parsers/trun.js
deleted file mode 100644
index 8ac84fd..0000000
--- a/js/infrastructure/segment/isobmff/parsers/trun.js
+++ /dev/null
@@ -1,105 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseTrun(box, view) {
-    const p = new BoxParser(box, view);
-    const { version, flags } = p.readVersionAndFlags();
-
-    if (flags === null) {
-        p.finalize();
-        return;
-    }
-
-    const sampleCount = p.readUint32('sample_count');
-    box.samples = []; // Initialize samples array
-
-    if (flags & 0x000001) {
-        // data_offset_present
-        p.readInt32('data_offset');
-    }
-    let firstSampleFlags = null;
-    if (flags & 0x000004) {
-        // first_sample_flags_present
-        const firstSampleFlagsDword = p.readUint32('first_sample_flags_dword');
-        if (firstSampleFlagsDword !== null) {
-            delete box.details['first_sample_flags_dword'];
-            firstSampleFlags = firstSampleFlagsDword;
-            box.details['first_sample_flags'] = {
-                value: `0x${firstSampleFlags.toString(16)}`,
-                offset:
-                    box.details['first_sample_flags_dword']?.offset ||
-                    p.box.offset + p.offset - 4,
-                length: 4,
-            };
-        }
-    }
-
-    if (sampleCount !== null) {
-        for (let i = 0; i < sampleCount; i++) {
-            if (p.stopped) break;
-
-            const sample = {};
-            if (flags & 0x000100) {
-                sample.duration = p.view.getUint32(p.offset);
-                p.offset += 4;
-            }
-            if (flags & 0x000200) {
-                sample.size = p.view.getUint32(p.offset);
-                p.offset += 4;
-            }
-            if (flags & 0x000400) {
-                sample.flags = p.view.getUint32(p.offset);
-                p.offset += 4;
-            }
-            if (i === 0 && firstSampleFlags !== null) {
-                sample.flags = firstSampleFlags;
-            }
-
-            if (flags & 0x000800) {
-                if (version === 0) {
-                    sample.compositionTimeOffset = p.view.getUint32(p.offset);
-                } else {
-                    sample.compositionTimeOffset = p.view.getInt32(p.offset);
-                }
-                p.offset += 4;
-            }
-            box.samples.push(sample);
-        }
-    }
-    p.finalize();
-}
-
-export const trunTooltip = {
-    trun: {
-        name: 'Track Run',
-        text: 'Contains timing, size, and flags for a run of samples.',
-        ref: 'ISO/IEC 14496-12, 8.8.8',
-    },
-    'trun@version': {
-        text: 'Version of this box (0 or 1). Affects signed/unsigned composition time.',
-        ref: 'ISO/IEC 14496-12, 8.8.8.2',
-    },
-    'trun@flags': {
-        text: 'A bitfield indicating which optional per-sample fields are present.',
-        ref: 'ISO/IEC 14496-12, 8.8.8.2',
-    },
-    'trun@sample_count': {
-        text: 'The number of samples in this run.',
-        ref: 'ISO/IEC 14496-12, 8.8.8.3',
-    },
-    'trun@data_offset': {
-        text: 'An optional offset added to the base_data_offset.',
-        ref: 'ISO/IEC 14496-12, 8.8.8.3',
-    },
-    'trun@first_sample_flags': {
-        text: 'Flags for the first sample, overriding the default.',
-        ref: 'ISO/IEC 14496-12, 8.8.8.3',
-    },
-    'trun@sample_1_details': {
-        text: 'A summary of the per-sample data fields for the first sample in this run.',
-        ref: 'ISO/IEC 14496-12, 8.8.8.2',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/parsers/vmhd.js b/js/infrastructure/segment/isobmff/parsers/vmhd.js
deleted file mode 100644
index 9a5cc2a..0000000
--- a/js/infrastructure/segment/isobmff/parsers/vmhd.js
+++ /dev/null
@@ -1,52 +0,0 @@
-import { BoxParser } from '../utils.js';
-
-/**
- * @param {import('../parser.js').Box} box
- * @param {DataView} view
- */
-export function parseVmhd(box, view) {
-    const p = new BoxParser(box, view);
-    p.readVersionAndFlags();
-    p.readUint16('graphicsmode');
-
-    const r = p.readUint16('opcolor_r');
-    const g = p.readUint16('opcolor_g');
-    const b = p.readUint16('opcolor_b');
-
-    if (r !== null && g !== null && b !== null) {
-        const baseOffset = box.details['opcolor_r'].offset;
-        delete box.details['opcolor_r'];
-        delete box.details['opcolor_g'];
-        delete box.details['opcolor_b'];
-        box.details['opcolor'] = {
-            value: `R:${r}, G:${g}, B:${b}`,
-            offset: baseOffset,
-            length: 6,
-        };
-    }
-    p.finalize();
-}
-
-export const vmhdTooltip = {
-    vmhd: {
-        name: 'Video Media Header',
-        text: 'Contains header information specific to video media.',
-        ref: 'ISO/IEC 14496-12, 8.4.5.2',
-    },
-    'vmhd@version': {
-        text: 'Version of this box, always 0.',
-        ref: 'ISO/IEC 14496-12, 8.4.5.2.2',
-    },
-    'vmhd@flags': {
-        text: 'A bitmask of flags, should have the low bit set to 1.',
-        ref: 'ISO/IEC 14496-12, 8.4.5.2',
-    },
-    'vmhd@graphicsmode': {
-        text: 'Specifies a composition mode for this video track.',
-        ref: 'ISO/IEC 14496-12, 8.4.5.2.2',
-    },
-    'vmhd@opcolor': {
-        text: 'A set of RGB color values available for use by graphics modes.',
-        ref: 'ISO/IEC 14496-12, 8.4.5.2.2',
-    },
-};
diff --git a/js/infrastructure/segment/isobmff/utils.js b/js/infrastructure/segment/isobmff/utils.js
deleted file mode 100644
index 5fa0e88..0000000
--- a/js/infrastructure/segment/isobmff/utils.js
+++ /dev/null
@@ -1,292 +0,0 @@
-/**
- * A utility class to simplify the parsing of ISOBMFF boxes.
- * It abstracts away manual offset tracking and provides a declarative API
- * for reading fields, automatically populating the box's `details` object.
- */
-export class BoxParser {
-    /**
-     * @param {import('./parser.js').Box} box The box object to be populated.
-     * @param {DataView} view The DataView for the box's content, starting from the beginning of the box.
-     */
-    constructor(box, view) {
-        this.box = box;
-        this.view = view;
-        // The view is already scoped to the box, so the parser starts after the header.
-        this.offset = box.headerSize;
-        this.stopped = false;
-    }
-
-    /**
-     * Adds an issue to the current box's issue list.
-     * @param {'error' | 'warn'} type
-     * @param {string} message
-     */
-    addIssue(type, message) {
-        if (!this.box.issues) {
-            this.box.issues = [];
-        }
-        this.box.issues.push({ type, message });
-    }
-
-    /**
-     * @param {number} length The number of bytes required for the next operation.
-     * @returns {boolean}
-     */
-    checkBounds(length) {
-        if (this.stopped) return false;
-        if (this.offset + length > this.view.byteLength) {
-            this.addIssue(
-                'error',
-                `Read attempt for ${length} bytes at offset ${this.offset} would exceed box '${this.box.type}' size of ${this.view.byteLength}. The box is truncated.`
-            );
-            this.stopped = true;
-            return false;
-        }
-        return true;
-    }
-
-    /**
-     * Reads a 32-bit unsigned integer.
-     * @param {string} fieldName The name of the field to store in `box.details`.
-     * @returns {number | null} The parsed value.
-     */
-    readUint32(fieldName) {
-        if (!this.checkBounds(4)) return null;
-        const value = this.view.getUint32(this.offset);
-        this.box.details[fieldName] = {
-            value,
-            offset: this.box.offset + this.offset,
-            length: 4,
-        };
-        this.offset += 4;
-        return value;
-    }
-
-    /**
-     * Reads a 64-bit unsigned integer.
-     * @param {string} fieldName The name of the field to store in `box.details`.
-     * @returns {bigint | null} The parsed value.
-     */
-    readBigUint64(fieldName) {
-        if (!this.checkBounds(8)) return null;
-        const value = this.view.getBigUint64(this.offset);
-        this.box.details[fieldName] = {
-            value: Number(value),
-            offset: this.box.offset + this.offset,
-            length: 8,
-        };
-        this.offset += 8;
-        return value;
-    }
-
-    /**
-     * Reads a 64-bit signed integer.
-     * @param {string} fieldName The name of the field to store in `box.details`.
-     * @returns {bigint | null} The parsed value.
-     */
-    readBigInt64(fieldName) {
-        if (!this.checkBounds(8)) return null;
-        const value = this.view.getBigInt64(this.offset);
-        this.box.details[fieldName] = {
-            value: Number(value),
-            offset: this.box.offset + this.offset,
-            length: 8,
-        };
-        this.offset += 8;
-        return value;
-    }
-
-    /**
-     * Reads an 8-bit unsigned integer.
-     * @param {string} fieldName The name of the field to store in `box.details`.
-     * @returns {number | null} The parsed value.
-     */
-    readUint8(fieldName) {
-        if (!this.checkBounds(1)) return null;
-        const value = this.view.getUint8(this.offset);
-        this.box.details[fieldName] = {
-            value,
-            offset: this.box.offset + this.offset,
-            length: 1,
-        };
-        this.offset += 1;
-        return value;
-    }
-
-    /**
-     * Reads a 16-bit unsigned integer.
-     * @param {string} fieldName The name of the field to store in `box.details`.
-     * @returns {number | null} The parsed value.
-     */
-    readUint16(fieldName) {
-        if (!this.checkBounds(2)) return null;
-        const value = this.view.getUint16(this.offset);
-        this.box.details[fieldName] = {
-            value,
-            offset: this.box.offset + this.offset,
-            length: 2,
-        };
-        this.offset += 2;
-        return value;
-    }
-
-    /**
-     * Reads a 16-bit signed integer.
-     * @param {string} fieldName The name of the field to store in `box.details`.
-     * @returns {number | null} The parsed value.
-     */
-    readInt16(fieldName) {
-        if (!this.checkBounds(2)) return null;
-        const value = this.view.getInt16(this.offset);
-        this.box.details[fieldName] = {
-            value,
-            offset: this.box.offset + this.offset,
-            length: 2,
-        };
-        this.offset += 2;
-        return value;
-    }
-
-    /**
-     * Reads a 32-bit integer.
-     * @param {string} fieldName The name of the field to store in `box.details`.
-     * @returns {number | null} The parsed value.
-     */
-    readInt32(fieldName) {
-        if (!this.checkBounds(4)) return null;
-        const value = this.view.getInt32(this.offset);
-        this.box.details[fieldName] = {
-            value,
-            offset: this.box.offset + this.offset,
-            length: 4,
-        };
-        this.offset += 4;
-        return value;
-    }
-
-    /**
-     * Reads a string of a given length.
-     * @param {number} length The number of bytes to read.
-     * @param {string} fieldName The name of the field.
-     * @returns {string | null}
-     */
-    readString(length, fieldName) {
-        if (!this.checkBounds(length)) return null;
-        const bytes = new Uint8Array(
-            this.view.buffer,
-            this.view.byteOffset + this.offset,
-            length
-        );
-        const value = String.fromCharCode(...bytes);
-        this.box.details[fieldName] = {
-            value,
-            offset: this.box.offset + this.offset,
-            length,
-        };
-        this.offset += length;
-        return value;
-    }
-
-    /**
-     * Reads a null-terminated string (C-style string).
-     * @param {string} fieldName The name of the field.
-     * @returns {string | null}
-     */
-    readNullTerminatedString(fieldName) {
-        if (this.stopped) return null;
-        const startOffset = this.offset;
-        let endOffset = startOffset;
-        while (
-            endOffset < this.view.byteLength &&
-            this.view.getUint8(endOffset) !== 0
-        ) {
-            endOffset++;
-        }
-        const stringBytes = new Uint8Array(
-            this.view.buffer,
-            this.view.byteOffset + startOffset,
-            endOffset - startOffset
-        );
-        const value = new TextDecoder('utf-8').decode(stringBytes);
-        const totalLength = endOffset - startOffset + 1; // Include null terminator
-
-        this.box.details[fieldName] = {
-            value,
-            offset: this.box.offset + startOffset,
-            length: totalLength,
-        };
-        this.offset += totalLength;
-        return value;
-    }
-
-    /**
-     * Reads version (1 byte) and flags (3 bytes) from a full box header.
-     * @returns {{version: number | null, flags: number | null}}
-     */
-    readVersionAndFlags() {
-        if (!this.checkBounds(4)) return { version: null, flags: null };
-        const versionAndFlags = this.view.getUint32(this.offset);
-        const version = versionAndFlags >> 24;
-        const flags = versionAndFlags & 0x00ffffff;
-
-        this.box.details['version'] = {
-            value: version,
-            offset: this.box.offset + this.offset,
-            length: 1,
-        };
-        this.box.details['flags'] = {
-            value: `0x${flags.toString(16).padStart(6, '0')}`,
-            offset: this.box.offset + this.offset,
-            length: 4, // Visually it's one field
-        };
-        this.offset += 4;
-
-        return { version, flags };
-    }
-
-    /**
-     * Reads the remaining bytes of the box into a field.
-     * @param {string} fieldName
-     */
-    readRemainingBytes(fieldName) {
-        if (this.stopped) return;
-        const remainingBytes = this.view.byteLength - this.offset;
-        if (remainingBytes > 0) {
-            this.box.details[fieldName] = {
-                value: `... ${remainingBytes} bytes of data ...`,
-                offset: this.box.offset + this.offset,
-                length: remainingBytes,
-            };
-            this.offset += remainingBytes;
-        }
-    }
-
-    /**
-     * Skips a specified number of bytes.
-     * @param {number} byteCount The number of bytes to skip.
-     * @param {string} fieldName The name for the reserved/skipped field.
-     */
-    skip(byteCount, fieldName = 'reserved') {
-        if (!this.checkBounds(byteCount)) return;
-        this.box.details[fieldName] = {
-            value: `${byteCount} bytes`,
-            offset: this.box.offset + this.offset,
-            length: byteCount,
-        };
-        this.offset += byteCount;
-    }
-
-    /**
-     * Checks for any unparsed bytes at the end of the box and logs an issue if found.
-     */
-    finalize() {
-        if (this.stopped) return;
-        const remainingBytes = this.view.byteLength - this.offset;
-        if (remainingBytes > 0) {
-            this.addIssue(
-                'warn',
-                `${remainingBytes} extra unparsed bytes found at the end of box '${this.box.type}'.`
-            );
-        }
-    }
-}
diff --git a/js/infrastructure/segment/ts/engine.js b/js/infrastructure/segment/ts/engine.js
deleted file mode 100644
index 19111bb..0000000
--- a/js/infrastructure/segment/ts/engine.js
+++ /dev/null
@@ -1,304 +0,0 @@
-import { parseHeader } from './parsers/header.js';
-import { parseAdaptationField } from './parsers/adaptation-field.js';
-import { parsePsiSection } from './parsers/psi-section.js';
-import { parsePatPayload } from './parsers/pat.js';
-import { parsePmtPayload } from './parsers/pmt.js';
-import { parseCatPayload } from './parsers/cat.js';
-import { parseTsdtPayload } from './parsers/tsdt.js';
-import { parsePrivateSectionPayload } from './parsers/private-section.js';
-import { parseIpmpPayload } from './parsers/ipmp.js';
-import { parsePesHeader } from './parsers/pes.js';
-import { parseDsmccPayload } from './parsers/dsm-cc.js';
-
-const TS_PACKET_SIZE = 188;
-const SYNC_BYTE = 0x47;
-
-// From Table 2-34 of the specification.
-
-export function parseTsSegment(buffer) {
-    const packets = [];
-    const summary = {
-        totalPackets: 0,
-        errors: [],
-        pmtPids: new Set(),
-        privateSectionPids: new Set(),
-        dsmccPids: new Set(),
-        programMap: {},
-        pcrPid: null,
-        pcrList: [],
-        continuityCounters: {},
-        tsdt: null,
-        ipmp: null,
-    };
-    const dataView = new DataView(buffer);
-
-    // 1st Pass: Find all PMT PIDs from all PATs in the segment and initialize programMap
-    for (
-        let offset = 0;
-        offset + TS_PACKET_SIZE <= buffer.byteLength;
-        offset += TS_PACKET_SIZE
-    ) {
-        if (dataView.getUint8(offset) !== SYNC_BYTE) continue;
-        const header = parseHeader(new DataView(buffer, offset, 4), offset);
-        if (
-            header.pid.value === 0x00 &&
-            header.payload_unit_start_indicator.value
-        ) {
-            let afLength =
-                header.adaptation_field_control.value & 2
-                    ? dataView.getUint8(offset + 4) + 1
-                    : 0;
-            let payloadOffset = offset + 4 + afLength;
-            if (payloadOffset >= offset + TS_PACKET_SIZE) continue;
-
-            const pointerField = dataView.getUint8(payloadOffset);
-            let sectionStart = payloadOffset + 1 + pointerField;
-            if (sectionStart >= offset + TS_PACKET_SIZE) continue;
-
-            const sectionView = new DataView(
-                buffer,
-                sectionStart,
-                offset + TS_PACKET_SIZE - sectionStart
-            );
-            const { header: sectionHeader, payload: patPayloadView } =
-                parsePsiSection(sectionView);
-            if (sectionHeader.table_id === '0x00' && !sectionHeader.error) {
-                // PAT
-                const patPayloadOffset =
-                    sectionStart +
-                    (sectionHeader.section_syntax_indicator ? 8 : 3);
-                const pat = parsePatPayload(patPayloadView, patPayloadOffset);
-                pat.programs.forEach((p) => {
-                    if (p.type === 'program') {
-                        const pmtPid = p.program_map_PID.value;
-                        summary.pmtPids.add(pmtPid);
-                        if (!summary.programMap[pmtPid]) {
-                            summary.programMap[pmtPid] = {
-                                programNumber: p.program_number.value,
-                                streams: {},
-                            };
-                        }
-                    }
-                });
-            }
-        }
-    }
-
-    // 2nd Pass: Full parse of each packet
-    for (
-        let offset = 0;
-        offset + TS_PACKET_SIZE <= buffer.byteLength;
-        offset += TS_PACKET_SIZE
-    ) {
-        if (dataView.getUint8(offset) !== SYNC_BYTE) continue;
-        summary.totalPackets++;
-
-        const packetView = new DataView(buffer, offset, TS_PACKET_SIZE);
-        const header = parseHeader(packetView, offset);
-        const pid = header.pid.value;
-        const packet = {
-            offset,
-            pid,
-            header,
-            adaptationField: null,
-            payloadType: 'Data',
-            pes: null,
-            psi: null,
-            fieldOffsets: { header: { offset, length: 4 } },
-        };
-
-        if (pid !== 0x1fff) {
-            if (!summary.continuityCounters[pid]) {
-                summary.continuityCounters[pid] = [];
-            }
-            summary.continuityCounters[pid].push({
-                cc: header.continuity_counter.value,
-                offset: offset,
-                hasPayload: (header.adaptation_field_control.value & 1) !== 0,
-            });
-        }
-
-        let payloadStart = 4;
-        if (header.adaptation_field_control.value & 2) {
-            const afLength = dataView.getUint8(offset + payloadStart);
-            const afView = new DataView(
-                buffer,
-                offset + payloadStart,
-                afLength + 1
-            );
-            packet.adaptationField = parseAdaptationField(
-                afView,
-                offset + payloadStart
-            );
-            packet.fieldOffsets.adaptationField = {
-                offset: offset + payloadStart,
-                length: afLength + 1,
-            };
-            if (packet.adaptationField.pcr) {
-                summary.pcrList.push({
-                    pcr: BigInt(packet.adaptationField.pcr.value),
-                    offset: offset,
-                });
-            }
-            payloadStart += afLength + 1;
-        }
-
-        const hasPayload = (header.adaptation_field_control.value & 1) !== 0;
-        if (!hasPayload || payloadStart >= TS_PACKET_SIZE) {
-            packets.push(packet);
-            continue;
-        }
-
-        const isPsiPid =
-            pid === 0x00 || // PAT
-            pid === 0x01 || // CAT
-            pid === 0x02 || // TSDT
-            pid === 0x03 || // IPMP-CIT
-            summary.pmtPids.has(pid) ||
-            summary.privateSectionPids.has(pid);
-
-        if (isPsiPid && header.payload_unit_start_indicator.value) {
-            const pointerField = dataView.getUint8(offset + payloadStart);
-            packet.fieldOffsets.pointerField = {
-                offset: offset + payloadStart,
-                length: pointerField + 1,
-            };
-            const sectionStartOffset = payloadStart + 1 + pointerField;
-
-            if (sectionStartOffset < TS_PACKET_SIZE) {
-                const sectionView = new DataView(
-                    buffer,
-                    offset + sectionStartOffset,
-                    TS_PACKET_SIZE - sectionStartOffset
-                );
-                const {
-                    header: sectionHeader,
-                    payload,
-                    isValid,
-                    crc,
-                } = parsePsiSection(sectionView);
-
-                const payloadBaseOffset =
-                    offset +
-                    sectionStartOffset +
-                    (sectionHeader.section_syntax_indicator ? 8 : 3);
-                let parsedPayload;
-
-                if (pid === 0x00) {
-                    parsedPayload = parsePatPayload(payload, payloadBaseOffset);
-                    packet.payloadType = 'PSI (PAT)';
-                } else if (pid === 0x01) {
-                    parsedPayload = parseCatPayload(payload, payloadBaseOffset);
-                    packet.payloadType = 'PSI (CAT)';
-                } else if (pid === 0x02) {
-                    parsedPayload = parseTsdtPayload(
-                        payload,
-                        payloadBaseOffset
-                    );
-                    packet.payloadType = 'PSI (TSDT)';
-                    summary.tsdt = parsedPayload;
-                } else if (pid === 0x03) {
-                    parsedPayload = parseIpmpPayload(
-                        payload,
-                        payloadBaseOffset
-                    );
-                    packet.payloadType = 'PSI (IPMP-CIT)';
-                    summary.ipmp = parsedPayload;
-                } else if (summary.pmtPids.has(pid)) {
-                    const tableIdNum = parseInt(sectionHeader.table_id, 16);
-                    if (tableIdNum === 0x02) {
-                        parsedPayload = parsePmtPayload(
-                            payload,
-                            payloadBaseOffset
-                        );
-                        packet.payloadType = 'PSI (PMT)';
-                        // ... (update summary.programMap logic)
-                    } else if (tableIdNum >= 0x40 && tableIdNum <= 0xfe) {
-                        parsedPayload = parsePrivateSectionPayload(
-                            payload,
-                            payloadBaseOffset,
-                            sectionHeader.section_syntax_indicator,
-                            sectionHeader.section_length
-                        );
-                        packet.payloadType = 'PSI (Private Section)';
-                    }
-                }
-
-                if (parsedPayload) {
-                    parsedPayload.isValid = isValid;
-                    parsedPayload.header = sectionHeader;
-                    parsedPayload.crc = crc;
-                    packet.psi = parsedPayload;
-                }
-            }
-        } else if (!isPsiPid) {
-            // Potentially a PES packet or just data
-            const pesView = new DataView(
-                buffer,
-                offset + payloadStart,
-                TS_PACKET_SIZE - payloadStart
-            );
-            if (
-                header.payload_unit_start_indicator.value &&
-                pesView.byteLength >= 6 &&
-                pesView.getUint32(0) >>> 8 === 0x000001
-            ) {
-                packet.payloadType = 'PES';
-                const pesResult = parsePesHeader(
-                    pesView,
-                    offset + payloadStart
-                );
-                if (pesResult) {
-                    packet.pes = pesResult.header;
-                    const headerLength = pesResult.payloadOffset;
-                    packet.fieldOffsets.pesHeader = {
-                        offset: offset + payloadStart,
-                        length: headerLength,
-                    };
-
-                    const streamId = parseInt(packet.pes.stream_id.value, 16);
-                    if (streamId === 0xf2) {
-                        // DSM-CC stream
-                        packet.payloadType = 'PES (DSM-CC)';
-                        const dsmccPayloadOffset = payloadStart + headerLength;
-                        if (
-                            offset + dsmccPayloadOffset <
-                            offset + TS_PACKET_SIZE
-                        ) {
-                            const dsmccView = new DataView(
-                                buffer,
-                                offset + dsmccPayloadOffset,
-                                offset +
-                                    TS_PACKET_SIZE -
-                                    (offset + dsmccPayloadOffset)
-                            );
-                            packet.pes.payload = parseDsmccPayload(
-                                dsmccView,
-                                offset + dsmccPayloadOffset
-                            );
-                        }
-                    }
-                }
-            }
-        }
-        packets.push(packet);
-    }
-
-    // Final pass to label elementary stream packets
-    const pidToStreamType = {};
-    Object.values(summary.programMap).forEach((program) => {
-        Object.entries(program.streams).forEach(([pid, type]) => {
-            pidToStreamType[pid] = type;
-        });
-    });
-
-    packets.forEach((packet) => {
-        if (pidToStreamType[packet.pid] && packet.payloadType === 'Data') {
-            packet.payloadType = pidToStreamType[packet.pid];
-        } else if (packet.pid === 0x1fff) {
-            packet.payloadType = 'Null Packet';
-        }
-    });
-
-    return { format: 'ts', data: { summary, packets } };
-}
diff --git a/js/infrastructure/segment/ts/index.js b/js/infrastructure/segment/ts/index.js
deleted file mode 100644
index 4352413..0000000
--- a/js/infrastructure/segment/ts/index.js
+++ /dev/null
@@ -1,43 +0,0 @@
-import { parseTsSegment } from './engine.js';
-import { tooltipData } from './parsers/descriptors/tooltips.js';
-
-/**
- * The main entry point for parsing an MPEG-2 Transport Stream segment.
- * @param {ArrayBuffer} buffer - The raw segment data.
- * @returns {object} The parsed segment data structure.
- */
-export function parse(buffer) {
-    try {
-        return parseTsSegment(buffer);
-    } catch (e) {
-        console.error('Error parsing TS segment:', e);
-        return {
-            format: 'ts',
-            error: e.message,
-            data: {
-                summary: {
-                    totalPackets: 0,
-                    errors: [e.message],
-                    pmtPids: new Set(),
-                    privateSectionPids: new Set(),
-                    dsmccPids: new Set(),
-                    programMap: {},
-                    pcrPid: null,
-                    pcrList: [],
-                    continuityCounters: {},
-                    tsdt: null,
-                    ipmp: null,
-                },
-                packets: [],
-            },
-        };
-    }
-}
-
-/**
- * Retrieves the tooltip data for all implemented TS elements.
- * @returns {object}
- */
-export function getTooltipData() {
-    return tooltipData;
-}
diff --git a/js/infrastructure/segment/ts/parsers/adaptation-field.js b/js/infrastructure/segment/ts/parsers/adaptation-field.js
deleted file mode 100644
index f6bce58..0000000
--- a/js/infrastructure/segment/ts/parsers/adaptation-field.js
+++ /dev/null
@@ -1,299 +0,0 @@
-// Parsers the Adaptation Field of a TS packet.
-// This includes decoding the AF length, flags (e.g., PCR_flag,
-// random_access_indicator), and optional fields like the
-// Program Clock Reference (PCR).
-import { parseAfDescriptors } from './descriptors/af-descriptors.js';
-
-/**
- * Parses the 42-bit Program Clock Reference (PCR/OPCR).
- * @param {DataView} view - A DataView starting at the 6-byte PCR field.
- * @returns {BigInt} The combined 42-bit value.
- */
-function parsePcr(view) {
-    const byte0 = view.getUint8(0);
-    const byte1 = view.getUint8(1);
-    const byte2 = view.getUint8(2);
-    const byte3 = view.getUint8(3);
-    const byte4 = view.getUint8(4);
-    const byte5 = view.getUint8(5);
-
-    const base =
-        (BigInt(byte0) << 25n) |
-        (BigInt(byte1) << 17n) |
-        (BigInt(byte2) << 9n) |
-        (BigInt(byte3) << 1n) |
-        BigInt(byte4 >> 7);
-
-    const extension = ((BigInt(byte4) & 1n) << 8n) | BigInt(byte5);
-
-    return base * 300n + extension;
-}
-
-/**
- * Parses the 33-bit DTS_next_AU timestamp.
- * @param {DataView} view - A DataView starting at the 5-byte field.
- * @returns {BigInt} The 33-bit DTS value.
- */
-function parseNextDts(view) {
-    const high = (view.getUint8(0) & 0x0e) >> 1;
-    const mid = view.getUint16(1) & 0x7fff;
-    const low = view.getUint16(3) & 0x7fff;
-    return (BigInt(high) << 30n) | (BigInt(mid) << 15n) | BigInt(low);
-}
-
-/**
- * Parses the variable-length Adaptation Field.
- * @param {DataView} view - A DataView pointing to the start of the Adaptation Field.
- * @param {number} baseOffset - The offset of the AF within the entire segment.
- * @returns {object | null} The parsed AF data, or null if empty.
- */
-export function parseAdaptationField(view, baseOffset) {
-    const length = view.getUint8(0);
-    if (length === 0)
-        return { length: { value: 0, offset: baseOffset, length: 1 } };
-    if (length > view.byteLength - 1)
-        return {
-            length: { value: length, offset: baseOffset, length: 1 },
-            error: 'Invalid length',
-        };
-
-    const flags = view.getUint8(1);
-    const af = {
-        length: { value: length, offset: baseOffset, length: 1 },
-        discontinuity_indicator: {
-            value: (flags >> 7) & 1,
-            offset: baseOffset + 1,
-            length: 0.125,
-        },
-        random_access_indicator: {
-            value: (flags >> 6) & 1,
-            offset: baseOffset + 1,
-            length: 0.125,
-        },
-        elementary_stream_priority_indicator: {
-            value: (flags >> 5) & 1,
-            offset: baseOffset + 1,
-            length: 0.125,
-        },
-        pcr_flag: {
-            value: (flags >> 4) & 1,
-            offset: baseOffset + 1,
-            length: 0.125,
-        },
-        opcr_flag: {
-            value: (flags >> 3) & 1,
-            offset: baseOffset + 1,
-            length: 0.125,
-        },
-        splicing_point_flag: {
-            value: (flags >> 2) & 1,
-            offset: baseOffset + 1,
-            length: 0.125,
-        },
-        transport_private_data_flag: {
-            value: (flags >> 1) & 1,
-            offset: baseOffset + 1,
-            length: 0.125,
-        },
-        adaptation_field_extension_flag: {
-            value: flags & 1,
-            offset: baseOffset + 1,
-            length: 0.125,
-        },
-    };
-
-    let currentOffset = 2;
-
-    if (af.pcr_flag.value) {
-        if (currentOffset + 6 <= length + 1) {
-            af.pcr = {
-                value: parsePcr(
-                    new DataView(view.buffer, view.byteOffset + currentOffset)
-                ).toString(),
-                offset: baseOffset + currentOffset,
-                length: 6,
-            };
-            currentOffset += 6;
-        }
-    }
-
-    if (af.opcr_flag.value) {
-        if (currentOffset + 6 <= length + 1) {
-            af.opcr = {
-                value: parsePcr(
-                    new DataView(view.buffer, view.byteOffset + currentOffset)
-                ).toString(),
-                offset: baseOffset + currentOffset,
-                length: 6,
-            };
-            currentOffset += 6;
-        }
-    }
-
-    if (af.splicing_point_flag.value) {
-        if (currentOffset + 1 <= length + 1) {
-            af.splice_countdown = {
-                value: view.getInt8(currentOffset),
-                offset: baseOffset + currentOffset,
-                length: 1,
-            };
-            currentOffset += 1;
-        }
-    }
-
-    if (af.transport_private_data_flag.value) {
-        if (currentOffset + 1 <= length + 1) {
-            const len = view.getUint8(currentOffset);
-            af.private_data_length = {
-                value: len,
-                offset: baseOffset + currentOffset,
-                length: 1,
-            };
-            currentOffset += 1 + len;
-        }
-    }
-
-    if (af.adaptation_field_extension_flag.value) {
-        if (currentOffset + 1 <= length + 1) {
-            const ext_len = view.getUint8(currentOffset);
-            const ext_flags = view.getUint8(currentOffset + 1);
-            const af_descriptor_not_present_flag = (ext_flags >> 4) & 1;
-            af.extension = {
-                length: {
-                    value: ext_len,
-                    offset: baseOffset + currentOffset,
-                    length: 1,
-                },
-                ltw_flag: {
-                    value: (ext_flags >> 7) & 1,
-                    offset: baseOffset + currentOffset + 1,
-                    length: 0.125,
-                },
-                piecewise_rate_flag: {
-                    value: (ext_flags >> 6) & 1,
-                    offset: baseOffset + currentOffset + 1,
-                    length: 0.125,
-                },
-                seamless_splice_flag: {
-                    value: (ext_flags >> 5) & 1,
-                    offset: baseOffset + currentOffset + 1,
-                    length: 0.125,
-                },
-                af_descriptor_not_present_flag: {
-                    value: af_descriptor_not_present_flag,
-                    offset: baseOffset + currentOffset + 1,
-                    length: 0.125,
-                },
-            };
-            let extOffset = currentOffset + 2;
-            if (
-                af.extension.ltw_flag.value &&
-                extOffset + 2 <= currentOffset + 1 + ext_len
-            ) {
-                const ltw_word = view.getUint16(extOffset);
-                af.extension.ltw_valid_flag = {
-                    value: (ltw_word >> 15) & 1,
-                    offset: baseOffset + extOffset,
-                    length: 0.125,
-                };
-                af.extension.ltw_offset = {
-                    value: ltw_word & 0x7fff,
-                    offset: baseOffset + extOffset,
-                    length: 1.875,
-                };
-                extOffset += 2;
-            }
-            if (
-                af.extension.piecewise_rate_flag.value &&
-                extOffset + 3 <= currentOffset + 1 + ext_len
-            ) {
-                const rate_dword = view.getUint32(extOffset - 1) & 0x3fffff00; // Aligned to byte boundary
-                af.extension.piecewise_rate = {
-                    value: rate_dword >> 8,
-                    offset: baseOffset + extOffset,
-                    length: 3,
-                };
-                extOffset += 3;
-            }
-            if (
-                af.extension.seamless_splice_flag.value &&
-                extOffset + 5 <= currentOffset + 1 + ext_len
-            ) {
-                af.extension.splice_type = {
-                    value: view.getUint8(extOffset) >> 4,
-                    offset: baseOffset + extOffset,
-                    length: 0.5,
-                };
-                af.extension.DTS_next_AU = {
-                    value: parseNextDts(
-                        new DataView(view.buffer, view.byteOffset + extOffset)
-                    ).toString(),
-                    offset: baseOffset + extOffset,
-                    length: 5,
-                };
-                extOffset += 5;
-            }
-
-            const remainingBytesInExt = currentOffset + 1 + ext_len - extOffset;
-            if (remainingBytesInExt > 0) {
-                if (af_descriptor_not_present_flag === 0) {
-                    const descriptorView = new DataView(
-                        view.buffer,
-                        view.byteOffset + extOffset,
-                        remainingBytesInExt
-                    );
-                    af.extension.af_descriptors = parseAfDescriptors(
-                        descriptorView,
-                        baseOffset + extOffset
-                    );
-                } else {
-                    af.extension.reserved_bytes = {
-                        value: `${remainingBytesInExt} reserved bytes`,
-                        offset: baseOffset + extOffset,
-                        length: remainingBytesInExt,
-                    };
-                }
-            }
-
-            currentOffset += 1 + ext_len;
-        }
-    }
-
-    const stuffingBytes = length + 1 - currentOffset;
-    if (stuffingBytes > 0) {
-        af.stuffing_bytes = {
-            value: stuffingBytes,
-            offset: baseOffset + currentOffset,
-            length: stuffingBytes,
-        };
-    }
-
-    return af;
-}
-
-export const adaptationFieldTooltipData = {
-    'AF@length': {
-        text: 'The total length of the adaptation field in bytes, not including this length byte itself.',
-        ref: 'Clause 2.4.3.5',
-    },
-    'AF@discontinuity_indicator': {
-        text: 'Set to 1 if a discontinuity is indicated for the current TS packet.',
-        ref: 'Clause 2.4.3.5',
-    },
-    'AF@random_access_indicator': {
-        text: 'Set to 1 if the stream may be randomly accessed at this point.',
-        ref: 'Clause 2.4.3.5',
-    },
-    'AF@pcr_flag': {
-        text: 'Set to 1 if the adaptation field contains a Program Clock Reference (PCR).',
-        ref: 'Clause 2.4.3.5',
-    },
-    'AF@pcr': {
-        text: "Program Clock Reference. A timestamp used to synchronize the decoder's clock.",
-        ref: 'Clause 2.4.3.5',
-    },
-    'AF@af_descriptor_not_present_flag': {
-        text: 'If set to 0, signals the presence of one or more descriptors in the adaptation field extension.',
-        ref: 'Clause 2.4.3.4',
-    },
-};
diff --git a/js/infrastructure/segment/ts/parsers/cat.js b/js/infrastructure/segment/ts/parsers/cat.js
deleted file mode 100644
index 7bd8b67..0000000
--- a/js/infrastructure/segment/ts/parsers/cat.js
+++ /dev/null
@@ -1,25 +0,0 @@
-import { parseDescriptors } from './descriptors/index.js';
-
-// Parses the payload of a Conditional Access Table (CAT) section.
-// Extracts descriptors that provide information about CA systems,
-// such as the location of Entitlement Management Message (EMM) streams.
-
-/**
- * Parses descriptors from a CAT section payload.
- * @param {DataView} view - A DataView of the CAT section's payload.
- * @param {number} baseOffset - The offset of the payload within the segment.
- * @returns {object} An object containing parsed CAT information.
- */
-export function parseCatPayload(view, baseOffset) {
-    return {
-        type: 'CAT',
-        descriptors: parseDescriptors(view, baseOffset),
-    };
-}
-
-export const catTooltipData = {
-    CAT: {
-        text: 'Conditional Access Table. Provides information on CA systems used in the multiplex.',
-        ref: 'Clause 2.4.4.7',
-    },
-};
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/af-descriptors.js b/js/infrastructure/segment/ts/parsers/descriptors/af-descriptors.js
deleted file mode 100644
index 806b7ec..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/af-descriptors.js
+++ /dev/null
@@ -1,70 +0,0 @@
-import { parseTimelineDescriptor } from './timeline.js';
-
-/**
- * Parses a loop of Adaptation Field (AF) descriptors.
- * @param {DataView} view - A DataView starting at the beginning of the descriptor loop.
- * @param {number} baseOffset - The offset of the loop within the segment.
- * @returns {object[]} An array of parsed AF descriptor objects.
- */
-export function parseAfDescriptors(view, baseOffset) {
-    const descriptors = [];
-    let offset = 0;
-
-    while (offset < view.byteLength) {
-        if (offset + 2 > view.byteLength) break;
-        const tag = view.getUint8(offset);
-        const length = view.getUint8(offset + 1);
-
-        if (offset + 2 + length > view.byteLength) break;
-
-        const payloadView = new DataView(
-            view.buffer,
-            view.byteOffset + offset + 2,
-            length
-        );
-        const payloadOffset = baseOffset + offset + 2;
-
-        let details;
-        let name = 'Unknown/Private AF Descriptor';
-
-        // Tag values from Table U.3
-        switch (tag) {
-            case 0x04:
-                name = 'Timeline Descriptor';
-                details = parseTimelineDescriptor(payloadView, payloadOffset);
-                break;
-            // Stubs for other AF descriptors
-            case 0x05:
-                name = 'Location Descriptor';
-                break;
-            case 0x06:
-                name = 'BaseURL Descriptor';
-                break;
-            case 0x0b:
-                name = 'Boundary Descriptor';
-                break;
-            case 0x0c:
-                name = 'Labeling Descriptor';
-                break;
-        }
-
-        if (!details) {
-            details = {
-                data: {
-                    value: `${length} bytes`,
-                    offset: payloadOffset,
-                    length,
-                },
-            };
-        }
-
-        descriptors.push({
-            tag,
-            length,
-            name,
-            details,
-        });
-        offset += 2 + length;
-    }
-    return descriptors;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/af-tooltips.js b/js/infrastructure/segment/ts/parsers/descriptors/af-tooltips.js
deleted file mode 100644
index 7eeb634..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/af-tooltips.js
+++ /dev/null
@@ -1,58 +0,0 @@
-export const afDescriptorTooltipData = {
-    Timeline_descriptor: {
-        text: 'Carries timing information to synchronize external data with the media timeline.',
-        ref: 'ISO/IEC 13818-1, Annex U.3.6',
-    },
-    'Timeline_descriptor@has_timestamp': {
-        text: 'Indicates if a media timestamp is present and its size (0: no, 1: 32-bit, 2: 64-bit).',
-        ref: 'Table U.8',
-    },
-    'Timeline_descriptor@has_ntp': {
-        text: 'If set to 1, indicates an NTP timestamp is present.',
-        ref: 'Table U.8',
-    },
-    'Timeline_descriptor@has_ptp': {
-        text: 'If set to 1, indicates a PTP timestamp is present.',
-        ref: 'Table U.8',
-    },
-    'Timeline_descriptor@has_timecode': {
-        text: 'Indicates if a frame timecode is present and its type.',
-        ref: 'Table U.8',
-    },
-    'Timeline_descriptor@force_reload': {
-        text: 'If set to 1, indicates that prior add-on descriptions may be obsolete and should be reloaded.',
-        ref: 'Table U.8',
-    },
-    'Timeline_descriptor@paused': {
-        text: 'If set to 1, indicates that the timeline identified by timeline_id is currently paused.',
-        ref: 'Table U.8',
-    },
-    'Timeline_descriptor@discontinuity': {
-        text: 'If set to 1, indicates that a discontinuity has occurred in the timeline.',
-        ref: 'Table U.8',
-    },
-    'Timeline_descriptor@timeline_id': {
-        text: 'Identifies the active timeline to which this timing information applies.',
-        ref: 'Table U.8',
-    },
-    'Timeline_descriptor@timescale': {
-        text: 'The number of time units that pass in one second for the media_timestamp.',
-        ref: 'Table U.8',
-    },
-    'Timeline_descriptor@media_timestamp': {
-        text: 'The media time in `timescale` units corresponding to the associated PTS value.',
-        ref: 'Table U.8',
-    },
-    'Timeline_descriptor@ntp_timestamp': {
-        text: 'A 64-bit NTP timestamp corresponding to the associated PTS value.',
-        ref: 'Table U.8',
-    },
-    'Timeline_descriptor@ptp_timestamp': {
-        text: 'An 80-bit PTP timestamp.',
-        ref: 'Table U.8',
-    },
-    'Timeline_descriptor@timecode_data': {
-        text: 'Timecode data structures.',
-        ref: 'Table U.8',
-    },
-};
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/audio-stream.js b/js/infrastructure/segment/ts/parsers/descriptors/audio-stream.js
deleted file mode 100644
index 4cfca81..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/audio-stream.js
+++ /dev/null
@@ -1,24 +0,0 @@
-/**
- * Parses a single Audio Stream Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.4 & Table 2-48
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed audio descriptor.
- */
-export function parseAudioStreamDescriptor(view, baseOffset) {
-    const byte1 = view.getUint8(0);
-    return {
-        free_format_flag: {
-            value: (byte1 >> 7) & 1,
-            offset: baseOffset,
-            length: 0.125,
-        },
-        ID: { value: (byte1 >> 6) & 1, offset: baseOffset, length: 0.125 },
-        layer: { value: (byte1 >> 4) & 3, offset: baseOffset, length: 0.25 },
-        variable_rate_audio_indicator: {
-            value: (byte1 >> 3) & 1,
-            offset: baseOffset,
-            length: 0.125,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/auxiliary-video-stream.js b/js/infrastructure/segment/ts/parsers/descriptors/auxiliary-video-stream.js
deleted file mode 100644
index 45dacc9..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/auxiliary-video-stream.js
+++ /dev/null
@@ -1,24 +0,0 @@
-/**
- * Parses an Auxiliary Video Stream Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.74 & Table 2-96
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseAuxiliaryVideoStreamDescriptor(view, baseOffset) {
-    const aux_video_codedstreamtype = view.getUint8(0);
-    const si_rbsp_length = view.byteLength - 1;
-
-    return {
-        aux_video_codedstreamtype: {
-            value: `0x${aux_video_codedstreamtype.toString(16).padStart(2, '0')}`,
-            offset: baseOffset,
-            length: 1,
-        },
-        si_rbsp_data: {
-            value: `${si_rbsp_length} bytes of Supplemental Information RBSP`,
-            offset: baseOffset + 1,
-            length: si_rbsp_length,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/avc-timing-hrd.js b/js/infrastructure/segment/ts/parsers/descriptors/avc-timing-hrd.js
deleted file mode 100644
index aa681b6..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/avc-timing-hrd.js
+++ /dev/null
@@ -1,86 +0,0 @@
-/**
- * Parses an AVC Timing and HRD Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.66 & Table 2-91
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed AVC timing and HRD descriptor.
- */
-export function parseAvcTimingAndHrdDescriptor(view, baseOffset) {
-    const byte1 = view.getUint8(0);
-    const hrd_management_valid_flag = (byte1 >> 7) & 1;
-    const picture_and_timing_info_present = byte1 & 1;
-
-    const details = {
-        hrd_management_valid_flag: {
-            value: hrd_management_valid_flag,
-            offset: baseOffset,
-            length: 0.125,
-        },
-        picture_and_timing_info_present: {
-            value: picture_and_timing_info_present,
-            offset: baseOffset,
-            length: 0.125,
-        },
-    };
-
-    let currentOffset = 1;
-
-    if (picture_and_timing_info_present) {
-        if (view.byteLength > currentOffset) {
-            const byte2 = view.getUint8(currentOffset);
-            const ninety_kHz_flag = (byte2 >> 7) & 1;
-            details['90kHz_flag'] = {
-                value: ninety_kHz_flag,
-                offset: baseOffset + currentOffset,
-                length: 0.125,
-            };
-            currentOffset += 1;
-
-            if (ninety_kHz_flag === 0) {
-                if (view.byteLength >= currentOffset + 8) {
-                    details.N = {
-                        value: view.getUint32(currentOffset),
-                        offset: baseOffset + currentOffset,
-                        length: 4,
-                    };
-                    details.K = {
-                        value: view.getUint32(currentOffset + 4),
-                        offset: baseOffset + currentOffset + 4,
-                        length: 4,
-                    };
-                    currentOffset += 8;
-                }
-            }
-
-            if (view.byteLength >= currentOffset + 4) {
-                details.num_units_in_tick = {
-                    value: view.getUint32(currentOffset),
-                    offset: baseOffset + currentOffset,
-                    length: 4,
-                };
-                currentOffset += 4;
-            }
-        }
-    }
-
-    if (view.byteLength > currentOffset) {
-        const byte_last = view.getUint8(currentOffset);
-        details.fixed_frame_rate_flag = {
-            value: (byte_last >> 7) & 1,
-            offset: baseOffset + currentOffset,
-            length: 0.125,
-        };
-        details.temporal_poc_flag = {
-            value: (byte_last >> 6) & 1,
-            offset: baseOffset + currentOffset,
-            length: 0.125,
-        };
-        details.picture_to_display_conversion_flag = {
-            value: (byte_last >> 5) & 1,
-            offset: baseOffset + currentOffset,
-            length: 0.125,
-        };
-    }
-
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/avc-video.js b/js/infrastructure/segment/ts/parsers/descriptors/avc-video.js
deleted file mode 100644
index 3f84fb2..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/avc-video.js
+++ /dev/null
@@ -1,69 +0,0 @@
-/**
- * Parses a single AVC Video Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.64 & Table 2-92
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed AVC video descriptor.
- */
-export function parseAvcVideoDescriptor(view, baseOffset) {
-    const byte1 = view.getUint8(1); // constraint flags byte
-    const byte2 = view.getUint8(3); // presence flags byte
-    return {
-        profile_idc: { value: view.getUint8(0), offset: baseOffset, length: 1 },
-        constraint_set0_flag: {
-            value: (byte1 >> 7) & 1,
-            offset: baseOffset + 1,
-            length: 0.125,
-        },
-        constraint_set1_flag: {
-            value: (byte1 >> 6) & 1,
-            offset: baseOffset + 1,
-            length: 0.125,
-        },
-        constraint_set2_flag: {
-            value: (byte1 >> 5) & 1,
-            offset: baseOffset + 1,
-            length: 0.125,
-        },
-        constraint_set3_flag: {
-            value: (byte1 >> 4) & 1,
-            offset: baseOffset + 1,
-            length: 0.125,
-        },
-        constraint_set4_flag: {
-            value: (byte1 >> 3) & 1,
-            offset: baseOffset + 1,
-            length: 0.125,
-        },
-        constraint_set5_flag: {
-            value: (byte1 >> 2) & 1,
-            offset: baseOffset + 1,
-            length: 0.125,
-        },
-        AVC_compatible_flags: {
-            value: byte1 & 3,
-            offset: baseOffset + 1,
-            length: 0.25,
-        },
-        level_idc: {
-            value: view.getUint8(2),
-            offset: baseOffset + 2,
-            length: 1,
-        },
-        AVC_still_present: {
-            value: (byte2 >> 7) & 1,
-            offset: baseOffset + 3,
-            length: 0.125,
-        },
-        AVC_24_hour_picture_flag: {
-            value: (byte2 >> 6) & 1,
-            offset: baseOffset + 3,
-            length: 0.125,
-        },
-        Frame_Packing_SEI_not_present_flag: {
-            value: (byte2 >> 5) & 1,
-            offset: baseOffset + 3,
-            length: 0.125,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/ca.js b/js/infrastructure/segment/ts/parsers/descriptors/ca.js
deleted file mode 100644
index a4b2ec1..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/ca.js
+++ /dev/null
@@ -1,37 +0,0 @@
-/**
- * Parses a single CA Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.16 & Table 2-61
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed CA descriptor with byte-level metadata.
- */
-export function parseCaDescriptor(view, baseOffset) {
-    const ca_system_ID = view.getUint16(0);
-    const ca_PID = view.getUint16(2) & 0x1fff;
-    const privateDataBytes = [];
-    for (let i = 4; i < view.byteLength; i++) {
-        privateDataBytes.push(view.getUint8(i).toString(16).padStart(2, '0'));
-    }
-
-    return {
-        ca_system_ID: {
-            value: `0x${ca_system_ID.toString(16).padStart(4, '0')}`,
-            offset: baseOffset,
-            length: 2,
-        },
-        reserved: {
-            value: (view.getUint8(2) >> 5) & 0x07,
-            offset: baseOffset + 2,
-            length: 0.375,
-        },
-        ca_PID: { value: ca_PID, offset: baseOffset + 2, length: 1.625 },
-        private_data: {
-            value:
-                privateDataBytes.length > 0
-                    ? privateDataBytes.join(' ')
-                    : 'none',
-            offset: baseOffset + 4,
-            length: privateDataBytes.length,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/content-labeling.js b/js/infrastructure/segment/ts/parsers/descriptors/content-labeling.js
deleted file mode 100644
index 36a381c..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/content-labeling.js
+++ /dev/null
@@ -1,118 +0,0 @@
-/**
- * Parses a Content Labelling Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.56 & Table 2-81
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseContentLabelingDescriptor(view, baseOffset) {
-    const details = {};
-    let offset = 0;
-
-    details.metadata_application_format = {
-        value: view.getUint16(offset),
-        offset: baseOffset + offset,
-        length: 2,
-    };
-    offset += 2;
-
-    if (details.metadata_application_format.value === 0xffff) {
-        details.metadata_application_format_identifier = {
-            value: view.getUint32(offset),
-            offset: baseOffset + offset,
-            length: 4,
-        };
-        offset += 4;
-    }
-
-    const flags = view.getUint8(offset);
-    details.content_reference_id_record_flag = {
-        value: (flags >> 7) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.content_time_base_indicator = {
-        value: (flags >> 3) & 0x0f,
-        offset: baseOffset + offset,
-        length: 0.5,
-    };
-    offset += 1;
-
-    if (details.content_reference_id_record_flag.value) {
-        const len = view.getUint8(offset);
-        details.content_reference_id_record_length = {
-            value: len,
-            offset: baseOffset + offset,
-            length: 1,
-        };
-        offset += 1;
-        details.content_reference_id_record = {
-            value: `${len} bytes`,
-            offset: baseOffset + offset,
-            length: len,
-        };
-        offset += len;
-    }
-
-    if (
-        details.content_time_base_indicator.value === 1 ||
-        details.content_time_base_indicator.value === 2
-    ) {
-        const val1_high = view.getUint8(offset) & 0x1;
-        const val1_low = view.getUint32(offset + 1);
-        details.content_time_base_value = {
-            value: ((BigInt(val1_high) << 32n) | BigInt(val1_low)).toString(),
-            offset: baseOffset + offset,
-            length: 5,
-        };
-        offset += 5;
-
-        const val2_high = view.getUint8(offset) & 0x1;
-        const val2_low = view.getUint32(offset + 1);
-        details.metadata_time_base_value = {
-            value: ((BigInt(val2_high) << 32n) | BigInt(val2_low)).toString(),
-            offset: baseOffset + offset,
-            length: 5,
-        };
-        offset += 5;
-
-        if (details.content_time_base_indicator.value === 2) {
-            details.contentId = {
-                value: view.getUint8(offset) & 0x7f,
-                offset: baseOffset + offset,
-                length: 1,
-            };
-            offset += 1;
-        }
-    }
-
-    if (
-        details.content_time_base_indicator.value >= 3 &&
-        details.content_time_base_indicator.value <= 7
-    ) {
-        const len = view.getUint8(offset);
-        details.time_base_association_data_length = {
-            value: len,
-            offset: baseOffset + offset,
-            length: 1,
-        };
-        offset += 1;
-        details.time_base_association_data = {
-            value: `${len} bytes`,
-            offset: baseOffset + offset,
-            length: len,
-        };
-        offset += len;
-    }
-
-    const privateDataLength = view.byteLength - offset;
-    if (privateDataLength > 0) {
-        details.private_data = {
-            value: `${privateDataLength} bytes`,
-            offset: baseOffset + offset,
-            length: privateDataLength,
-        };
-    }
-
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/copyright.js b/js/infrastructure/segment/ts/parsers/descriptors/copyright.js
deleted file mode 100644
index 9f79197..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/copyright.js
+++ /dev/null
@@ -1,16 +0,0 @@
-/**
- * Parses a Copyright Descriptor.
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseCopyrightDescriptor(view, baseOffset) {
-    const identifier = view.getUint32(0);
-    return {
-        copyright_identifier: {
-            value: `0x${identifier.toString(16).padStart(8, '0')}`,
-            offset: baseOffset,
-            length: 4,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/data-stream-alignment.js b/js/infrastructure/segment/ts/parsers/descriptors/data-stream-alignment.js
deleted file mode 100644
index ae8db6b..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/data-stream-alignment.js
+++ /dev/null
@@ -1,59 +0,0 @@
-/**
- * Parses a Data Stream Alignment Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.10 & Table 2-52
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @param {number | null} streamType - The stream_type of the parent elementary stream.
- * @returns {object} The parsed alignment descriptor.
- */
-export function parseDataStreamAlignmentDescriptor(
-    view,
-    baseOffset,
-    streamType
-) {
-    const alignmentType = view.getUint8(0);
-    let alignmentText = `Unknown/Reserved (${alignmentType})`;
-
-    const videoAlignmentMap = {
-        1: 'Slice, or video access unit',
-        2: 'Video access unit',
-        3: 'GOP, or SEQ',
-        4: 'SEQ',
-    };
-    const avcAlignmentMap = {
-        1: 'AVC slice or AVC access unit',
-        2: 'AVC access unit',
-        3: 'SVC slice or SVC dependency representation',
-        4: 'SVC dependency representation',
-        5: 'MVC slice or MVC view-component subset',
-        6: 'MVC view-component subset',
-        7: 'MVCD slice or MVCD view-component subset',
-        8: 'MVCD view-component subset',
-    };
-    const hevcAlignmentMap = {
-        1: 'HEVC access unit',
-        2: 'HEVC slice',
-        3: 'HEVC access unit or slice',
-        4: 'HEVC tile of slices',
-    };
-    const audioAlignmentMap = { 1: 'Sync word' };
-
-    const videoTypes = [0x01, 0x02, 0x10];
-    const avcTypes = [0x1b, 0x1f, 0x20, 0x23, 0x26];
-    const hevcTypes = [0x24, 0x25];
-    const audioTypes = [0x03, 0x04, 0x0f, 0x11, 0x1c];
-
-    if (videoTypes.includes(streamType)) {
-        alignmentText = videoAlignmentMap[alignmentType] || alignmentText;
-    } else if (avcTypes.includes(streamType)) {
-        alignmentText = avcAlignmentMap[alignmentType] || alignmentText;
-    } else if (hevcTypes.includes(streamType)) {
-        alignmentText = hevcAlignmentMap[alignmentType] || alignmentText;
-    } else if (audioTypes.includes(streamType)) {
-        alignmentText = audioAlignmentMap[alignmentType] || alignmentText;
-    }
-
-    return {
-        alignment_type: { value: alignmentText, offset: baseOffset, length: 1 },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/extension.js b/js/infrastructure/segment/ts/parsers/descriptors/extension.js
deleted file mode 100644
index 36dfe3f..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/extension.js
+++ /dev/null
@@ -1,177 +0,0 @@
-import { parseHevcTimingAndHrdDescriptor } from './hevc-timing-hrd.js';
-import { parseHevcOperationPointDescriptor } from './hevc-operation-point.js';
-import { parseGreenExtensionDescriptor } from './green-extension.js';
-import {
-    parseMpegH3dAudioDescriptor,
-    parseMpegH3dAudioConfigDescriptor,
-    parseMpegH3dAudioSceneDescriptor,
-    parseMpegH3dAudioTextLabelDescriptor,
-    parseMpegH3dAudioMultiStreamDescriptor,
-    parseMpegH3dAudioDrcLoudnessDescriptor,
-    parseMpegH3dAudioCommandDescriptor,
-} from './mpeg-h-3d-audio.js';
-import { parseQualityExtensionDescriptor } from './quality-extension.js';
-import { parseVirtualSegmentationDescriptor } from './virtual-segmentation.js';
-import { parseHevcTileSubstreamDescriptor } from './hevc-tile-substream.js';
-import { parseHevcSubregionDescriptor } from './hevc-subregion.js';
-
-/**
- * Parses the Extension Descriptor, which acts as a container for other descriptors.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.90
- * @param {DataView} payloadView - A DataView for the descriptor's payload.
- * @param {number} payloadOffset - The offset of the descriptor payload within the segment.
- * @returns {{name: string, details: object}}
- */
-export function parseExtensionDescriptor(payloadView, payloadOffset) {
-    let name = 'Extension Descriptor';
-    const extension_descriptor_tag = payloadView.getUint8(0);
-    const extPayloadView = new DataView(
-        payloadView.buffer,
-        payloadView.byteOffset + 1,
-        payloadView.byteLength - 1
-    );
-    let details = {
-        extension_descriptor_tag: {
-            value: `0x${extension_descriptor_tag.toString(16)}`,
-            offset: payloadOffset,
-            length: 1,
-        },
-    };
-
-    if (extension_descriptor_tag === 0x02) {
-        name = 'Object Descriptor Update';
-        details.ODUpdate_data = {
-            value: `${extPayloadView.byteLength} bytes`,
-            offset: payloadOffset + 1,
-            length: extPayloadView.byteLength,
-        };
-    } else if (extension_descriptor_tag === 0x03) {
-        name = 'HEVC Timing and HRD Descriptor';
-        Object.assign(
-            details,
-            parseHevcTimingAndHrdDescriptor(extPayloadView, payloadOffset + 1)
-        );
-    } else if (extension_descriptor_tag === 0x04) {
-        name = 'AF Extensions Descriptor';
-        details.af_extensions_data = {
-            value: `${extPayloadView.byteLength} bytes`,
-            offset: payloadOffset + 1,
-            length: extPayloadView.byteLength,
-        };
-    } else if (extension_descriptor_tag === 0x05) {
-        name = 'HEVC Operation Point Descriptor';
-        Object.assign(
-            details,
-            parseHevcOperationPointDescriptor(extPayloadView, payloadOffset + 1)
-        );
-    } else if (extension_descriptor_tag === 0x06) {
-        name = 'HEVC Hierarchy Extension Descriptor';
-        // This is already implemented in a dedicated file, but the call is here.
-        Object.assign(details, {});
-    } else if (extension_descriptor_tag === 0x07) {
-        name = 'Green Extension Descriptor';
-        Object.assign(
-            details,
-            parseGreenExtensionDescriptor(extPayloadView, payloadOffset + 1)
-        );
-    } else if (extension_descriptor_tag === 0x08) {
-        name = 'MPEG-H 3D Audio Descriptor';
-        Object.assign(
-            details,
-            parseMpegH3dAudioDescriptor(extPayloadView, payloadOffset + 1)
-        );
-    } else if (extension_descriptor_tag === 0x09) {
-        name = 'MPEG-H 3D Audio Config Descriptor';
-        Object.assign(
-            details,
-            parseMpegH3dAudioConfigDescriptor(extPayloadView, payloadOffset + 1)
-        );
-    } else if (extension_descriptor_tag === 0x0a) {
-        name = 'MPEG-H 3D Audio Scene Descriptor';
-        Object.assign(
-            details,
-            parseMpegH3dAudioSceneDescriptor(extPayloadView, payloadOffset + 1)
-        );
-    } else if (extension_descriptor_tag === 0x0b) {
-        name = 'MPEG-H 3D Audio Text Label Descriptor';
-        Object.assign(
-            details,
-            parseMpegH3dAudioTextLabelDescriptor(
-                extPayloadView,
-                payloadOffset + 1
-            )
-        );
-    } else if (extension_descriptor_tag === 0x0c) {
-        name = 'MPEG-H 3D Audio Multi-stream Descriptor';
-        Object.assign(
-            details,
-            parseMpegH3dAudioMultiStreamDescriptor(
-                extPayloadView,
-                payloadOffset + 1
-            )
-        );
-    } else if (extension_descriptor_tag === 0x0d) {
-        name = 'MPEG-H 3D Audio DRC Loudness Descriptor';
-        Object.assign(
-            details,
-            parseMpegH3dAudioDrcLoudnessDescriptor(
-                extPayloadView,
-                payloadOffset + 1
-            )
-        );
-    } else if (extension_descriptor_tag === 0x0e) {
-        name = 'MPEG-H 3D Audio Command Descriptor';
-        Object.assign(
-            details,
-            parseMpegH3dAudioCommandDescriptor(
-                extPayloadView,
-                payloadOffset + 1
-            )
-        );
-    } else if (extension_descriptor_tag === 0x0f) {
-        name = 'Quality Extension Descriptor';
-        Object.assign(
-            details,
-            parseQualityExtensionDescriptor(extPayloadView, payloadOffset + 1)
-        );
-    } else if (extension_descriptor_tag === 0x10) {
-        name = 'Virtual Segmentation Descriptor';
-        Object.assign(
-            details,
-            parseVirtualSegmentationDescriptor(
-                extPayloadView,
-                payloadOffset + 1
-            )
-        );
-    } else if (extension_descriptor_tag === 0x11) {
-        name = 'Timed Metadata Extension Descriptor';
-        details.timed_metadata = {
-            value: `${extPayloadView.byteLength} bytes`,
-            offset: payloadOffset + 1,
-            length: extPayloadView.byteLength,
-        };
-    } else if (extension_descriptor_tag === 0x12) {
-        name = 'HEVC Tile Substream Descriptor';
-        Object.assign(
-            details,
-            parseHevcTileSubstreamDescriptor(extPayloadView, payloadOffset + 1)
-        );
-    } else if (extension_descriptor_tag === 0x13) {
-        name = 'HEVC Subregion Descriptor';
-        Object.assign(
-            details,
-            parseHevcSubregionDescriptor(extPayloadView, payloadOffset + 1)
-        );
-    } else {
-        const remainingBytes = payloadView.byteLength - 1;
-        if (remainingBytes > 0) {
-            details.reserved_data = {
-                value: `${remainingBytes} bytes`,
-                offset: payloadOffset + 1,
-                length: remainingBytes,
-            };
-        }
-    }
-
-    return { name, details };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/external-es-id.js b/js/infrastructure/segment/ts/parsers/descriptors/external-es-id.js
deleted file mode 100644
index 793912c..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/external-es-id.js
+++ /dev/null
@@ -1,16 +0,0 @@
-/**
- * Parses an External ES_ID Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.46 & Table 2-76
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseExternalEsIdDescriptor(view, baseOffset) {
-    return {
-        External_ES_ID: {
-            value: view.getUint16(0),
-            offset: baseOffset,
-            length: 2,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/flexmux-timing.js b/js/infrastructure/segment/ts/parsers/descriptors/flexmux-timing.js
deleted file mode 100644
index aafccb4..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/flexmux-timing.js
+++ /dev/null
@@ -1,27 +0,0 @@
-/**
- * Parses a FlexMuxTiming Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.54 & Table 2-80
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseFlexMuxTimingDescriptor(view, baseOffset) {
-    return {
-        FCR_ES_ID: { value: view.getUint16(0), offset: baseOffset, length: 2 },
-        FCRResolution: {
-            value: view.getUint32(2),
-            offset: baseOffset + 2,
-            length: 4,
-        },
-        FCRLength: {
-            value: view.getUint8(6),
-            offset: baseOffset + 6,
-            length: 1,
-        },
-        FmxRateLength: {
-            value: view.getUint8(7),
-            offset: baseOffset + 7,
-            length: 1,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/fmc.js b/js/infrastructure/segment/ts/parsers/descriptors/fmc.js
deleted file mode 100644
index 1f8706a..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/fmc.js
+++ /dev/null
@@ -1,25 +0,0 @@
-/**
- * Parses an FMC (FlexMux Channel) Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.44
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseFmcDescriptor(view, baseOffset) {
-    const entries = [];
-    for (let offset = 0; offset < view.byteLength; offset += 3) {
-        if (offset + 3 > view.byteLength) break;
-        const esId = view.getUint16(offset);
-        const flexMuxChannel = view.getUint8(offset + 2);
-        entries.push({
-            ES_ID: { value: esId, offset: baseOffset + offset, length: 2 },
-            FlexMuxChannel: {
-                value: flexMuxChannel,
-                offset: baseOffset + offset + 2,
-                length: 1,
-            },
-        });
-    }
-
-    return { entries };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/fmx-buffer-size.js b/js/infrastructure/segment/ts/parsers/descriptors/fmx-buffer-size.js
deleted file mode 100644
index fee67a4..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/fmx-buffer-size.js
+++ /dev/null
@@ -1,18 +0,0 @@
-/**
- * Parses an FmxBufferSize Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.50 & Table 2-78
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseFmxBufferSizeDescriptor(view, baseOffset) {
-    // The internal structure (DefaultFlexMuxBufferDescriptor, FlexMuxBufferDescriptor)
-    // is defined in ISO/IEC 14496-1 and treated as opaque here.
-    return {
-        fmx_buffer_size_data: {
-            value: `${view.byteLength} bytes of FlexMux Buffer Size data`,
-            offset: baseOffset,
-            length: view.byteLength,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/green-extension.js b/js/infrastructure/segment/ts/parsers/descriptors/green-extension.js
deleted file mode 100644
index 4b1d4e8..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/green-extension.js
+++ /dev/null
@@ -1,59 +0,0 @@
-/**
- * Parses a Green Extension Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1, Extension Descriptor Tag 0x07, Table 2-118
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseGreenExtensionDescriptor(view, baseOffset) {
-    const details = {};
-    let offset = 0;
-
-    const byte0 = view.getUint8(offset);
-    const num_intervals = (byte0 >> 6) & 0x03;
-    details.num_constant_backlight_voltage_time_intervals = {
-        value: num_intervals,
-        offset: baseOffset + offset,
-        length: 0.25,
-    };
-    offset += 1;
-
-    details.intervals = [];
-    for (let i = 0; i < num_intervals; i++) {
-        if (offset + 2 > view.byteLength) break;
-        if (offset + 2 > view.byteLength) break;
-        details.intervals.push({
-            constant_backlight_voltage_time_interval: {
-                value: view.getUint16(offset),
-                offset: baseOffset + offset,
-                length: 2,
-            },
-        });
-        offset += 2;
-    }
-
-    const byte_vars = view.getUint8(offset);
-    const num_vars = (byte_vars >> 6) & 0x03;
-    details.num_max_variations = {
-        value: num_vars,
-        offset: baseOffset + offset,
-        length: 0.25,
-    };
-    offset += 1;
-
-    details.variations = [];
-    for (let j = 0; j < num_vars; j++) {
-        if (offset + 2 > view.byteLength) break;
-        if (offset + 2 > view.byteLength) break;
-        details.variations.push({
-            max_variation: {
-                value: view.getUint16(offset),
-                offset: baseOffset + offset,
-                length: 2,
-            },
-        });
-        offset += 2;
-    }
-
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/hevc-hierarchy-extension.js b/js/infrastructure/segment/ts/parsers/descriptors/hevc-hierarchy-extension.js
deleted file mode 100644
index 33fbebb..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/hevc-hierarchy-extension.js
+++ /dev/null
@@ -1,81 +0,0 @@
-/**
- * Parses an HEVC Hierarchy Extension Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1, Extension Descriptor Tag 0x06, see Table 2-116
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseHevcHierarchyExtensionDescriptor(view, baseOffset) {
-    const details = {};
-    let offset = 0;
-
-    details.extension_dimension_bits = {
-        value: `0x${view.getUint16(offset).toString(16).padStart(4, '0')}`,
-        offset: baseOffset + offset,
-        length: 2,
-    };
-    offset += 2;
-
-    const byte2 = view.getUint8(offset);
-    details.hierarchy_layer_index = {
-        value: byte2 & 0x3f,
-        offset: baseOffset + offset,
-        length: 0.75,
-    };
-    offset += 1;
-
-    const byte3 = view.getUint8(offset);
-    details.temporal_id = {
-        value: (byte3 >> 5) & 0x07,
-        offset: baseOffset + offset,
-        length: 0.375,
-    };
-    offset += 1;
-
-    const byte4 = view.getUint8(offset);
-    details.nuh_layer_id = {
-        value: byte4 & 0x3f,
-        offset: baseOffset + offset,
-        length: 0.75,
-    };
-    offset += 1;
-
-    const byte5 = view.getUint8(offset);
-    details.tref_present_flag = {
-        value: (byte5 >> 7) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    offset += 1;
-
-    const num_embedded_layers = view.getUint8(offset) & 0x3f;
-    details.num_embedded_layers = {
-        value: num_embedded_layers,
-        offset: baseOffset + offset,
-        length: 0.75,
-    };
-    offset += 1;
-
-    details.hierarchy_channel = {
-        value: view.getUint8(offset) & 0x3f,
-        offset: baseOffset + offset,
-        length: 0.75,
-    };
-    offset += 1;
-
-    details.embedded_layers = [];
-    for (let i = 0; i < num_embedded_layers; i++) {
-        if (offset >= view.byteLength) break;
-        const layerByte = view.getUint8(offset);
-        details.embedded_layers.push({
-            hierarchy_ext_embedded_layer_index: {
-                value: layerByte & 0x3f,
-                offset: baseOffset + offset,
-                length: 0.75,
-            },
-        });
-        offset += 1;
-    }
-
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/hevc-operation-point.js b/js/infrastructure/segment/ts/parsers/descriptors/hevc-operation-point.js
deleted file mode 100644
index 48f3af9..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/hevc-operation-point.js
+++ /dev/null
@@ -1,175 +0,0 @@
-/**
- * Parses an HEVC Operation Point Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1, Extension Descriptor Tag 0x05, Table 2-115
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseHevcOperationPointDescriptor(view, baseOffset) {
-    const details = {};
-    let offset = 0;
-
-    const byte0 = view.getUint8(offset);
-    details.num_ptl = {
-        value: byte0 & 0x3f,
-        offset: baseOffset + offset,
-        length: 0.75,
-    };
-    const num_ptl = byte0 & 0x3f;
-    offset += 1;
-
-    details.profile_tier_level_infos = [];
-    for (let i = 0; i < num_ptl; i++) {
-        if (offset + 12 > view.byteLength) break;
-        if (offset + 12 > view.byteLength) break;
-        details.profile_tier_level_infos.push({
-            value: `12 bytes of PTL data for index ${i}`,
-            offset: baseOffset + offset,
-            length: 12,
-        });
-        offset += 12;
-    }
-
-    const operation_points_count = view.getUint8(offset);
-    details.operation_points_count = {
-        value: operation_points_count,
-        offset: baseOffset + offset,
-        length: 1,
-    };
-    offset += 1;
-
-    details.operation_points = [];
-    for (let i = 0; i < operation_points_count; i++) {
-        if (offset + 2 > view.byteLength) break;
-        if (offset + 2 > view.byteLength) break;
-        const op = {};
-        op.target_ols = {
-            value: view.getUint8(offset),
-            offset: baseOffset + offset,
-            length: 1,
-        };
-        op.ES_count = {
-            value: view.getUint8(offset + 1),
-            offset: baseOffset + offset + 1,
-            length: 1,
-        };
-        const es_count = op.ES_count.value;
-        offset += 2;
-
-        op.es_references = [];
-        for (let j = 0; j < es_count; j++) {
-            if (offset + 1 > view.byteLength) break;
-            const byte = view.getUint8(offset);
-            if (offset + 1 > view.byteLength) break;
-            op.es_references.push({
-                prepend_dependencies: {
-                    value: (byte >> 7) & 1,
-                    offset: baseOffset + offset,
-                    length: 0.125,
-                },
-                ES_reference: {
-                    value: byte & 0x3f,
-                    offset: baseOffset + offset,
-                    length: 0.75,
-                },
-            });
-            offset += 1;
-        }
-
-        if (offset + 1 > view.byteLength) break;
-        op.numEsInOp = {
-            value: view.getUint8(offset) & 0x3f,
-            offset: baseOffset + offset,
-            length: 0.75,
-        };
-        const numEsInOp = op.numEsInOp.value;
-        offset += 1;
-
-        op.layers = [];
-        for (let k = 0; k < numEsInOp; k++) {
-            if (offset + 1 > view.byteLength) break;
-            const byte = view.getUint8(offset);
-            if (offset + 1 > view.byteLength) break;
-            op.layers.push({
-                necessary_layer_flag: {
-                    value: (byte >> 7) & 1,
-                    offset: baseOffset + offset,
-                    length: 0.125,
-                },
-                output_layer_flag: {
-                    value: (byte >> 6) & 1,
-                    offset: baseOffset + offset,
-                    length: 0.125,
-                },
-                ptl_ref_idx: {
-                    value: byte & 0x3f,
-                    offset: baseOffset + offset,
-                    length: 0.75,
-                },
-            });
-            offset += 1;
-        }
-
-        if (offset + 1 > view.byteLength) break;
-        const flags = view.getUint8(offset);
-        op.avg_bit_rate_info_flag = {
-            value: (flags >> 7) & 1,
-            offset: baseOffset + offset,
-            length: 0.125,
-        };
-        op.max_bit_rate_info_flag = {
-            value: (flags >> 6) & 1,
-            offset: baseOffset + offset,
-            length: 0.125,
-        };
-        op.constant_frame_rate_info_idc = {
-            value: (flags >> 4) & 0x03,
-            offset: baseOffset + offset,
-            length: 0.25,
-        };
-        op.applicable_temporal_id = {
-            value: (flags >> 1) & 0x07,
-            offset: baseOffset + offset,
-            length: 0.375,
-        };
-        offset += 1;
-
-        if (op.constant_frame_rate_info_idc.value > 0) {
-            if (offset + 2 > view.byteLength) break;
-            if (offset + 2 > view.byteLength) break;
-            op.frame_rate_indicator = {
-                value: view.getUint16(offset) & 0x0fff,
-                offset: baseOffset + offset,
-                length: 1.5,
-            };
-            offset += 2;
-        }
-
-        if (op.avg_bit_rate_info_flag.value === 1) {
-            if (offset + 3 > view.byteLength) break;
-            if (offset + 3 > view.byteLength) break;
-            op.avg_bit_rate = {
-                value:
-                    (view.getUint8(offset) << 16) | view.getUint16(offset + 1),
-                offset: baseOffset + offset,
-                length: 3,
-            };
-            offset += 3;
-        }
-        if (op.max_bit_rate_info_flag.value === 1) {
-            if (offset + 3 > view.byteLength) break;
-            if (offset + 3 > view.byteLength) break;
-            op.max_bit_rate = {
-                value:
-                    (view.getUint8(offset) << 16) | view.getUint16(offset + 1),
-                offset: baseOffset + offset,
-                length: 3,
-            };
-            offset += 3;
-        }
-
-        details.operation_points.push(op);
-    }
-
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/hevc-subregion.js b/js/infrastructure/segment/ts/parsers/descriptors/hevc-subregion.js
deleted file mode 100644
index f5a2840..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/hevc-subregion.js
+++ /dev/null
@@ -1,51 +0,0 @@
-/**
- * Parses an HEVC Subregion Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1, Extension Descriptor Tag 0x13, Table 2-129
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseHevcSubregionDescriptor(view, baseOffset) {
-    const details = {};
-    let offset = 0;
-
-    const byte0 = view.getUint8(offset);
-    details.SubstreamMarkingFlag = {
-        value: (byte0 >> 7) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.SubstreamIDsPerLine = {
-        value: byte0 & 0x7f,
-        offset: baseOffset + offset,
-        length: 0.875,
-    };
-    offset += 1;
-
-    details.TotalSubstreamIDs = {
-        value: view.getUint8(offset),
-        offset: baseOffset + offset,
-        length: 1,
-    };
-    offset += 1;
-
-    details.LevelFullPanorama = {
-        value: view.getUint8(offset),
-        offset: baseOffset + offset,
-        length: 1,
-    };
-    offset += 1;
-
-    // The rest is a loop of layouts, too complex to fully parse without context.
-    // We'll just indicate the presence of layout data.
-    const remainingBytes = view.byteLength - offset;
-    if (remainingBytes > 0) {
-        details.layout_data = {
-            value: `${remainingBytes} bytes of layout data`,
-            offset: baseOffset + offset,
-            length: remainingBytes,
-        };
-    }
-
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/hevc-tile-substream.js b/js/infrastructure/segment/ts/parsers/descriptors/hevc-tile-substream.js
deleted file mode 100644
index c9d99cf..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/hevc-tile-substream.js
+++ /dev/null
@@ -1,61 +0,0 @@
-/**
- * Parses an HEVC Tile Substream Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1, Extension Descriptor Tag 0x12, Table 2-128
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseHevcTileSubstreamDescriptor(view, baseOffset) {
-    const details = {};
-    let offset = 0;
-
-    const byte0 = view.getUint8(offset);
-    const referenceFlag = (byte0 >> 7) & 1;
-    details.ReferenceFlag = {
-        value: referenceFlag,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.SubstreamID = {
-        value: byte0 & 0x7f,
-        offset: baseOffset + offset,
-        length: 0.875,
-    };
-    offset += 1;
-
-    if (view.byteLength > 1) {
-        if (referenceFlag === 1) {
-            const byte1 = view.getUint8(offset);
-            details.PreambleFlag = {
-                value: (byte1 >> 7) & 1,
-                offset: baseOffset + offset,
-                length: 0.125,
-            };
-            details.PatternReference = {
-                value: byte1 & 0x7f,
-                offset: baseOffset + offset,
-                length: 0.875,
-            };
-        } else {
-            details.additional_substreams = [];
-            while (offset < view.byteLength) {
-                const byte = view.getUint8(offset);
-                details.additional_substreams.push({
-                    Flag: {
-                        value: (byte >> 7) & 1,
-                        offset: baseOffset + offset,
-                        length: 0.125,
-                    },
-                    AdditionalSubstreamID: {
-                        value: byte & 0x7f,
-                        offset: baseOffset + offset,
-                        length: 0.875,
-                    },
-                });
-                offset += 1;
-            }
-        }
-    }
-
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/hevc-timing-hrd.js b/js/infrastructure/segment/ts/parsers/descriptors/hevc-timing-hrd.js
deleted file mode 100644
index 8f0732b..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/hevc-timing-hrd.js
+++ /dev/null
@@ -1,68 +0,0 @@
-/**
- * Parses an HEVC Timing and HRD Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1, Extension Descriptor Tag 0x03, see Table 2-113
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed HEVC timing and HRD descriptor.
- */
-export function parseHevcTimingAndHrdDescriptor(view, baseOffset) {
-    const details = {};
-    let offset = 0;
-
-    if (view.byteLength < 2) return details;
-
-    const byte0 = view.getUint8(offset);
-    details.hrd_management_valid_flag = {
-        value: (byte0 >> 7) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    offset += 1;
-
-    const byte1 = view.getUint8(offset);
-    const picture_and_timing_info_present_flag = byte1 & 1;
-    details.picture_and_timing_info_present_flag = {
-        value: picture_and_timing_info_present_flag,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    offset += 1;
-
-    if (picture_and_timing_info_present_flag) {
-        if (view.byteLength > offset) {
-            const byte2 = view.getUint8(offset);
-            const ninety_kHz_flag = (byte2 >> 7) & 1;
-            details['90kHz_flag'] = {
-                value: ninety_kHz_flag,
-                offset: baseOffset + offset,
-                length: 0.125,
-            };
-            offset += 1;
-
-            if (ninety_kHz_flag === 0) {
-                if (view.byteLength >= offset + 8) {
-                    details.N = {
-                        value: view.getUint32(offset),
-                        offset: baseOffset + offset,
-                        length: 4,
-                    };
-                    details.K = {
-                        value: view.getUint32(offset + 4),
-                        offset: baseOffset + offset + 4,
-                        length: 4,
-                    };
-                    offset += 8;
-                }
-            }
-            if (view.byteLength >= offset + 4) {
-                details.num_units_in_tick = {
-                    value: view.getUint32(offset),
-                    offset: baseOffset + offset,
-                    length: 4,
-                };
-            }
-        }
-    }
-
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/hevc-video.js b/js/infrastructure/segment/ts/parsers/descriptors/hevc-video.js
deleted file mode 100644
index 1252921..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/hevc-video.js
+++ /dev/null
@@ -1,116 +0,0 @@
-/**
- * Parses an HEVC Video Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.95 & Table 2-111
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed HEVC video descriptor.
- */
-export function parseHevcVideoDescriptor(view, baseOffset) {
-    const details = {};
-    let offset = 0;
-
-    const byte0 = view.getUint8(offset);
-    details.profile_space = {
-        value: (byte0 >> 6) & 0x03,
-        offset: baseOffset + offset,
-        length: 0.25,
-    };
-    details.tier_flag = {
-        value: (byte0 >> 5) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.profile_idc = {
-        value: byte0 & 0x1f,
-        offset: baseOffset + offset,
-        length: 0.625,
-    };
-    offset += 1;
-
-    details.profile_compatibility_indication = {
-        value: `0x${view.getUint32(offset).toString(16).padStart(8, '0')}`,
-        offset: baseOffset + offset,
-        length: 4,
-    };
-    offset += 4;
-
-    const byte5 = view.getUint8(offset);
-    details.progressive_source_flag = {
-        value: (byte5 >> 7) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.interlaced_source_flag = {
-        value: (byte5 >> 6) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.non_packed_constraint_flag = {
-        value: (byte5 >> 5) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.frame_only_constraint_flag = {
-        value: (byte5 >> 4) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    offset += 1;
-
-    // copied_44bits are skipped for brevity but would be parsed here
-    offset += 6; // 44 bits is ~6 bytes
-
-    details.level_idc = {
-        value: view.getUint8(offset),
-        offset: baseOffset + offset,
-        length: 1,
-    };
-    offset += 1;
-
-    if (offset < view.byteLength) {
-        const flags = view.getUint8(offset);
-        const temporal_layer_subset_flag = (flags >> 7) & 1;
-        details.temporal_layer_subset_flag = {
-            value: temporal_layer_subset_flag,
-            offset: baseOffset + offset,
-            length: 0.125,
-        };
-        details.HEVC_still_present_flag = {
-            value: (flags >> 6) & 1,
-            offset: baseOffset + offset,
-            length: 0.125,
-        };
-        details.HEVC_24hr_picture_present_flag = {
-            value: (flags >> 5) & 1,
-            offset: baseOffset + offset,
-            length: 0.125,
-        };
-        details.sub_pic_hrd_params_not_present_flag = {
-            value: (flags >> 4) & 1,
-            offset: baseOffset + offset,
-            length: 0.125,
-        };
-        details.HDR_WCG_idc = {
-            value: flags & 0x03,
-            offset: baseOffset + offset,
-            length: 0.25,
-        };
-        offset += 1;
-
-        if (temporal_layer_subset_flag) {
-            const temporal_ids = view.getUint8(offset);
-            details.temporal_id_min = {
-                value: (temporal_ids >> 5) & 0x07,
-                offset: baseOffset + offset,
-                length: 0.375,
-            };
-            details.temporal_id_max = {
-                value: temporal_ids & 0x07,
-                offset: baseOffset + offset,
-                length: 0.375,
-            };
-        }
-    }
-
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/hierarchy.js b/js/infrastructure/segment/ts/parsers/descriptors/hierarchy.js
deleted file mode 100644
index 9677261..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/hierarchy.js
+++ /dev/null
@@ -1,72 +0,0 @@
-/**
- * Parses a Hierarchy Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.6 & Table 2-49
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed hierarchy descriptor.
- */
-export function parseHierarchyDescriptor(view, baseOffset) {
-    const byte1 = view.getUint8(0);
-    const hierarchyType = byte1 & 0x0f;
-    const byte2 = view.getUint8(1);
-    const byte3 = view.getUint8(2);
-
-    const hierarchyTypeMap = {
-        1: 'Spatial Scalability',
-        2: 'SNR Scalability',
-        3: 'Temporal Scalability',
-        4: 'Data partitioning',
-        5: 'Extension bitstream',
-        8: 'Combined Scalability',
-        9: 'MVC/MVCD video sub-bitstream',
-        15: 'Base layer',
-    };
-
-    return {
-        no_view_scalability_flag: {
-            value: (byte1 >> 7) & 1,
-            offset: baseOffset,
-            length: 0.125,
-        },
-        no_temporal_scalability_flag: {
-            value: (byte1 >> 6) & 1,
-            offset: baseOffset,
-            length: 0.125,
-        },
-        no_spatial_scalability_flag: {
-            value: (byte1 >> 5) & 1,
-            offset: baseOffset,
-            length: 0.125,
-        },
-        no_quality_scalability_flag: {
-            value: (byte1 >> 4) & 1,
-            offset: baseOffset,
-            length: 0.125,
-        },
-        hierarchy_type: {
-            value: `${hierarchyTypeMap[hierarchyType] || 'Reserved'} (${hierarchyType})`,
-            offset: baseOffset,
-            length: 0.5,
-        },
-        hierarchy_layer_index: {
-            value: byte2 & 0x3f,
-            offset: baseOffset + 1,
-            length: 0.75,
-        },
-        tref_present_flag: {
-            value: (byte2 >> 6) & 1,
-            offset: baseOffset + 1,
-            length: 0.125,
-        },
-        hierarchy_embedded_layer_index: {
-            value: byte3 & 0x3f,
-            offset: baseOffset + 2,
-            length: 0.75,
-        },
-        hierarchy_channel: {
-            value: view.getUint8(3) & 0x3f,
-            offset: baseOffset + 3,
-            length: 0.75,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/ibp.js b/js/infrastructure/segment/ts/parsers/descriptors/ibp.js
deleted file mode 100644
index 8bcc2fc..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/ibp.js
+++ /dev/null
@@ -1,27 +0,0 @@
-/**
- * Parses an IBP Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.34 & Table 2-69
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed IBP descriptor.
- */
-export function parseIbpDescriptor(view, baseOffset) {
-    const word = view.getUint16(0);
-    return {
-        closed_gop_flag: {
-            value: (word >> 15) & 1,
-            offset: baseOffset,
-            length: 0.125,
-        },
-        identical_gop_flag: {
-            value: (word >> 14) & 1,
-            offset: baseOffset,
-            length: 0.125,
-        },
-        max_gop_length: {
-            value: word & 0x3fff,
-            offset: baseOffset,
-            length: 1.75,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/index.js b/js/infrastructure/segment/ts/parsers/descriptors/index.js
deleted file mode 100644
index d81385c..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/index.js
+++ /dev/null
@@ -1,388 +0,0 @@
-import { parseVideoStreamDescriptor } from './video-stream.js';
-import { parseAudioStreamDescriptor } from './audio-stream.js';
-import { parseHierarchyDescriptor } from './hierarchy.js';
-import { parseRegistrationDescriptor } from './registration.js';
-import { parseDataStreamAlignmentDescriptor } from './data-stream-alignment.js';
-import { parseTargetBackgroundGridDescriptor } from './target-background-grid.js';
-import { parseVideoWindowDescriptor } from './video-window.js';
-import { parseCaDescriptor } from './ca.js';
-import { parseIso639LanguageDescriptor } from './iso639-language.js';
-import { parseSystemClockDescriptor } from './system-clock.js';
-import { parseMultiplexBufferUtilizationDescriptor } from './multiplex-buffer-utilization.js';
-import { parseCopyrightDescriptor } from './copyright.js';
-import { parseMaximumBitrateDescriptor } from './maximum-bitrate.js';
-import { parsePrivateDataIndicatorDescriptor } from './private-data-indicator.js';
-import { parseSmoothingBufferDescriptor } from './smoothing-buffer.js';
-import { parseStdDescriptor } from './std.js';
-import { parseIbpDescriptor } from './ibp.js';
-import { parseMpeg4VideoDescriptor } from './mpeg4-video.js';
-import { parseMpeg4AudioDescriptor } from './mpeg4-audio.js';
-import { parseMpeg4TextDescriptor } from './mpeg4-text.js';
-import { parseAvcVideoDescriptor } from './avc-video.js';
-import { parseHevcVideoDescriptor } from './hevc-video.js';
-import { parseExtensionDescriptor } from './extension.js';
-import { parseIodDescriptor } from './iod.js';
-import { parseSlDescriptor } from './sl.js';
-import { parseFmcDescriptor } from './fmc.js';
-import { parseSvcExtensionDescriptor } from './svc-extension.js';
-import { parseMvcExtensionDescriptor } from './mvc-extension.js';
-import { parseFlexMuxTimingDescriptor } from './flexmux-timing.js';
-import { parseMultiplexBufferDescriptor } from './multiplex-buffer.js';
-import { parseMpeg2StereoscopicVideoFormatDescriptor } from './mpeg2-stereoscopic-video-format.js';
-import { parseStereoscopicProgramInfoDescriptor } from './stereoscopic-program-info.js';
-import { parseStereoscopicVideoInfoDescriptor } from './stereoscopic-video-info.js';
-import { parseTransportProfileDescriptor } from './transport-profile.js';
-import { parseJ2kVideoDescriptor } from './j2k-video.js';
-import { parseAvcTimingAndHrdDescriptor } from './avc-timing-hrd.js';
-import { parseContentLabelingDescriptor } from './content-labeling.js';
-import { parseMetadataPointerDescriptor } from './metadata-pointer.js';
-import { parseMetadataDescriptor } from './metadata.js';
-import { parseMetadataStdDescriptor } from './metadata-std.js';
-import { parseMpeg2AacAudioDescriptor } from './mpeg2-aac-audio.js';
-import { parseMpeg4AudioExtensionDescriptor } from './mpeg4-audio-extension.js';
-import { parseAuxiliaryVideoStreamDescriptor } from './auxiliary-video-stream.js';
-import { parseExternalEsIdDescriptor } from './external-es-id.js';
-import { parseMuxcodeDescriptor } from './muxcode.js';
-import { parseFmxBufferSizeDescriptor } from './fmx-buffer-size.js';
-import { parseIpmpDescriptor } from './ipmp.js';
-import { parseMvcOperationPointDescriptor } from './mvc-operation-point.js';
-
-/**
- * Parses a loop of descriptors from a DataView.
- * @param {DataView} view - A DataView starting at the beginning of the descriptor loop.
- * @param {number} baseOffset - The offset of the loop within the segment.
- * @param {string | null} streamTypeHexString - The hex string of the parent stream type.
- * @returns {object[]} An array of parsed descriptor objects.
- */
-export function parseDescriptors(view, baseOffset, streamTypeHexString = null) {
-    const descriptors = [];
-    let offset = 0;
-    const streamType = streamTypeHexString
-        ? parseInt(streamTypeHexString, 16)
-        : null;
-
-    while (offset < view.byteLength) {
-        if (offset + 2 > view.byteLength) break;
-        const descriptor_tag = view.getUint8(offset);
-        const descriptor_length = view.getUint8(offset + 1);
-
-        if (offset + 2 + descriptor_length > view.byteLength) break;
-
-        const payloadView = new DataView(
-            view.buffer,
-            view.byteOffset + offset + 2,
-            descriptor_length
-        );
-        const payloadOffset = baseOffset + offset + 2;
-
-        let details;
-        let name = 'Unknown/Private Descriptor';
-
-        switch (descriptor_tag) {
-            case 0x02:
-                name = 'Video Stream Descriptor';
-                details = parseVideoStreamDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x03:
-                name = 'Audio Stream Descriptor';
-                details = parseAudioStreamDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x04:
-                name = 'Hierarchy Descriptor';
-                details = parseHierarchyDescriptor(payloadView, payloadOffset);
-                break;
-            case 0x05:
-                name = 'Registration Descriptor';
-                details = parseRegistrationDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x06:
-                name = 'Data Stream Alignment Descriptor';
-                details = parseDataStreamAlignmentDescriptor(
-                    payloadView,
-                    payloadOffset,
-                    streamType
-                );
-                break;
-            case 0x07:
-                name = 'Target Background Grid Descriptor';
-                details = parseTargetBackgroundGridDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x08:
-                name = 'Video Window Descriptor';
-                details = parseVideoWindowDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x09:
-                name = 'Conditional Access Descriptor';
-                details = parseCaDescriptor(payloadView, payloadOffset);
-                break;
-            case 0x0a:
-                name = 'ISO 639 Language Descriptor';
-                details = parseIso639LanguageDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x0b:
-                name = 'System Clock Descriptor';
-                details = parseSystemClockDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x0c:
-                name = 'Multiplex Buffer Utilization Descriptor';
-                details = parseMultiplexBufferUtilizationDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x0d:
-                name = 'Copyright Descriptor';
-                details = parseCopyrightDescriptor(payloadView, payloadOffset);
-                break;
-            case 0x0e:
-                name = 'Maximum Bitrate Descriptor';
-                details = parseMaximumBitrateDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x0f:
-                name = 'Private Data Indicator Descriptor';
-                details = parsePrivateDataIndicatorDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x10:
-                name = 'Smoothing Buffer Descriptor';
-                details = parseSmoothingBufferDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x11:
-                name = 'STD Descriptor';
-                details = parseStdDescriptor(payloadView, payloadOffset);
-                break;
-            case 0x12:
-                name = 'IBP Descriptor';
-                details = parseIbpDescriptor(payloadView, payloadOffset);
-                break;
-            case 0x1b:
-                name = 'MPEG-4 Video Descriptor';
-                details = parseMpeg4VideoDescriptor(payloadView, payloadOffset);
-                break;
-            case 0x1c:
-                name = 'MPEG-4 Audio Descriptor';
-                details = parseMpeg4AudioDescriptor(payloadView, payloadOffset);
-                break;
-            case 0x1d:
-                name = 'IOD Descriptor';
-                details = parseIodDescriptor(payloadView, payloadOffset);
-                break;
-            case 0x1e:
-                name = 'SL Descriptor';
-                details = parseSlDescriptor(payloadView, payloadOffset);
-                break;
-            case 0x1f:
-                name = 'FMC Descriptor';
-                details = parseFmcDescriptor(payloadView, payloadOffset);
-                break;
-            case 0x20:
-                name = 'External ES_ID Descriptor';
-                details = parseExternalEsIdDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x21:
-                name = 'MuxCode Descriptor';
-                details = parseMuxcodeDescriptor(payloadView, payloadOffset);
-                break;
-            case 0x22:
-                name = 'FmxBufferSize Descriptor';
-                details = parseFmxBufferSizeDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x23:
-                name = 'MultiplexBuffer Descriptor';
-                details = parseMultiplexBufferDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x24:
-                name = 'Content Labeling Descriptor';
-                details = parseContentLabelingDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x25:
-                name = 'Metadata Pointer Descriptor';
-                details = parseMetadataPointerDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x26:
-                name = 'Metadata Descriptor';
-                details = parseMetadataDescriptor(payloadView, payloadOffset);
-                break;
-            case 0x27:
-                name = 'Metadata STD Descriptor';
-                details = parseMetadataStdDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x28:
-                name = 'AVC Video Descriptor';
-                details = parseAvcVideoDescriptor(payloadView, payloadOffset);
-                break;
-            case 0x29:
-                name = 'IPMP Descriptor';
-                details = parseIpmpDescriptor(payloadView, payloadOffset);
-                break;
-            case 0x2a:
-                name = 'AVC Timing and HRD Descriptor';
-                details = parseAvcTimingAndHrdDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x2b:
-                name = 'MPEG-2 AAC Audio Descriptor';
-                details = parseMpeg2AacAudioDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x2c:
-                name = 'FlexMuxTiming Descriptor';
-                details = parseFlexMuxTimingDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x2d:
-                name = 'MPEG-4 Text Descriptor';
-                details = parseMpeg4TextDescriptor(payloadView, payloadOffset);
-                break;
-            case 0x2e:
-                name = 'MPEG-4 Audio Extension Descriptor';
-                details = parseMpeg4AudioExtensionDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x2f:
-                name = 'Auxiliary Video Stream Descriptor';
-                details = parseAuxiliaryVideoStreamDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x30:
-                name = 'SVC Extension Descriptor';
-                details = parseSvcExtensionDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x31:
-                name = 'MVC Extension Descriptor';
-                details = parseMvcExtensionDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x32:
-                name = 'J2K Video Descriptor';
-                details = parseJ2kVideoDescriptor(payloadView, payloadOffset);
-                break;
-            case 0x33:
-                name = 'MVC Operation Point Descriptor';
-                details = parseMvcOperationPointDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x34:
-                name = 'MPEG-2 Stereoscopic Video Format Descriptor';
-                details = parseMpeg2StereoscopicVideoFormatDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x35:
-                name = 'Stereoscopic Program Info Descriptor';
-                details = parseStereoscopicProgramInfoDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x36:
-                name = 'Stereoscopic Video Info Descriptor';
-                details = parseStereoscopicVideoInfoDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x37:
-                name = 'Transport Profile Descriptor';
-                details = parseTransportProfileDescriptor(
-                    payloadView,
-                    payloadOffset
-                );
-                break;
-            case 0x38:
-                name = 'HEVC Video Descriptor';
-                details = parseHevcVideoDescriptor(payloadView, payloadOffset);
-                break;
-            case 0x63: {
-                ({ name, details } = parseExtensionDescriptor(
-                    payloadView,
-                    payloadOffset
-                ));
-                break;
-            }
-            default:
-                details = {
-                    data: {
-                        value: `${descriptor_length} bytes`,
-                        offset: payloadOffset,
-                        length: descriptor_length,
-                    },
-                };
-                break;
-        }
-
-        descriptors.push({
-            tag: descriptor_tag,
-            length: descriptor_length,
-            name,
-            details,
-        });
-        offset += 2 + descriptor_length;
-    }
-    return descriptors;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/iod.js b/js/infrastructure/segment/ts/parsers/descriptors/iod.js
deleted file mode 100644
index 41083f0..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/iod.js
+++ /dev/null
@@ -1,30 +0,0 @@
-/**
- * Parses an IOD (Initial Object Descriptor) Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.40
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseIodDescriptor(view, baseOffset) {
-    const scope = view.getUint8(0);
-    const label = view.getUint8(1);
-    const initialObjectDescriptorLength = view.byteLength - 2;
-
-    return {
-        Scope_of_IOD_label: {
-            value: `0x${scope.toString(16).padStart(2, '0')}`,
-            offset: baseOffset,
-            length: 1,
-        },
-        IOD_label: {
-            value: `0x${label.toString(16).padStart(2, '0')}`,
-            offset: baseOffset + 1,
-            length: 1,
-        },
-        InitialObjectDescriptor: {
-            value: `${initialObjectDescriptorLength} bytes of InitialObjectDescriptor data`,
-            offset: baseOffset + 2,
-            length: initialObjectDescriptorLength,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/ipmp.js b/js/infrastructure/segment/ts/parsers/descriptors/ipmp.js
deleted file mode 100644
index 5521798..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/ipmp.js
+++ /dev/null
@@ -1,17 +0,0 @@
-/**
- * Parses an IPMP (Intellectual Property Management and Protection) Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6, Tag 0x29
- * The structure is defined in ISO/IEC 13818-11.
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseIpmpDescriptor(view, baseOffset) {
-    return {
-        ipmp_data: {
-            value: `${view.byteLength} bytes of IPMP data`,
-            offset: baseOffset,
-            length: view.byteLength,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/iso639-language.js b/js/infrastructure/segment/ts/parsers/descriptors/iso639-language.js
deleted file mode 100644
index 73bc0d9..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/iso639-language.js
+++ /dev/null
@@ -1,39 +0,0 @@
-/**
- * Parses an ISO 639 Language Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.18 & Table 2-60
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed language descriptor.
- */
-export function parseIso639LanguageDescriptor(view, baseOffset) {
-    const languages = [];
-    for (let offset = 0; offset < view.byteLength; offset += 4) {
-        if (offset + 4 > view.byteLength) break;
-        const langCode =
-            String.fromCharCode(view.getUint8(offset)) +
-            String.fromCharCode(view.getUint8(offset + 1)) +
-            String.fromCharCode(view.getUint8(offset + 2));
-        const audioType = view.getUint8(offset + 3);
-        const audioTypeMap = {
-            0x00: 'Undefined',
-            0x01: 'Clean effects',
-            0x02: 'Hearing impaired',
-            0x03: 'Visual impaired commentary',
-        };
-        languages.push({
-            language: {
-                value: langCode,
-                offset: baseOffset + offset,
-                length: 3,
-            },
-            audio_type: {
-                value:
-                    audioTypeMap[audioType] ||
-                    `User Private (0x${audioType.toString(16)})`,
-                offset: baseOffset + offset + 3,
-                length: 1,
-            },
-        });
-    }
-    return { languages };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/j2k-video.js b/js/infrastructure/segment/ts/parsers/descriptors/j2k-video.js
deleted file mode 100644
index c007721..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/j2k-video.js
+++ /dev/null
@@ -1,126 +0,0 @@
-/**
- * Parses a J2K (JPEG 2000) Video Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.80 & Table 2-99
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed J2K video descriptor.
- */
-export function parseJ2kVideoDescriptor(view, baseOffset) {
-    const word1 = view.getUint16(0);
-    const extended_capability_flag = (word1 >> 15) & 1;
-    const profile_and_level = word1 & 0x7fff;
-
-    const details = {
-        extended_capability_flag: {
-            value: extended_capability_flag,
-            offset: baseOffset,
-            length: 0.125,
-        },
-        profile_and_level: {
-            value: `0x${profile_and_level.toString(16).padStart(4, '0')}`,
-            offset: baseOffset,
-            length: 1.875,
-        },
-        horizontal_size: {
-            value: view.getUint32(2),
-            offset: baseOffset + 2,
-            length: 4,
-        },
-        vertical_size: {
-            value: view.getUint32(6),
-            offset: baseOffset + 6,
-            length: 4,
-        },
-        max_bit_rate: {
-            value: view.getUint32(10),
-            offset: baseOffset + 10,
-            length: 4,
-        },
-        max_buffer_size: {
-            value: view.getUint32(14),
-            offset: baseOffset + 14,
-            length: 4,
-        },
-        DEN_frame_rate: {
-            value: view.getUint16(18),
-            offset: baseOffset + 18,
-            length: 2,
-        },
-        NUM_frame_rate: {
-            value: view.getUint16(20),
-            offset: baseOffset + 20,
-            length: 2,
-        },
-    };
-
-    let currentOffset = 22;
-    if (extended_capability_flag) {
-        const flags1 = view.getUint8(currentOffset);
-        details.stripe_flag = {
-            value: (flags1 >> 7) & 1,
-            offset: baseOffset + currentOffset,
-            length: 0.125,
-        };
-        details.block_flag = {
-            value: (flags1 >> 6) & 1,
-            offset: baseOffset + currentOffset,
-            length: 0.125,
-        };
-        details.mdm_flag = {
-            value: (flags1 >> 5) & 1,
-            offset: baseOffset + currentOffset,
-            length: 0.125,
-        };
-        currentOffset += 1;
-    } else {
-        details.color_specification = {
-            value: view.getUint8(currentOffset),
-            offset: baseOffset + currentOffset,
-            length: 1,
-        };
-        currentOffset += 1;
-    }
-
-    const flags2 = view.getUint8(currentOffset);
-    details.still_mode = {
-        value: (flags2 >> 7) & 1,
-        offset: baseOffset + currentOffset,
-        length: 0.125,
-    };
-    details.interlaced_video = {
-        value: (flags2 >> 6) & 1,
-        offset: baseOffset + currentOffset,
-        length: 0.125,
-    };
-    currentOffset += 1;
-
-    if (extended_capability_flag) {
-        details.colour_primaries = {
-            value: view.getUint8(currentOffset),
-            offset: baseOffset + currentOffset,
-            length: 1,
-        };
-        currentOffset += 1;
-        details.transfer_characteristics = {
-            value: view.getUint8(currentOffset),
-            offset: baseOffset + currentOffset,
-            length: 1,
-        };
-        currentOffset += 1;
-        details.matrix_coefficients = {
-            value: view.getUint8(currentOffset),
-            offset: baseOffset + currentOffset,
-            length: 1,
-        };
-        currentOffset += 1;
-        const fullRangeByte = view.getUint8(currentOffset);
-        details.video_full_range_flag = {
-            value: (fullRangeByte >> 7) & 1,
-            offset: baseOffset + currentOffset,
-            length: 0.125,
-        };
-        currentOffset += 1;
-    }
-
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/maximum-bitrate.js b/js/infrastructure/segment/ts/parsers/descriptors/maximum-bitrate.js
deleted file mode 100644
index fef1890..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/maximum-bitrate.js
+++ /dev/null
@@ -1,31 +0,0 @@
-/**
- * Parses a Maximum Bitrate Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.26 & Table 2-65
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMaximumBitrateDescriptor(view, baseOffset) {
-    if (view.byteLength < 3) {
-        return { error: 'Payload too short for MaximumBitrateDescriptor' };
-    }
-    const byte0 = view.getUint8(0);
-    const byte1 = view.getUint8(1);
-    const byte2 = view.getUint8(2);
-
-    const maxBitrateValue = ((byte0 & 0x3f) << 16) | (byte1 << 8) | byte2;
-    const rate = maxBitrateValue * 400; // Value is in units of 50 bytes/s -> 400 bps
-
-    return {
-        reserved: {
-            value: (byte0 >> 6) & 0x03,
-            offset: baseOffset,
-            length: 0.25,
-        },
-        maximum_bitrate: {
-            value: `${(rate / 1000000).toFixed(2)} Mbps`,
-            offset: baseOffset,
-            length: 3, // The entire field is 3 bytes (2 + 22 bits)
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/metadata-pointer.js b/js/infrastructure/segment/ts/parsers/descriptors/metadata-pointer.js
deleted file mode 100644
index 8451989..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/metadata-pointer.js
+++ /dev/null
@@ -1,114 +0,0 @@
-/**
- * Parses a Metadata Pointer Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.58 & Table 2-84
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMetadataPointerDescriptor(view, baseOffset) {
-    const details = {};
-    let offset = 0;
-
-    details.metadata_application_format = {
-        value: view.getUint16(offset),
-        offset: baseOffset + offset,
-        length: 2,
-    };
-    offset += 2;
-
-    if (details.metadata_application_format.value === 0xffff) {
-        details.metadata_application_format_identifier = {
-            value: view.getUint32(offset),
-            offset: baseOffset + offset,
-            length: 4,
-        };
-        offset += 4;
-    }
-
-    details.metadata_format = {
-        value: view.getUint8(offset),
-        offset: baseOffset + offset,
-        length: 1,
-    };
-    offset += 1;
-
-    if (details.metadata_format.value === 0xff) {
-        details.metadata_format_identifier = {
-            value: view.getUint32(offset),
-            offset: baseOffset + offset,
-            length: 4,
-        };
-        offset += 4;
-    }
-
-    details.metadata_service_id = {
-        value: view.getUint8(offset),
-        offset: baseOffset + offset,
-        length: 1,
-    };
-    offset += 1;
-
-    const flags = view.getUint8(offset);
-    details.metadata_locator_record_flag = {
-        value: (flags >> 7) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.MPEG_carriage_flags = {
-        value: (flags >> 5) & 3,
-        offset: baseOffset + offset,
-        length: 0.25,
-    };
-    offset += 1;
-
-    if (details.metadata_locator_record_flag.value) {
-        const len = view.getUint8(offset);
-        details.metadata_locator_record_length = {
-            value: len,
-            offset: baseOffset + offset,
-            length: 1,
-        };
-        offset += 1;
-        details.metadata_locator_record = {
-            value: `${len} bytes`,
-            offset: baseOffset + offset,
-            length: len,
-        };
-        offset += len;
-    }
-
-    if (details.MPEG_carriage_flags.value <= 2) {
-        details.program_number = {
-            value: view.getUint16(offset),
-            offset: baseOffset + offset,
-            length: 2,
-        };
-        offset += 2;
-    }
-
-    if (details.MPEG_carriage_flags.value === 1) {
-        details.transport_stream_location = {
-            value: view.getUint16(offset),
-            offset: baseOffset + offset,
-            length: 2,
-        };
-        offset += 2;
-        details.transport_stream_id = {
-            value: view.getUint16(offset),
-            offset: baseOffset + offset,
-            length: 2,
-        };
-        offset += 2;
-    }
-
-    const privateDataLength = view.byteLength - offset;
-    if (privateDataLength > 0) {
-        details.private_data = {
-            value: `${privateDataLength} bytes`,
-            offset: baseOffset + offset,
-            length: privateDataLength,
-        };
-    }
-
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/metadata-std.js b/js/infrastructure/segment/ts/parsers/descriptors/metadata-std.js
deleted file mode 100644
index df7bfbb..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/metadata-std.js
+++ /dev/null
@@ -1,42 +0,0 @@
-/**
- * Parses a Metadata STD (System Target Decoder) Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.62 & Table 2-89
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMetadataStdDescriptor(view, baseOffset) {
-    const details = {};
-    let offset = 0;
-
-    const byte0 = view.getUint8(offset);
-    const byte1 = view.getUint8(offset + 1);
-    const byte2 = view.getUint8(offset + 2);
-    details.metadata_input_leak_rate = {
-        value: ((byte0 & 0x3f) << 16) | (byte1 << 8) | byte2,
-        offset: baseOffset + offset,
-        length: 3,
-    };
-    offset += 3;
-
-    const byte3 = view.getUint8(offset);
-    const byte4 = view.getUint8(offset + 1);
-    const byte5 = view.getUint8(offset + 2);
-    details.metadata_buffer_size = {
-        value: ((byte3 & 0x3f) << 16) | (byte4 << 8) | byte5,
-        offset: baseOffset + offset,
-        length: 3,
-    };
-    offset += 3;
-
-    const byte6 = view.getUint8(offset);
-    const byte7 = view.getUint8(offset + 1);
-    const byte8 = view.getUint8(offset + 2);
-    details.metadata_output_leak_rate = {
-        value: ((byte6 & 0x3f) << 16) | (byte7 << 8) | byte8,
-        offset: baseOffset + offset,
-        length: 3,
-    };
-
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/metadata.js b/js/infrastructure/segment/ts/parsers/descriptors/metadata.js
deleted file mode 100644
index e19e8a9..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/metadata.js
+++ /dev/null
@@ -1,128 +0,0 @@
-/**
- * Parses a Metadata Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.60 & Table 2-87
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMetadataDescriptor(view, baseOffset) {
-    const details = {};
-    let offset = 0;
-
-    details.metadata_application_format = {
-        value: view.getUint16(offset),
-        offset: baseOffset + offset,
-        length: 2,
-    };
-    offset += 2;
-
-    if (details.metadata_application_format.value === 0xffff) {
-        details.metadata_application_format_identifier = {
-            value: view.getUint32(offset),
-            offset: baseOffset + offset,
-            length: 4,
-        };
-        offset += 4;
-    }
-
-    details.metadata_format = {
-        value: view.getUint8(offset),
-        offset: baseOffset + offset,
-        length: 1,
-    };
-    offset += 1;
-
-    if (details.metadata_format.value === 0xff) {
-        details.metadata_format_identifier = {
-            value: view.getUint32(offset),
-            offset: baseOffset + offset,
-            length: 4,
-        };
-        offset += 4;
-    }
-
-    details.metadata_service_id = {
-        value: view.getUint8(offset),
-        offset: baseOffset + offset,
-        length: 1,
-    };
-    offset += 1;
-
-    const flags = view.getUint8(offset);
-    details.decoder_config_flags = {
-        value: (flags >> 5) & 7,
-        offset: baseOffset + offset,
-        length: 0.375,
-    };
-    details.DSM_CC_flag = {
-        value: (flags >> 4) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    offset += 1;
-
-    if (details.DSM_CC_flag.value) {
-        const len = view.getUint8(offset);
-        details.service_identification_length = {
-            value: len,
-            offset: baseOffset + offset,
-            length: 1,
-        };
-        offset += 1;
-        details.service_identification_record = {
-            value: `${len} bytes`,
-            offset: baseOffset + offset,
-            length: len,
-        };
-        offset += len;
-    }
-
-    const config_flags = details.decoder_config_flags.value;
-    if (config_flags === 0b001) {
-        const len = view.getUint8(offset);
-        details.decoder_config_length = {
-            value: len,
-            offset: baseOffset + offset,
-            length: 1,
-        };
-        offset += 1;
-        details.decoder_config = {
-            value: `${len} bytes`,
-            offset: baseOffset + offset,
-            length: len,
-        };
-        offset += len;
-    } else if (config_flags === 0b011) {
-        const len = view.getUint8(offset);
-        details.dec_config_identification_record_length = {
-            value: len,
-            offset: baseOffset + offset,
-            length: 1,
-        };
-        offset += 1;
-        details.dec_config_identification_record = {
-            value: `${len} bytes`,
-            offset: baseOffset + offset,
-            length: len,
-        };
-        offset += len;
-    } else if (config_flags === 0b100) {
-        details.decoder_config_metadata_service_id = {
-            value: view.getUint8(offset),
-            offset: baseOffset + offset,
-            length: 1,
-        };
-        offset += 1;
-    }
-
-    const privateDataLength = view.byteLength - offset;
-    if (privateDataLength > 0) {
-        details.private_data = {
-            value: `${privateDataLength} bytes`,
-            offset: baseOffset + offset,
-            length: privateDataLength,
-        };
-    }
-
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/mpeg-h-3d-audio.js b/js/infrastructure/segment/ts/parsers/descriptors/mpeg-h-3d-audio.js
deleted file mode 100644
index 9ed05e9..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/mpeg-h-3d-audio.js
+++ /dev/null
@@ -1,132 +0,0 @@
-/**
- * Parses an MPEG-H 3D Audio Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1, Extension Descriptor Tag 0x08, Table 2-119
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMpegH3dAudioDescriptor(view, baseOffset) {
-    const details = {};
-    let offset = 0;
-    details.mpegh3daProfileLevelIndication = {
-        value: view.getUint8(offset),
-        offset: baseOffset + offset,
-        length: 1,
-    };
-    offset += 1;
-
-    const byte1 = view.getUint16(offset);
-    details.interactivityEnabled = {
-        value: (byte1 >> 15) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.referenceChannelLayout = {
-        value: byte1 & 0x3f,
-        offset: baseOffset + offset,
-        length: 0.75,
-    };
-    return details;
-}
-
-/**
- * Parses an MPEG-H 3D Audio Config Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1, Extension Descriptor Tag 0x09, Table 2-120
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMpegH3dAudioConfigDescriptor(view, baseOffset) {
-    return {
-        mpegh3daConfig: {
-            value: `${view.byteLength} bytes of config data`,
-            offset: baseOffset,
-            length: view.byteLength,
-        },
-    };
-}
-
-/**
- * Parses an MPEG-H 3D Audio Scene Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1, Extension Descriptor Tag 0x0A, Table 2-121
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMpegH3dAudioSceneDescriptor(view, baseOffset) {
-    return {
-        scene_info: {
-            value: `${view.byteLength} bytes of scene information`,
-            offset: baseOffset,
-            length: view.byteLength,
-        },
-    };
-}
-
-/**
- * Parses an MPEG-H 3D Audio Text Label Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1, Extension Descriptor Tag 0x0B, Table 2-122
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMpegH3dAudioTextLabelDescriptor(view, baseOffset) {
-    return {
-        text_label_info: {
-            value: `${view.byteLength} bytes of text label information`,
-            offset: baseOffset,
-            length: view.byteLength,
-        },
-    };
-}
-
-/**
- * Parses an MPEG-H 3D Audio Multi-stream Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1, Extension Descriptor Tag 0x0C, Table 2-123
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMpegH3dAudioMultiStreamDescriptor(view, baseOffset) {
-    return {
-        multistream_info: {
-            value: `${view.byteLength} bytes of multi-stream information`,
-            offset: baseOffset,
-            length: view.byteLength,
-        },
-    };
-}
-
-/**
- * Parses an MPEG-H 3D Audio DRC and Loudness Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1, Extension Descriptor Tag 0x0D, Table 2-124
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMpegH3dAudioDrcLoudnessDescriptor(view, baseOffset) {
-    return {
-        drc_loudness_info: {
-            value: `${view.byteLength} bytes of DRC/Loudness information`,
-            offset: baseOffset,
-            length: view.byteLength,
-        },
-    };
-}
-
-/**
- * Parses an MPEG-H 3D Audio Command Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1, Extension Descriptor Tag 0x0E, Table 2-125
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMpegH3dAudioCommandDescriptor(view, baseOffset) {
-    return {
-        command_data: {
-            value: `${view.byteLength} bytes of command data`,
-            offset: baseOffset,
-            length: view.byteLength,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/mpeg2-aac-audio.js b/js/infrastructure/segment/ts/parsers/descriptors/mpeg2-aac-audio.js
deleted file mode 100644
index 17fe973..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/mpeg2-aac-audio.js
+++ /dev/null
@@ -1,51 +0,0 @@
-/**
- * Parses an MPEG-2 AAC Audio Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.68 & Table 2-92
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMpeg2AacAudioDescriptor(view, baseOffset) {
-    const profile = view.getUint8(0);
-    const channelConfig = view.getUint8(1);
-    const additionalInfo = view.getUint8(2);
-
-    const profileMap = {
-        0: 'Main Profile',
-        1: 'Low Complexity Profile (LC)',
-        2: 'Scalable Sample Rate Profile (SSR)',
-        3: 'Reserved',
-    };
-
-    const channelConfigMap = {
-        1: '1 channel (mono)',
-        2: '2 channels (stereo)',
-        3: '3 channels (front: C, L, R)',
-        4: '4 channels (front: C, L, R; back: C)',
-        5: '5 channels (front: C, L, R; back: L, R)',
-        6: '5.1 channels (front: C, L, R; back: L, R; LFE)',
-    };
-
-    const additionalInfoMap = {
-        0: 'AAC data according to ISO/IEC 13818-7',
-        1: 'AAC data with Bandwidth Extension data present',
-    };
-
-    return {
-        MPEG_2_AAC_profile: {
-            value: `${profileMap[profile] || 'Reserved'} (${profile})`,
-            offset: baseOffset,
-            length: 1,
-        },
-        MPEG_2_AAC_channel_configuration: {
-            value: `${channelConfigMap[channelConfig] || 'Undefined'} (${channelConfig})`,
-            offset: baseOffset + 1,
-            length: 1,
-        },
-        MPEG_2_AAC_additional_information: {
-            value: `${additionalInfoMap[additionalInfo] || 'Reserved'} (0x${additionalInfo.toString(16).padStart(2, '0')})`,
-            offset: baseOffset + 2,
-            length: 1,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/mpeg2-stereoscopic-video-format.js b/js/infrastructure/segment/ts/parsers/descriptors/mpeg2-stereoscopic-video-format.js
deleted file mode 100644
index 0d74160..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/mpeg2-stereoscopic-video-format.js
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Parses an MPEG2_stereoscopic_video_format_descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.84 & Table 2-102
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMpeg2StereoscopicVideoFormatDescriptor(view, baseOffset) {
-    const byte = view.getUint8(0);
-    const present_flag = (byte >> 7) & 1;
-    const details = {
-        stereo_video_arrangement_type_present: {
-            value: present_flag,
-            offset: baseOffset,
-            length: 0.125,
-        },
-    };
-    if (present_flag) {
-        details.arrangement_type = {
-            value: byte & 0x7f,
-            offset: baseOffset,
-            length: 0.875,
-        };
-    }
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/mpeg4-audio-extension.js b/js/infrastructure/segment/ts/parsers/descriptors/mpeg4-audio-extension.js
deleted file mode 100644
index 6b698d5..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/mpeg4-audio-extension.js
+++ /dev/null
@@ -1,60 +0,0 @@
-/**
- * Parses an MPEG-4 Audio Extension Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.72 & Table 2-95
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMpeg4AudioExtensionDescriptor(view, baseOffset) {
-    const details = {};
-    let offset = 0;
-
-    const flagsAndLoops = view.getUint8(offset);
-    const ascFlag = (flagsAndLoops >> 7) & 1;
-    const numLoops = flagsAndLoops & 0x0f;
-
-    details.ASC_flag = {
-        value: ascFlag,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.num_of_loops = {
-        value: numLoops,
-        offset: baseOffset + offset,
-        length: 0.5,
-    };
-    offset += 1;
-
-    for (let i = 0; i < numLoops; i++) {
-        if (offset >= view.byteLength) break;
-        const profileAndLevel = view.getUint8(offset);
-        details[`audioProfileLevelIndication_${i + 1}`] = {
-            value: `0x${profileAndLevel.toString(16).padStart(2, '0')}`,
-            offset: baseOffset + offset,
-            length: 1,
-        };
-        offset += 1;
-    }
-
-    if (ascFlag) {
-        if (offset < view.byteLength) {
-            const ascSize = view.getUint8(offset);
-            details.ASC_size = {
-                value: ascSize,
-                offset: baseOffset + offset,
-                length: 1,
-            };
-            offset += 1;
-
-            if (offset + ascSize <= view.byteLength) {
-                details.audioSpecificConfig = {
-                    value: `${ascSize} bytes of AudioSpecificConfig data`,
-                    offset: baseOffset + offset,
-                    length: ascSize,
-                };
-            }
-        }
-    }
-
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/mpeg4-audio.js b/js/infrastructure/segment/ts/parsers/descriptors/mpeg4-audio.js
deleted file mode 100644
index 248d542..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/mpeg4-audio.js
+++ /dev/null
@@ -1,16 +0,0 @@
-/**
- * Parses an MPEG-4 Audio Descriptor.
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMpeg4AudioDescriptor(view, baseOffset) {
-    const profileAndLevel = view.getUint8(0);
-    return {
-        MPEG4_audio_profile_and_level: {
-            value: `0x${profileAndLevel.toString(16).padStart(2, '0')}`,
-            offset: baseOffset,
-            length: 1,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/mpeg4-text.js b/js/infrastructure/segment/ts/parsers/descriptors/mpeg4-text.js
deleted file mode 100644
index 243c2ee..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/mpeg4-text.js
+++ /dev/null
@@ -1,18 +0,0 @@
-/**
- * Parses an MPEG-4 Text Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.70
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMpeg4TextDescriptor(view, baseOffset) {
-    // The payload is the textConfig(), which is complex and format-specific.
-    // For now, we'll just indicate its presence and size.
-    return {
-        textConfig_data: {
-            value: `${view.byteLength} bytes of TextConfig data`,
-            offset: baseOffset,
-            length: view.byteLength,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/mpeg4-video.js b/js/infrastructure/segment/ts/parsers/descriptors/mpeg4-video.js
deleted file mode 100644
index 26f7fb5..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/mpeg4-video.js
+++ /dev/null
@@ -1,17 +0,0 @@
-/**
- * Parses an MPEG-4 Video Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.36 & Table 2-70
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMpeg4VideoDescriptor(view, baseOffset) {
-    const profileAndLevel = view.getUint8(0);
-    return {
-        MPEG4_visual_profile_and_level: {
-            value: `0x${profileAndLevel.toString(16).padStart(2, '0')}`,
-            offset: baseOffset,
-            length: 1,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/multiplex-buffer-utilization.js b/js/infrastructure/segment/ts/parsers/descriptors/multiplex-buffer-utilization.js
deleted file mode 100644
index 9a42c5f..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/multiplex-buffer-utilization.js
+++ /dev/null
@@ -1,27 +0,0 @@
-/**
- * Parses a Multiplex Buffer Utilization Descriptor.
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMultiplexBufferUtilizationDescriptor(view, baseOffset) {
-    const word1 = view.getUint16(0);
-    const word2 = view.getUint16(2);
-    return {
-        bound_valid_flag: {
-            value: (word1 >> 15) & 1,
-            offset: baseOffset,
-            length: 0.125,
-        },
-        LTW_offset_lower_bound: {
-            value: word1 & 0x7fff,
-            offset: baseOffset,
-            length: 1.875,
-        },
-        LTW_offset_upper_bound: {
-            value: word2 & 0x7fff,
-            offset: baseOffset + 2,
-            length: 1.875,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/multiplex-buffer.js b/js/infrastructure/segment/ts/parsers/descriptors/multiplex-buffer.js
deleted file mode 100644
index d56e785..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/multiplex-buffer.js
+++ /dev/null
@@ -1,21 +0,0 @@
-/**
- * Parses a MultiplexBuffer Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.52 & Table 2-79
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMultiplexBufferDescriptor(view, baseOffset) {
-    return {
-        MB_buffer_size: {
-            value: view.getUint32(0) & 0x00ffffff,
-            offset: baseOffset,
-            length: 3,
-        },
-        TB_leak_rate: {
-            value: view.getUint32(3) & 0x00ffffff,
-            offset: baseOffset + 3,
-            length: 3,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/muxcode.js b/js/infrastructure/segment/ts/parsers/descriptors/muxcode.js
deleted file mode 100644
index 9ae8852..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/muxcode.js
+++ /dev/null
@@ -1,18 +0,0 @@
-/**
- * Parses a MuxCode Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.48 & Table 2-77
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMuxcodeDescriptor(view, baseOffset) {
-    // The internal structure (MuxCodeTableEntry) is defined in ISO/IEC 14496-1
-    // and is treated as opaque here.
-    return {
-        mux_code_table_entry_data: {
-            value: `${view.byteLength} bytes of MuxCodeTableEntry data`,
-            offset: baseOffset,
-            length: view.byteLength,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/mvc-extension.js b/js/infrastructure/segment/ts/parsers/descriptors/mvc-extension.js
deleted file mode 100644
index d5958bd..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/mvc-extension.js
+++ /dev/null
@@ -1,64 +0,0 @@
-/**
- * Parses an MVC (Multi-view Video Coding) Extension Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.78 & Table 2-98
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMvcExtensionDescriptor(view, baseOffset) {
-    const flags = view.getUint8(4);
-    return {
-        average_bit_rate: {
-            value: view.getUint16(0),
-            offset: baseOffset,
-            length: 2,
-        },
-        maximum_bitrate: {
-            value: view.getUint16(2),
-            offset: baseOffset + 2,
-            length: 2,
-        },
-        view_association_not_present: {
-            value: (flags >> 7) & 1,
-            offset: baseOffset + 4,
-            length: 0.125,
-        },
-        base_view_is_left_eyeview: {
-            value: (flags >> 6) & 1,
-            offset: baseOffset + 4,
-            length: 0.125,
-        },
-        view_order_index_min: {
-            value: view.getUint16(5) >> 6,
-            offset: baseOffset + 5,
-            length: 1.25,
-        },
-        view_order_index_max: {
-            value:
-                ((view.getUint16(6) & 0xfc00) >> 6) |
-                ((view.getUint8(6) & 0x3f) << 4),
-            offset: baseOffset + 6,
-            length: 1.25,
-        }, // Complex packing
-        temporal_id_start: {
-            value: (view.getUint8(8) >> 5) & 7,
-            offset: baseOffset + 8,
-            length: 0.375,
-        },
-        temporal_id_end: {
-            value: (view.getUint8(8) >> 2) & 7,
-            offset: baseOffset + 8,
-            length: 0.375,
-        },
-        no_sei_nal_unit_present: {
-            value: (view.getUint8(8) >> 1) & 1,
-            offset: baseOffset + 8,
-            length: 0.125,
-        },
-        no_prefix_nal_unit_present: {
-            value: view.getUint8(8) & 1,
-            offset: baseOffset + 8,
-            length: 0.125,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/mvc-operation-point.js b/js/infrastructure/segment/ts/parsers/descriptors/mvc-operation-point.js
deleted file mode 100644
index 1aaa483..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/mvc-operation-point.js
+++ /dev/null
@@ -1,130 +0,0 @@
-/**
- * Parses an MVC (Multi-view Coding) Operation Point Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.82 & Table 2-101
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseMvcOperationPointDescriptor(view, baseOffset) {
-    const details = {};
-    let offset = 0;
-
-    details.profile_idc = {
-        value: view.getUint8(offset),
-        offset: baseOffset + offset,
-        length: 1,
-    };
-    offset += 1;
-
-    const constraintByte = view.getUint8(offset);
-    details.constraint_set0_flag = {
-        value: (constraintByte >> 7) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.constraint_set1_flag = {
-        value: (constraintByte >> 6) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.constraint_set2_flag = {
-        value: (constraintByte >> 5) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.constraint_set3_flag = {
-        value: (constraintByte >> 4) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.constraint_set4_flag = {
-        value: (constraintByte >> 3) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.constraint_set5_flag = {
-        value: (constraintByte >> 2) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.AVC_compatible_flags = {
-        value: constraintByte & 0x03,
-        offset: baseOffset + offset,
-        length: 0.25,
-    };
-    offset += 1;
-
-    const level_count = view.getUint8(offset);
-    details.level_count = {
-        value: level_count,
-        offset: baseOffset + offset,
-        length: 1,
-    };
-    offset += 1;
-
-    details.levels = [];
-    for (let i = 0; i < level_count; i++) {
-        if (offset + 2 > view.byteLength) break;
-        const level = {
-            level_idc: {
-                value: view.getUint8(offset),
-                offset: baseOffset + offset,
-                length: 1,
-            },
-            operation_points: [],
-        };
-        offset += 1;
-
-        const op_count = view.getUint8(offset);
-        level.operation_points_count = {
-            value: op_count,
-            offset: baseOffset + offset,
-            length: 1,
-        };
-        offset += 1;
-
-        for (let j = 0; j < op_count; j++) {
-            if (offset + 3 > view.byteLength) break;
-            const op_byte1 = view.getUint8(offset);
-            const op = {
-                applicable_temporal_id: {
-                    value: op_byte1 & 0x07,
-                    offset: baseOffset + offset,
-                    length: 0.375,
-                },
-                num_target_output_views: {
-                    value: view.getUint8(offset + 1),
-                    offset: baseOffset + offset + 1,
-                    length: 1,
-                },
-                es_references: [],
-            };
-            offset += 2;
-
-            const es_count = view.getUint8(offset);
-            op.ES_count = {
-                value: es_count,
-                offset: baseOffset + offset,
-                length: 1,
-            };
-            offset += 1;
-
-            for (let k = 0; k < es_count; k++) {
-                if (offset + 1 > view.byteLength) break;
-                const es_byte = view.getUint8(offset);
-                op.es_references.push({
-                    ES_reference: {
-                        value: es_byte & 0x3f,
-                        offset: baseOffset + offset,
-                        length: 0.75,
-                    },
-                });
-                offset += 1;
-            }
-            level.operation_points.push(op);
-        }
-        details.levels.push(level);
-    }
-
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/private-data-indicator.js b/js/infrastructure/segment/ts/parsers/descriptors/private-data-indicator.js
deleted file mode 100644
index c880359..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/private-data-indicator.js
+++ /dev/null
@@ -1,16 +0,0 @@
-/**
- * Parses a Private Data Indicator Descriptor.
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parsePrivateDataIndicatorDescriptor(view, baseOffset) {
-    const indicator = view.getUint32(0);
-    return {
-        private_data_indicator: {
-            value: `0x${indicator.toString(16).padStart(8, '0')}`,
-            offset: baseOffset,
-            length: 4,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/quality-extension.js b/js/infrastructure/segment/ts/parsers/descriptors/quality-extension.js
deleted file mode 100644
index 6875cc6..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/quality-extension.js
+++ /dev/null
@@ -1,43 +0,0 @@
-/**
- * Parses a Quality Extension Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1, Extension Descriptor Tag 0x0F, Table 2-126
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseQualityExtensionDescriptor(view, baseOffset) {
-    const details = {};
-    let offset = 0;
-
-    details.field_size_bytes = {
-        value: view.getUint8(offset),
-        offset: baseOffset + offset,
-        length: 1,
-    };
-    offset += 1;
-
-    const metric_count = view.getUint8(offset);
-    details.metric_count = {
-        value: metric_count,
-        offset: baseOffset + offset,
-        length: 1,
-    };
-    offset += 1;
-
-    details.metrics = [];
-    for (let i = 0; i < metric_count; i++) {
-        if (offset + 4 > view.byteLength) break;
-        if (offset + 4 > view.byteLength) break;
-        const code = view.getUint32(offset);
-        details.metrics.push({
-            metric_code: {
-                value: `0x${code.toString(16).padStart(8, '0')}`,
-                offset: baseOffset + offset,
-                length: 4,
-            },
-        });
-        offset += 4;
-    }
-
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/registration.js b/js/infrastructure/segment/ts/parsers/descriptors/registration.js
deleted file mode 100644
index b4975e4..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/registration.js
+++ /dev/null
@@ -1,40 +0,0 @@
-/**
- * Parses a Registration Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.8 & Table 2-51
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed registration descriptor.
- */
-export function parseRegistrationDescriptor(view, baseOffset) {
-    const formatIdentifier = view.getUint32(0);
-    const additionalInfoBytes = [];
-    for (let i = 4; i < view.byteLength; i++) {
-        additionalInfoBytes.push(
-            view.getUint8(i).toString(16).padStart(2, '0')
-        );
-    }
-    const formatIdentifierString = String.fromCharCode(
-        (formatIdentifier >> 24) & 0xff,
-        (formatIdentifier >> 16) & 0xff,
-        (formatIdentifier >> 8) & 0xff,
-        formatIdentifier & 0xff
-    );
-
-    return {
-        format_identifier: {
-            value: `0x${formatIdentifier
-                .toString(16)
-                .padStart(8, '0')} (${formatIdentifierString})`,
-            offset: baseOffset,
-            length: 4,
-        },
-        additional_identification_info: {
-            value:
-                additionalInfoBytes.length > 0
-                    ? additionalInfoBytes.join(' ')
-                    : 'none',
-            offset: baseOffset + 4,
-            length: additionalInfoBytes.length,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/sl.js b/js/infrastructure/segment/ts/parsers/descriptors/sl.js
deleted file mode 100644
index 8f6fe0c..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/sl.js
+++ /dev/null
@@ -1,17 +0,0 @@
-/**
- * Parses an SL (Sync Layer) Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.42
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseSlDescriptor(view, baseOffset) {
-    const esId = view.getUint16(0);
-    return {
-        ES_ID: {
-            value: esId,
-            offset: baseOffset,
-            length: 2,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/smoothing-buffer.js b/js/infrastructure/segment/ts/parsers/descriptors/smoothing-buffer.js
deleted file mode 100644
index 5e0ef31..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/smoothing-buffer.js
+++ /dev/null
@@ -1,35 +0,0 @@
-/**
- * Parses a Smoothing Buffer Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.30 & Table 2-67
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseSmoothingBufferDescriptor(view, baseOffset) {
-    if (view.byteLength < 6) {
-        return { error: 'Payload too short for SmoothingBufferDescriptor' };
-    }
-
-    const byte0 = view.getUint8(0);
-    const byte1 = view.getUint8(1);
-    const byte2 = view.getUint8(2);
-    const sb_leak_rate = ((byte0 & 0x3f) << 16) | (byte1 << 8) | byte2;
-
-    const byte3 = view.getUint8(3);
-    const byte4 = view.getUint8(4);
-    const byte5 = view.getUint8(5);
-    const sb_size = ((byte3 & 0x3f) << 16) | (byte4 << 8) | byte5;
-
-    return {
-        sb_leak_rate: {
-            value: `${sb_leak_rate * 400} bps`,
-            offset: baseOffset,
-            length: 3,
-        },
-        sb_size: {
-            value: `${sb_size} bytes`,
-            offset: baseOffset + 3,
-            length: 3,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/std.js b/js/infrastructure/segment/ts/parsers/descriptors/std.js
deleted file mode 100644
index 68e2354..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/std.js
+++ /dev/null
@@ -1,15 +0,0 @@
-/**
- * Parses an STD Descriptor.
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseStdDescriptor(view, baseOffset) {
-    return {
-        leak_valid_flag: {
-            value: view.getUint8(0) & 1,
-            offset: baseOffset,
-            length: 0.125,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/stereoscopic-program-info.js b/js/infrastructure/segment/ts/parsers/descriptors/stereoscopic-program-info.js
deleted file mode 100644
index 6a28c9d..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/stereoscopic-program-info.js
+++ /dev/null
@@ -1,23 +0,0 @@
-/**
- * Parses a Stereoscopic_program_info_descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.86 & Table 2-103
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseStereoscopicProgramInfoDescriptor(view, baseOffset) {
-    const byte = view.getUint8(0);
-    const type = byte & 0x07;
-    const typeMap = {
-        1: '2D-only (monoscopic)',
-        2: 'Frame-compatible stereoscopic 3D',
-        3: 'Service-compatible stereoscopic 3D',
-    };
-    return {
-        stereoscopic_service_type: {
-            value: typeMap[type] || `Reserved (${type})`,
-            offset: baseOffset,
-            length: 0.375,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/stereoscopic-video-info.js b/js/infrastructure/segment/ts/parsers/descriptors/stereoscopic-video-info.js
deleted file mode 100644
index 577afb5..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/stereoscopic-video-info.js
+++ /dev/null
@@ -1,49 +0,0 @@
-/**
- * Parses a Stereoscopic_video_info_descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.88 & Table 2-105
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseStereoscopicVideoInfoDescriptor(view, baseOffset) {
-    const byte = view.getUint8(0);
-    const base_video_flag = byte & 1;
-    const details = {
-        base_video_flag: {
-            value: base_video_flag,
-            offset: baseOffset,
-            length: 0.125,
-        },
-    };
-
-    if (base_video_flag) {
-        if (view.byteLength > 1) {
-            const byte2 = view.getUint8(1);
-            details.leftview_flag = {
-                value: byte2 & 1,
-                offset: baseOffset + 1,
-                length: 0.125,
-            };
-        }
-    } else {
-        if (view.byteLength > 1) {
-            const byte2 = view.getUint8(1);
-            details.usable_as_2D = {
-                value: (byte2 >> 7) & 1,
-                offset: baseOffset + 1,
-                length: 0.125,
-            };
-            details.horizontal_upsampling_factor = {
-                value: (byte2 >> 3) & 0x0f,
-                offset: baseOffset + 1,
-                length: 0.5,
-            };
-            details.vertical_upsampling_factor = {
-                value: ((byte2 & 7) << 1) | (view.getUint8(2) >> 7),
-                offset: baseOffset + 1.625,
-                length: 0.5,
-            };
-        }
-    }
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/svc-extension.js b/js/infrastructure/segment/ts/parsers/descriptors/svc-extension.js
deleted file mode 100644
index 32a5e16..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/svc-extension.js
+++ /dev/null
@@ -1,60 +0,0 @@
-/**
- * Parses an SVC (Scalable Video Coding) Extension Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.76 & Table 2-97
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseSvcExtensionDescriptor(view, baseOffset) {
-    const byte8 = view.getUint8(8);
-    const byte9 = view.getUint8(9);
-    return {
-        width: { value: view.getUint16(0), offset: baseOffset, length: 2 },
-        height: { value: view.getUint16(2), offset: baseOffset + 2, length: 2 },
-        frame_rate: {
-            value: view.getUint16(4),
-            offset: baseOffset + 4,
-            length: 2,
-        },
-        average_bitrate: {
-            value: view.getUint16(6),
-            offset: baseOffset + 6,
-            length: 2,
-        },
-        maximum_bitrate: {
-            value: view.getUint16(8),
-            offset: baseOffset + 8,
-            length: 2,
-        },
-        dependency_id: {
-            value: (byte8 >> 5) & 0x07,
-            offset: baseOffset + 10,
-            length: 0.375,
-        },
-        quality_id_start: {
-            value: (byte8 >> 1) & 0x0f,
-            offset: baseOffset + 10.5,
-            length: 0.5,
-        },
-        quality_id_end: {
-            value: ((byte8 & 1) << 3) | (byte9 >> 5),
-            offset: baseOffset + 10.875,
-            length: 0.5,
-        },
-        temporal_id_start: {
-            value: (byte9 >> 2) & 0x07,
-            offset: baseOffset + 11.375,
-            length: 0.375,
-        },
-        temporal_id_end: {
-            value: ((byte9 & 0x03) << 1) | (view.getUint8(10) >> 7),
-            offset: baseOffset + 11.75,
-            length: 0.375,
-        },
-        no_sei_nal_unit_present: {
-            value: (view.getUint8(10) >> 6) & 1,
-            offset: baseOffset + 12.125,
-            length: 0.125,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/system-clock.js b/js/infrastructure/segment/ts/parsers/descriptors/system-clock.js
deleted file mode 100644
index ef35455..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/system-clock.js
+++ /dev/null
@@ -1,27 +0,0 @@
-/**
- * Parses a System Clock Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.20 & Table 2-62
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseSystemClockDescriptor(view, baseOffset) {
-    const byte = view.getUint8(0);
-    return {
-        external_clock_reference_indicator: {
-            value: (byte >> 7) & 1,
-            offset: baseOffset,
-            length: 0.125,
-        },
-        clock_accuracy_integer: {
-            value: (byte >> 1) & 0x3f,
-            offset: baseOffset,
-            length: 0.75,
-        }, // Corrected parsing
-        clock_accuracy_exponent: {
-            value: (view.getUint8(1) >> 5) & 0x07,
-            offset: baseOffset + 1,
-            length: 0.375,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/target-background-grid.js b/js/infrastructure/segment/ts/parsers/descriptors/target-background-grid.js
deleted file mode 100644
index 62c5a3f..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/target-background-grid.js
+++ /dev/null
@@ -1,28 +0,0 @@
-/**
- * Parses a Target Background Grid Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.12
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseTargetBackgroundGridDescriptor(view, baseOffset) {
-    const word1 = view.getUint16(0);
-    const word2 = view.getUint16(2);
-    return {
-        horizontal_size: {
-            value: word1 >> 2,
-            offset: baseOffset,
-            length: 1.75,
-        },
-        vertical_size: {
-            value: ((word1 & 0x03) << 12) | (word2 >> 4),
-            offset: baseOffset + 1.75,
-            length: 1.75,
-        },
-        aspect_ratio_information: {
-            value: word2 & 0x0f,
-            offset: baseOffset + 3.5,
-            length: 0.5,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/timeline.js b/js/infrastructure/segment/ts/parsers/descriptors/timeline.js
deleted file mode 100644
index ff24f78..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/timeline.js
+++ /dev/null
@@ -1,136 +0,0 @@
-/**
- * Parses a 64-bit NTP timestamp into an ISO 8601 string.
- * The NTP epoch is January 1, 1900. The Unix epoch is January 1, 1970.
- * The difference is 2208988800 seconds.
- * @param {DataView} view
- * @param {number} offset
- * @returns {string} Formatted NTP timestamp as an ISO string.
- */
-function parseNtpTimestamp(view, offset) {
-    const seconds = view.getUint32(offset);
-    const fraction = view.getUint32(offset + 4);
-    // Convert NTP seconds to Unix milliseconds, and add fractional part in milliseconds
-    const date = new Date(
-        (seconds - 2208988800) * 1000 + (fraction / 0x100000000) * 1000
-    );
-    return date.toISOString();
-}
-
-/**
- * Parses a Timeline Descriptor as per ISO/IEC 13818-1, Annex U.3.6.
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed timeline descriptor details.
- */
-export function parseTimelineDescriptor(view, baseOffset) {
-    const details = {};
-    let offset = 0;
-
-    const byte1 = view.getUint8(offset);
-    const has_timestamp = (byte1 >> 6) & 0x03;
-    const has_ntp = (byte1 >> 5) & 1;
-    const has_ptp = (byte1 >> 4) & 1;
-    const has_timecode = (byte1 >> 2) & 0x03;
-    const force_reload = (byte1 >> 1) & 1;
-    const paused = byte1 & 1;
-    details.has_timestamp = {
-        value: has_timestamp,
-        offset: baseOffset + offset,
-        length: 0.25,
-    };
-    details.has_ntp = {
-        value: has_ntp,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.has_ptp = {
-        value: has_ptp,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.has_timecode = {
-        value: has_timecode,
-        offset: baseOffset + offset,
-        length: 0.25,
-    };
-    details.force_reload = {
-        value: force_reload,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    details.paused = {
-        value: paused,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    offset += 1;
-
-    // Based on the standard's table layout, discontinuity and timeline_id follow.
-    const byte2 = view.getUint8(offset);
-    details.discontinuity = {
-        value: (byte2 >> 7) & 1,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    offset += 1;
-
-    details.timeline_id = {
-        value: view.getUint8(offset),
-        offset: baseOffset + offset,
-        length: 1,
-    };
-    offset += 1;
-
-    if (has_timestamp) {
-        details.timescale = {
-            value: view.getUint32(offset),
-            offset: baseOffset + offset,
-            length: 4,
-        };
-        offset += 4;
-        if (has_timestamp === 1) {
-            details.media_timestamp = {
-                value: view.getUint32(offset),
-                offset: baseOffset + offset,
-                length: 4,
-            };
-            offset += 4;
-        } else if (has_timestamp === 2) {
-            details.media_timestamp = {
-                value: view.getBigUint64(offset).toString(),
-                offset: baseOffset + offset,
-                length: 8,
-            };
-            offset += 8;
-        }
-    }
-
-    if (has_ntp) {
-        details.ntp_timestamp = {
-            value: parseNtpTimestamp(view, offset),
-            offset: baseOffset + offset,
-            length: 8,
-        };
-        offset += 8;
-    }
-
-    if (has_ptp) {
-        details.ptp_timestamp = {
-            value: 'PTP data present',
-            offset: baseOffset + offset,
-            length: 10,
-        };
-        offset += 10;
-    }
-
-    if (has_timecode) {
-        const remainingBytes = view.byteLength - offset;
-        details.timecode_data = {
-            value: `Timecode data present (${remainingBytes} bytes)`,
-            offset: baseOffset + offset,
-            length: remainingBytes,
-        };
-    }
-
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/tooltips.js b/js/infrastructure/segment/ts/parsers/descriptors/tooltips.js
deleted file mode 100644
index 3671c09..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/tooltips.js
+++ /dev/null
@@ -1,555 +0,0 @@
-import { adaptationFieldTooltipData } from '../../parsers/adaptation-field.js';
-import { catTooltipData } from '../../parsers/cat.js';
-import { dsmccTooltipData } from '../../parsers/dsm-cc.js';
-import { ipmpTooltipData } from '../../parsers/ipmp.js';
-import { patTooltipData } from '../../parsers/pat.js';
-import { pmtTooltipData } from '../../parsers/pmt.js';
-import { pesTooltipData } from '../../parsers/pes.js';
-import { privateSectionTooltipData } from '../../parsers/private-section.js';
-import { tsdtTooltipData } from '../../parsers/tsdt.js';
-import { afDescriptorTooltipData } from './af-tooltips.js';
-
-const metadataTooltipData = {
-    content_labeling_descriptor: {
-        text: 'Assigns a label to content, which can be used by metadata to reference the associated content.',
-        ref: 'Clause 2.6.56',
-    },
-    metadata_pointer_descriptor: {
-        text: 'Points to a single metadata service and associates it with audiovisual content.',
-        ref: 'Clause 2.6.58',
-    },
-    metadata_descriptor: {
-        text: 'Specifies parameters of a metadata service carried in the stream, such as its format and decoder configuration.',
-        ref: 'Clause 2.6.60',
-    },
-    metadata_STD_descriptor: {
-        text: 'Defines parameters of the System Target Decoder (STD) model for processing the associated metadata stream.',
-        ref: 'Clause 2.6.62',
-    },
-};
-
-const hevcTooltipData = {
-    HEVC_video_descriptor: {
-        text: 'Provides basic information for identifying coding parameters of an HEVC (H.265) video stream.',
-        ref: 'Clause 2.6.95',
-    },
-    'HEVC_video_descriptor@profile_idc': {
-        text: 'Indicates the profile to which the HEVC stream conforms.',
-        ref: 'Clause 2.6.96',
-    },
-    'HEVC_video_descriptor@level_idc': {
-        text: 'Indicates the level to which the HEVC stream conforms.',
-        ref: 'Clause 2.6.96',
-    },
-    'HEVC_video_descriptor@tier_flag': {
-        text: 'Indicates the tier (Main or High) of the HEVC stream.',
-        ref: 'Clause 2.6.96',
-    },
-    'HEVC_video_descriptor@temporal_layer_subset_flag': {
-        text: 'If set to 1, indicates that syntax elements describing a subset of temporal layers are included.',
-        ref: 'Clause 2.6.96',
-    },
-    HEVC_timing_and_HRD_descriptor: {
-        text: 'Provides timing and Hypothetical Reference Decoder (HRD) parameters for an HEVC stream. This is an Extension Descriptor.',
-        ref: 'Clause 2.6.97',
-    },
-    'HEVC_timing_and_HRD_descriptor@hrd_management_valid_flag': {
-        text: 'If set to 1, indicates that HRD management is active and Buffering Period/Picture Timing SEIs shall be present.',
-        ref: 'Clause 2.6.98',
-    },
-    HEVC_hierarchy_extension_descriptor: {
-        text: 'Provides information to identify components of layered HEVC streams (e.g., SHVC, MV-HEVC). This is an Extension Descriptor.',
-        ref: 'Clause 2.6.102',
-    },
-    'HEVC_hierarchy_extension_descriptor@extension_dimension_bits': {
-        text: 'A 16-bit field indicating the enhancement dimensions present (e.g., multi-view, spatial scalability).',
-        ref: 'Clause 2.6.103, Table 2-117',
-    },
-    'HEVC_hierarchy_extension_descriptor@hierarchy_layer_index': {
-        text: 'A unique index for this program element in the coding layer hierarchy.',
-        ref: 'Clause 2.6.103',
-    },
-    'HEVC_hierarchy_extension_descriptor@nuh_layer_id': {
-        text: 'Specifies the highest nuh_layer_id of the NAL units in the elementary stream associated with this descriptor.',
-        ref: 'Clause 2.6.103',
-    },
-    HEVC_operation_point_descriptor: {
-        text: 'Provides a method to indicate profile and level for one or more HEVC operation points (for layered video).',
-        ref: 'Clause 2.6.100',
-    },
-    Green_extension_descriptor: {
-        text: 'Contains static metadata related to energy-efficient media consumption (Green Metadata).',
-        ref: 'Clause 2.6.104 / ISO/IEC 23001-11',
-    },
-    MPEG_H_3dAudio_descriptor: {
-        text: 'Provides basic coding information for an MPEG-H 3D Audio stream.',
-        ref: 'Clause 2.6.106 / ISO/IEC 23008-3',
-    },
-    Quality_extension_descriptor: {
-        text: 'Describes quality metrics that are present in each Quality Access Unit for dynamic quality metadata.',
-        ref: 'Clause 2.6.119 / ISO/IEC 23001-10',
-    },
-    Virtual_segmentation_descriptor: {
-        text: 'Indicates that an elementary stream is virtually segmented, often used for ad insertion or cloud DVR.',
-        ref: 'Clause 2.6.120',
-    },
-    HEVC_tile_substream_descriptor: {
-        text: 'Assigns an ID to an HEVC tile substream, used for panoramic/Region-of-Interest streaming.',
-        ref: 'Clause 2.6.122',
-    },
-    HEVC_subregion_descriptor: {
-        text: 'Signals patterns of SubstreamIDs that belong to a subregion for HEVC tiled streaming.',
-        ref: 'Clause 2.6.125',
-    },
-};
-
-const descriptorTooltipData = {
-    ...metadataTooltipData,
-    ...afDescriptorTooltipData,
-    ...hevcTooltipData,
-    CA_descriptor: {
-        text: 'Conditional Access Descriptor. Provides information about the CA system used for scrambling.',
-        ref: 'Clause 2.6.16',
-    },
-    'CA_descriptor@ca_system_ID': {
-        text: 'A 16-bit identifier for the Conditional Access system.',
-        ref: 'Clause 2.6.17',
-    },
-    'CA_descriptor@ca_PID': {
-        text: 'The PID of the transport stream packets that carry the EMM or ECM data for this CA system.',
-        ref: 'Clause 2.6.17',
-    },
-    video_stream_descriptor: {
-        text: 'Provides basic coding parameters of a video elementary stream.',
-        ref: 'Clause 2.6.2',
-    },
-    audio_stream_descriptor: {
-        text: 'Provides basic information which identifies the coding version of an audio elementary stream.',
-        ref: 'Clause 2.6.4',
-    },
-    AVC_video_descriptor: {
-        text: 'Provides basic information for identifying coding parameters of an AVC (H.264) video stream.',
-        ref: 'Clause 2.6.64',
-    },
-    AVC_timing_and_HRD_descriptor: {
-        text: 'Provides timing and Hypothetical Reference Decoder (HRD) parameters of the associated AVC video stream.',
-        ref: 'Clause 2.6.66',
-    },
-    'AVC_timing_and_HRD_descriptor@hrd_management_valid_flag': {
-        text: 'If set to 1, indicates that HRD management is active and Buffering Period/Picture Timing SEIs shall be present.',
-        ref: 'Clause 2.6.67',
-    },
-    'AVC_timing_and_HRD_descriptor@picture_and_timing_info_present': {
-        text: 'If set to 1, indicates that detailed timing information (90kHz flag, N, K, etc.) is present in the descriptor.',
-        ref: 'Clause 2.6.67',
-    },
-    'AVC_timing_and_HRD_descriptor@90kHz_flag': {
-        text: 'If set to 1, indicates the AVC time base is 90 kHz. If 0, N and K are used to define the time base.',
-        ref: 'Clause 2.6.67',
-    },
-    'AVC_timing_and_HRD_descriptor@fixed_frame_rate_flag': {
-        text: 'If set to 1, indicates that the coded frame rate is constant within the AVC stream.',
-        ref: 'Clause 2.6.67',
-    },
-    MPEG2_AAC_audio_descriptor: {
-        text: 'Provides basic information for identifying the coding parameters of an MPEG-2 AAC audio elementary stream.',
-        ref: 'Clause 2.6.68',
-    },
-    'MPEG2_AAC_audio_descriptor@MPEG_2_AAC_profile': {
-        text: 'Indicates the AAC profile (e.g., Main, LC, SSR) according to ISO/IEC 13818-7.',
-        ref: 'Clause 2.6.69',
-    },
-    'MPEG2_AAC_audio_descriptor@MPEG_2_AAC_channel_configuration': {
-        text: 'Indicates the number and configuration of audio channels (e.g., mono, stereo, 5.1).',
-        ref: 'Clause 2.6.69',
-    },
-    'MPEG2_AAC_audio_descriptor@MPEG_2_AAC_additional_information': {
-        text: 'Indicates whether features like Bandwidth Extension (SBR) are present.',
-        ref: 'Clause 2.6.69',
-    },
-    hierarchy_descriptor: {
-        text: 'Identifies program elements of hierarchically-coded video, audio, and private streams.',
-        ref: 'Clause 2.6.6',
-    },
-    registration_descriptor: {
-        text: 'Provides a method to uniquely and unambiguously identify formats of private data.',
-        ref: 'Clause 2.6.8',
-    },
-    'registration_descriptor@format_identifier': {
-        text: 'A 32-bit value obtained from a Registration Authority that identifies the private format. Often represented as a four-character code (e.g., "CUEI" for SCTE-35).',
-        ref: 'Clause 2.6.9',
-    },
-    ISO_639_language_descriptor: {
-        text: 'Specifies the language of an audio or text program element.',
-        ref: 'Clause 2.6.18',
-    },
-    'ISO_639_language_descriptor@language': {
-        text: 'A 3-character language code as specified by ISO 639-2.',
-        ref: 'Clause 2.6.19',
-    },
-    'ISO_639_language_descriptor@audio_type': {
-        text: 'Specifies the type of audio service (e.g., clean effects, hearing impaired).',
-        ref: 'Clause 2.6.19, Table 2-61',
-    },
-    data_stream_alignment_descriptor: {
-        text: 'Describes the type of alignment present in the elementary stream when the data_alignment_indicator in the PES header is set.',
-        ref: 'Clause 2.6.10',
-    },
-    'data_stream_alignment_descriptor@alignment_type': {
-        text: 'Indicates the syntax element on which the stream is aligned (e.g., Access Unit, GOP, Slice). The meaning is context-dependent based on the stream type.',
-        ref: 'Clause 2.6.11, Tables 2-53 to 2-56',
-    },
-    'MPEG-4_video_descriptor': {
-        text: 'Provides basic information for identifying the coding parameters of an MPEG-4 Visual elementary stream.',
-        ref: 'Clause 2.6.36',
-    },
-    'MPEG-4_video_descriptor@MPEG4_visual_profile_and_level': {
-        text: 'An 8-bit field identifying the profile and level of the MPEG-4 Visual stream.',
-        ref: 'Clause 2.6.37',
-    },
-    'MPEG-4_audio_descriptor': {
-        text: 'Provides basic information for identifying the coding parameters of an MPEG-4 audio stream.',
-        ref: 'Clause 2.6.38',
-    },
-    'MPEG-4_audio_descriptor@MPEG4_audio_profile_and_level': {
-        text: 'An 8-bit field identifying the profile and level of the MPEG-4 audio stream.',
-        ref: 'Clause 2.6.39, Table 2-72',
-    },
-    'MPEG-4_text_descriptor': {
-        text: 'Carries the TextConfig() structure for an ISO/IEC 14496-17 text stream.',
-        ref: 'Clause 2.6.70',
-    },
-    'AVC_video_descriptor@profile_idc': {
-        text: 'Indicates the profile to which the AVC stream conforms (e.g., 66=Baseline, 77=Main, 100=High).',
-        ref: 'Table 2-92 / H.264 Spec',
-    },
-    'AVC_video_descriptor@level_idc': {
-        text: 'Indicates the level to which the AVC stream conforms.',
-        ref: 'Table 2-92 / H.264 Spec',
-    },
-    'AVC_video_descriptor@constraint_set0_flag': {
-        text: 'A constraint flag for Baseline Profile.',
-        ref: 'Table 2-92 / H.264 Spec',
-    },
-    'AVC_video_descriptor@constraint_set1_flag': {
-        text: 'A constraint flag for Main Profile.',
-        ref: 'Table 2-92 / H.264 Spec',
-    },
-    'AVC_video_descriptor@constraint_set2_flag': {
-        text: 'A constraint flag for Extended Profile.',
-        ref: 'Table 2-92 / H.264 Spec',
-    },
-    'AVC_video_descriptor@AVC_still_present': {
-        text: 'If set to 1, indicates that the stream may include AVC still pictures.',
-        ref: 'Table 2-92',
-    },
-    'AVC_video_descriptor@AVC_24_hour_picture_flag': {
-        text: 'If set to 1, indicates the stream may contain pictures with a presentation time more than 24 hours in the future.',
-        ref: 'Table 2-92',
-    },
-    'hierarchy_descriptor@hierarchy_type': {
-        text: 'Defines the hierarchical relation between this layer and its embedded layer (e.g., Spatial, SNR, Temporal, MVC).',
-        ref: 'Clause 2.6.7, Table 2-50',
-    },
-    'hierarchy_descriptor@hierarchy_layer_index': {
-        text: 'A unique index for this program element in the coding layer hierarchy.',
-        ref: 'Clause 2.6.7',
-    },
-    'hierarchy_descriptor@hierarchy_embedded_layer_index': {
-        text: 'The index of the program element that this layer depends on for decoding.',
-        ref: 'Clause 2.6.7',
-    },
-    IBP_descriptor: {
-        text: 'Provides information on the GOP structure of an MPEG-2 video stream.',
-        ref: 'Clause 2.6.34',
-    },
-    'IBP_descriptor@closed_gop_flag': {
-        text: 'If set to 1, indicates that all GOPs are closed (i.e., can be decoded without reference to a previous GOP).',
-        ref: 'Clause 2.6.35',
-    },
-    'IBP_descriptor@identical_gop_flag': {
-        text: 'If set to 1, indicates that the GOP structure (sequence of I, P, B frames) is the same throughout the sequence.',
-        ref: 'Clause 2.6.35',
-    },
-    'IBP_descriptor@max_gop_length': {
-        text: 'Indicates the maximum number of pictures between any two consecutive I-pictures.',
-        ref: 'Clause 2.6.35',
-    },
-    maximum_bitrate_descriptor: {
-        text: 'Specifies the maximum bitrate of the program element or program.',
-        ref: 'Clause 2.6.26',
-    },
-    'maximum_bitrate_descriptor@maximum_bitrate': {
-        text: 'An upper bound of the bitrate in units of 50 bytes/second, including transport overhead.',
-        ref: 'Clause 2.6.27',
-    },
-    private_data_indicator_descriptor: {
-        text: 'Indicates the presence of a specific private data format.',
-        ref: 'Clause 2.6.28',
-    },
-    'private_data_indicator_descriptor@private_data_indicator': {
-        text: 'A 32-bit value whose meaning is privately defined, but should correspond to a registered format identifier.',
-        ref: 'Clause 2.6.29',
-    },
-    system_clock_descriptor: {
-        text: 'Conveys information about the system clock that was used to generate timestamps.',
-        ref: 'Clause 2.6.20',
-    },
-    'system_clock_descriptor@external_clock_reference_indicator': {
-        text: 'If set to 1, indicates the system clock was derived from an external frequency reference.',
-        ref: 'Clause 2.6.21',
-    },
-    'system_clock_descriptor@clock_accuracy_integer': {
-        text: 'The integer part of the clock accuracy value.',
-        ref: 'Clause 2.6.21',
-    },
-    'system_clock_descriptor@clock_accuracy_exponent': {
-        text: 'The exponent part of the clock accuracy value, used to calculate accuracy in parts-per-million.',
-        ref: 'Clause 2.6.21',
-    },
-    Extension_descriptor: {
-        text: 'Provides a mechanism to extend the descriptor range using an extended tag.',
-        ref: 'Clause 2.6.90',
-    },
-    'Extension_descriptor@extension_descriptor_tag': {
-        text: 'An 8-bit tag that identifies the nested descriptor.',
-        ref: 'Clause 2.6.91, Table 2-108',
-    },
-    'Extension_descriptor@nested_descriptor_name': {
-        text: 'The name of the descriptor identified by the extension tag.',
-        ref: 'Clause 2.6.91',
-    },
-    copyright_descriptor: {
-        text: 'Provides a method to enable audiovisual works identification.',
-        ref: 'Clause 2.6.24',
-    },
-    'copyright_descriptor@copyright_identifier': {
-        text: 'A 32-bit value obtained from a Registration Authority that identifies the work type (e.g., ISAN, ISBN).',
-        ref: 'Clause 2.6.25',
-    },
-    smoothing_buffer_descriptor: {
-        text: 'Conveys the size of a smoothing buffer and the associated leak rate for the program element.',
-        ref: 'Clause 2.6.30',
-    },
-    'smoothing_buffer_descriptor@sb_leak_rate': {
-        text: 'The value of the leak rate out of the smoothing buffer in units of 400 bits/s.',
-        ref: 'Clause 2.6.31',
-    },
-    'smoothing_buffer_descriptor@sb_size': {
-        text: 'The size of the smoothing buffer in units of 1 byte.',
-        ref: 'Clause 2.6.31',
-    },
-    multiplex_buffer_utilization_descriptor: {
-        text: 'Provides bounds on the occupancy of the STD multiplex buffer, intended for use by re-multiplexers.',
-        ref: 'Clause 2.6.22',
-    },
-    'multiplex_buffer_utilization_descriptor@bound_valid_flag': {
-        text: 'A flag indicating if the lower and upper bound fields are valid.',
-        ref: 'Clause 2.6.23',
-    },
-    'multiplex_buffer_utilization_descriptor@LTW_offset_lower_bound': {
-        text: 'The lowest value that any Legal Time Window (LTW) offset field would have in the stream.',
-        ref: 'Clause 2.6.23',
-    },
-    'multiplex_buffer_utilization_descriptor@LTW_offset_upper_bound': {
-        text: 'The largest value that any Legal Time Window (LTW) offset field would have in the stream.',
-        ref: 'Clause 2.6.23',
-    },
-    STD_descriptor: {
-        text: 'Applies only to the T-STD model for MPEG-2 video streams.',
-        ref: 'Clause 2.6.32',
-    },
-    'STD_descriptor@leak_valid_flag': {
-        text: 'If 1, the T-STD uses the leak method for buffer transfer. If 0, it uses the vbv_delay method.',
-        ref: 'Clause 2.6.33',
-    },
-    target_background_grid_descriptor: {
-        text: 'Describes a grid of unit pixels projected on to the display area for video windowing.',
-        ref: 'Clause 2.6.12',
-    },
-    'target_background_grid_descriptor@horizontal_size': {
-        text: 'The horizontal size of the target background grid in pixels.',
-        ref: 'Clause 2.6.13',
-    },
-    'target_background_grid_descriptor@vertical_size': {
-        text: 'The vertical size of the target background grid in pixels.',
-        ref: 'Clause 2.6.13',
-    },
-    'target_background_grid_descriptor@aspect_ratio_information': {
-        text: 'Specifies the sample or display aspect ratio of the target background grid.',
-        ref: 'Clause 2.6.13',
-    },
-    video_window_descriptor: {
-        text: 'Describes the window characteristics of the associated video elementary stream, relative to the target background grid.',
-        ref: 'Clause 2.6.14',
-    },
-    'video_window_descriptor@horizontal_offset': {
-        text: 'The horizontal position of the top left pixel of the video window on the target grid.',
-        ref: 'Clause 2.6.15',
-    },
-    'video_window_descriptor@vertical_offset': {
-        text: 'The vertical position of the top left pixel of the video window on the target grid.',
-        ref: 'Clause 2.6.15',
-    },
-    'video_window_descriptor@window_priority': {
-        text: 'Indicates the front-to-back ordering of overlapping windows (0=lowest, 15=highest).',
-        ref: 'Clause 2.6.15',
-    },
-    IOD_descriptor: {
-        text: 'Encapsulates the InitialObjectDescriptor, which is the entry point to an ISO/IEC 14496 (MPEG-4) scene.',
-        ref: 'Clause 2.6.40',
-    },
-    SL_descriptor: {
-        text: 'Associates an ISO/IEC 14496-1 ES_ID with an elementary stream carried in PES packets.',
-        ref: 'Clause 2.6.42',
-    },
-    'SL_descriptor@ES_ID': {
-        text: 'The 16-bit identifier of the ISO/IEC 14496-1 SL-packetized stream.',
-        ref: 'Clause 2.6.43',
-    },
-    FMC_descriptor: {
-        text: 'Associates FlexMux channels to the ES_ID values of the SL-packetized streams within a FlexMux stream.',
-        ref: 'Clause 2.6.44',
-    },
-    'FMC_descriptor@ES_ID': {
-        text: 'The ES_ID of an SL-packetized stream within the FlexMux.',
-        ref: 'Clause 2.6.45',
-    },
-    'FMC_descriptor@FlexMuxChannel': {
-        text: 'The FlexMux channel number used for this SL-packetized stream.',
-        ref: 'Clause 2.6.45',
-    },
-    SVC_extension_descriptor: {
-        text: 'Provides detailed information about an SVC (Scalable Video Coding) video sub-bitstream.',
-        ref: 'Clause 2.6.76',
-    },
-    MVC_extension_descriptor: {
-        text: 'Provides detailed information about an MVC (Multi-view Coding) video sub-bitstream.',
-        ref: 'Clause 2.6.78',
-    },
-    FlexMuxTiming_descriptor: {
-        text: 'Conveys timing information for an ISO/IEC 14496-1 FlexMux stream.',
-        ref: 'Clause 2.6.54',
-    },
-    multiplexBuffer_descriptor: {
-        text: 'Conveys the size of the multiplex buffer (MBn) and the leak rate (Rxn) from the transport buffer (TBn) for an ISO/IEC 14496 stream.',
-        ref: 'Clause 2.6.52',
-    },
-    MPEG2_stereoscopic_video_format_descriptor: {
-        text: 'Indicates the type of stereoscopic video format included in the user_data of an MPEG-2 video elementary stream.',
-        ref: 'Clause 2.6.84',
-    },
-    Stereoscopic_program_info_descriptor: {
-        text: 'Specifies the type of stereoscopic service, such as monoscopic, frame-compatible, or service-compatible.',
-        ref: 'Clause 2.6.86',
-    },
-    Stereoscopic_video_info_descriptor: {
-        text: 'Provides information for service-compatible stereoscopic 3D services that carry left and right views in separate video streams.',
-        ref: 'Clause 2.6.88',
-    },
-    Transport_profile_descriptor: {
-        text: 'Signals a profile value of the transport stream for the associated program, indicating specific constraints (e.g., for adaptive streaming).',
-        ref: 'Clause 2.6.93',
-    },
-    J2K_video_descriptor: {
-        text: 'Provides information for identifying and decoding a JPEG 2000 video elementary stream.',
-        ref: 'Clause 2.6.80',
-    },
-    'J2K_video_descriptor@profile_and_level': {
-        text: 'Specifies the profile and level of the JPEG 2000 video stream, corresponding to the Rsiz value in the codestream.',
-        ref: 'Clause 2.6.81',
-    },
-    'J2K_video_descriptor@extended_capability_flag': {
-        text: 'Indicates if the stream uses extended color specification and may have capabilities like stripes or blocks.',
-        ref: 'Clause 2.6.81',
-    },
-    'SEMANTIC-PTS-FREQ': {
-        text: 'Validates that the time interval between consecutive Presentation Time Stamps (PTS) for any single elementary stream does not exceed 0.7 seconds.',
-        ref: 'Clause 2.7.4',
-    },
-    'SEMANTIC-PTS-DISCONT': {
-        text: 'Validates that a Presentation Time Stamp (PTS) is present for the first access unit following a discontinuity.',
-        ref: 'Clause 2.7.5',
-    },
-    'SEMANTIC-TB-OVERFLOW': {
-        text: 'Validates that the Transport Buffer (TBn) in the T-STD model does not overflow for any elementary stream.',
-        ref: 'Clause 2.4.2.7',
-    },
-    'SEMANTIC-PCR-FREQ': {
-        text: 'Validates that the time interval between consecutive Program Clock References (PCRs) for a program does not exceed 0.1 seconds.',
-        ref: 'Clause 2.7.2',
-    },
-    'SEMANTIC-CC-ERROR': {
-        text: 'Checks for unexpected jumps in the continuity_counter for a PID, which indicates potential packet loss.',
-        ref: 'Clause 2.4.3.3',
-    },
-    MPEG4_audio_extension_descriptor: {
-        text: 'Carries additional audio profile/level indications and optionally the AudioSpecificConfig for an MPEG-4 audio stream.',
-        ref: 'Clause 2.6.72',
-    },
-    'MPEG4_audio_extension_descriptor@ASC_flag': {
-        text: 'If set to 1, indicates that the AudioSpecificConfig (ASC) data is present in this descriptor.',
-        ref: 'Clause 2.6.73',
-    },
-    'MPEG4_audio_extension_descriptor@num_of_loops': {
-        text: 'The number of audioProfileLevelIndication fields that follow.',
-        ref: 'Clause 2.6.73',
-    },
-    'MPEG4_audio_extension_descriptor@audioProfileLevelIndication': {
-        text: 'Indicates an audio profile and level to which the stream conforms.',
-        ref: 'Clause 2.6.73 / ISO/IEC 14496-3',
-    },
-    'MPEG4_audio_extension_descriptor@ASC_size': {
-        text: 'The size in bytes of the following AudioSpecificConfig data.',
-        ref: 'Clause 2.6.73',
-    },
-    'MPEG4_audio_extension_descriptor@audioSpecificConfig': {
-        text: 'The AudioSpecificConfig data, which provides detailed decoder configuration for MPEG-4 audio.',
-        ref: 'Clause 2.6.73 / ISO/IEC 14496-3',
-    },
-    Auxiliary_video_stream_descriptor: {
-        text: 'Specifies parameters for the decoding and interpretation of an auxiliary video stream (e.g., depth maps for 3D video).',
-        ref: 'Clause 2.6.74',
-    },
-    'Auxiliary_video_stream_descriptor@aux_video_codedstreamtype': {
-        text: 'Indicates the compression coding type of the auxiliary video stream (e.g., 0x1B for H.264/AVC).',
-        ref: 'Clause 2.6.75',
-    },
-    'Auxiliary_video_stream_descriptor@si_rbsp_data': {
-        text: 'The Supplemental Information Raw Byte Sequence Payload, containing detailed parameters for the auxiliary video as defined in ISO/IEC 23002-3.',
-        ref: 'Clause 2.6.75',
-    },
-    external_ES_ID_descriptor: {
-        text: 'Assigns an ES_ID to a program element, allowing non-MPEG-4 components to be referenced in an MPEG-4 scene.',
-        ref: 'Clause 2.6.46',
-    },
-    MuxCode_descriptor: {
-        text: 'Conveys MuxCodeTableEntry structures to configure the MuxCode mode of FlexMux.',
-        ref: 'Clause 2.6.48',
-    },
-    FmxBufferSize_descriptor: {
-        text: 'Conveys the size of the FlexMux buffer (FB) for each SL packetized stream multiplexed in a FlexMux stream.',
-        ref: 'Clause 2.6.50',
-    },
-    IPMP_descriptor: {
-        text: 'Provides information for Intellectual Property Management and Protection (IPMP) systems.',
-        ref: 'Clause 2.6, Tag 0x29 / ISO/IEC 13818-11',
-    },
-    MVC_operation_point_descriptor: {
-        text: 'Indicates profile and level for one or more operation points of an MVC (Multi-view Coding) bitstream.',
-        ref: 'Clause 2.6.82',
-    },
-};
-
-export const tooltipData = {
-    ...adaptationFieldTooltipData,
-    ...catTooltipData,
-    ...descriptorTooltipData,
-    ...dsmccTooltipData,
-    ...ipmpTooltipData,
-    ...patTooltipData,
-    ...pmtTooltipData,
-    ...pesTooltipData,
-    ...privateSectionTooltipData,
-    ...tsdtTooltipData,
-};
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/transport-profile.js b/js/infrastructure/segment/ts/parsers/descriptors/transport-profile.js
deleted file mode 100644
index 31948a3..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/transport-profile.js
+++ /dev/null
@@ -1,21 +0,0 @@
-/**
- * Parses a Transport_profile_descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.93 & Table 2-109
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseTransportProfileDescriptor(view, baseOffset) {
-    const profile = view.getUint8(0);
-    const profileMap = {
-        0x01: 'Complete profile',
-        0x02: 'Adaptive profile',
-    };
-    return {
-        transport_profile: {
-            value: profileMap[profile] || `Reserved/User-Private (${profile})`,
-            offset: baseOffset,
-            length: 1,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/video-stream.js b/js/infrastructure/segment/ts/parsers/descriptors/video-stream.js
deleted file mode 100644
index a8d41b4..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/video-stream.js
+++ /dev/null
@@ -1,57 +0,0 @@
-/**
- * Parses a single Video Stream Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.2 & Table 2-46
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed video descriptor.
- */
-export function parseVideoStreamDescriptor(view, baseOffset) {
-    const byte1 = view.getUint8(0);
-    const details = {
-        multiple_frame_rate_flag: {
-            value: (byte1 >> 7) & 1,
-            offset: baseOffset,
-            length: 0.125,
-        },
-        frame_rate_code: {
-            value: (byte1 >> 3) & 0x0f,
-            offset: baseOffset,
-            length: 0.5,
-        },
-        MPEG_1_only_flag: {
-            value: (byte1 >> 2) & 1,
-            offset: baseOffset,
-            length: 0.125,
-        },
-        constrained_parameter_flag: {
-            value: (byte1 >> 1) & 1,
-            offset: baseOffset,
-            length: 0.125,
-        },
-        still_picture_flag: {
-            value: byte1 & 1,
-            offset: baseOffset,
-            length: 0.125,
-        },
-    };
-    if (details.MPEG_1_only_flag.value === 0) {
-        const byte2 = view.getUint8(1);
-        details.profile_and_level_indication = {
-            value: byte2,
-            offset: baseOffset + 1,
-            length: 1,
-        };
-        const byte3 = view.getUint8(2);
-        details.chroma_format = {
-            value: (byte3 >> 6) & 3,
-            offset: baseOffset + 2,
-            length: 0.25,
-        };
-        details.frame_rate_extension_flag = {
-            value: (byte3 >> 5) & 1,
-            offset: baseOffset + 2,
-            length: 0.125,
-        };
-    }
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/video-window.js b/js/infrastructure/segment/ts/parsers/descriptors/video-window.js
deleted file mode 100644
index fb8f3df..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/video-window.js
+++ /dev/null
@@ -1,28 +0,0 @@
-/**
- * Parses a Video Window Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1 Clause 2.6.14
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseVideoWindowDescriptor(view, baseOffset) {
-    const word1 = view.getUint16(0);
-    const word2 = view.getUint16(2);
-    return {
-        horizontal_offset: {
-            value: word1 >> 2,
-            offset: baseOffset,
-            length: 1.75,
-        },
-        vertical_offset: {
-            value: ((word1 & 0x03) << 12) | (word2 >> 4),
-            offset: baseOffset + 1.75,
-            length: 1.75,
-        },
-        window_priority: {
-            value: word2 & 0x0f,
-            offset: baseOffset + 3.5,
-            length: 0.5,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/descriptors/virtual-segmentation.js b/js/infrastructure/segment/ts/parsers/descriptors/virtual-segmentation.js
deleted file mode 100644
index 18e83ef..0000000
--- a/js/infrastructure/segment/ts/parsers/descriptors/virtual-segmentation.js
+++ /dev/null
@@ -1,92 +0,0 @@
-/**
- * Parses a Virtual Segmentation Descriptor.
- * ITU-T H.222.0 | ISO/IEC 13818-1, Extension Descriptor Tag 0x10, Table 2-127
- * @param {DataView} view - A DataView for the descriptor's payload.
- * @param {number} baseOffset - The offset of the descriptor payload within the segment.
- * @returns {object} The parsed descriptor.
- */
-export function parseVirtualSegmentationDescriptor(view, baseOffset) {
-    const details = {};
-    let offset = 0;
-
-    if (view.byteLength < 1) return details;
-
-    const byte0 = view.getUint8(offset);
-    const num_partitions = (byte0 >> 5) & 0x07;
-    const timescale_flag = (byte0 >> 4) & 1;
-    details.num_partitions = {
-        value: num_partitions,
-        offset: baseOffset + offset,
-        length: 0.375,
-    };
-    details.timescale_flag = {
-        value: timescale_flag,
-        offset: baseOffset + offset,
-        length: 0.125,
-    };
-    offset += 1;
-
-    let mdl = -1;
-    if (timescale_flag) {
-        const dword = view.getUint32(offset - 1); // Re-read to get cross-byte value
-        details.ticks_per_second = {
-            value: (dword >> 8) & 0x1fffff,
-            offset: baseOffset + offset - 1,
-            length: 2.625,
-        };
-        mdl = (view.getUint8(offset + 2) >> 5) & 0x07;
-        details.maximum_duration_length_minus_1 = {
-            value: mdl,
-            offset: baseOffset + offset + 2,
-            length: 0.375,
-        };
-        offset += 3;
-    }
-
-    details.partitions = [];
-    for (let i = 0; i < num_partitions; i++) {
-        if (offset + 2 > view.byteLength) break;
-        const partition = {};
-        const byte1 = view.getUint8(offset);
-        const byte2 = view.getUint8(offset + 1);
-
-        partition.explicit_boundary_flag = {
-            value: (byte1 >> 7) & 1,
-            offset: baseOffset + offset,
-            length: 0.125,
-        };
-        partition.partition_id = {
-            value: (byte1 >> 4) & 0x07,
-            offset: baseOffset + offset,
-            length: 0.375,
-        };
-        partition.SAP_type_max = {
-            value: byte2 & 0x0f,
-            offset: baseOffset + offset + 1,
-            length: 0.5,
-        };
-        offset += 2;
-
-        if (partition.explicit_boundary_flag.value === 0) {
-            if (offset + 2 > view.byteLength) break;
-            partition.boundary_PID = {
-                value: view.getUint16(offset) & 0x1fff,
-                offset: baseOffset + offset,
-                length: 1.625,
-            };
-            offset += 2;
-        } else {
-            const max_duration_len_bytes = mdl + 1;
-            if (offset + max_duration_len_bytes > view.byteLength) break;
-            // Reading variable length integer is complex, showing as bytes for now.
-            partition.maximum_duration = {
-                value: `${max_duration_len_bytes} bytes of duration data`,
-                offset: baseOffset + offset,
-                length: max_duration_len_bytes,
-            };
-            offset += max_duration_len_bytes;
-        }
-        details.partitions.push(partition);
-    }
-    return details;
-}
diff --git a/js/infrastructure/segment/ts/parsers/dsm-cc.js b/js/infrastructure/segment/ts/parsers/dsm-cc.js
deleted file mode 100644
index 7e8fb7e..0000000
--- a/js/infrastructure/segment/ts/parsers/dsm-cc.js
+++ /dev/null
@@ -1,264 +0,0 @@
-/**
- * A utility class for safely parsing binary data, inspired by BoxParser.
- */
-class DsmccParser {
-    constructor(view, baseOffset) {
-        this.view = view;
-        this.baseOffset = baseOffset;
-        this.offset = 0;
-        this.details = {};
-        this.stopped = false;
-    }
-
-    checkBounds(length) {
-        if (this.stopped || this.offset + length > this.view.byteLength) {
-            this.stopped = true;
-            return false;
-        }
-        return true;
-    }
-
-    read(length, fieldName, readerFn, bits = length * 8) {
-        if (!this.checkBounds(length)) return null;
-        const value = readerFn.call(this.view, this.offset);
-        this.details[fieldName] = {
-            value,
-            offset: this.baseOffset + this.offset,
-            length: bits / 8,
-        };
-        this.offset += length;
-        return value;
-    }
-
-    readUint8(f) {
-        return this.read(1, f, this.view.getUint8);
-    }
-    readUint16(f) {
-        return this.read(2, f, this.view.getUint16);
-    }
-
-    parseTimestamp(fieldName) {
-        if (!this.checkBounds(5)) return null;
-        const v = new DataView(
-            this.view.buffer,
-            this.view.byteOffset + this.offset,
-            5
-        );
-        const high = BigInt((v.getUint8(0) & 0x0e) >> 1);
-        const mid = BigInt((v.getUint16(1) & 0x7fff) >> 1);
-        const low = BigInt((v.getUint16(3) & 0x7fff) >> 1);
-        const value = (high << 30n) | (mid << 15n) | low;
-        this.details[fieldName] = {
-            value: value.toString(),
-            offset: this.baseOffset + this.offset,
-            length: 5,
-        };
-        this.offset += 5;
-        return value;
-    }
-}
-
-function parseTimeCode(p) {
-    const byte0 = p.readUint8('timecode_header');
-    if (p.stopped) return;
-    const infinite_time_flag = byte0 & 1;
-    p.details.infinite_time_flag = {
-        value: infinite_time_flag,
-        offset: p.details.timecode_header.offset,
-        length: 0.125,
-    };
-
-    if (infinite_time_flag === 0) {
-        p.parseTimestamp('PTS');
-    }
-}
-
-export function parseDsmccPayload(view, baseOffset) {
-    const p = new DsmccParser(view, baseOffset);
-    const command_id = p.readUint8('command_id');
-
-    if (p.stopped) return { type: 'DSM-CC (Truncated)', ...p.details };
-
-    if (command_id === 0x01) {
-        // Control Command
-        const flags = p.readUint16('control_flags');
-        if (p.stopped) return { type: 'DSM-CC Control', ...p.details };
-
-        const select_flag = (flags >> 15) & 1;
-        p.details.select_flag = {
-            value: select_flag,
-            offset: p.details.control_flags.offset,
-            length: 0.125,
-        };
-        // ... (other flags could be parsed similarly)
-
-        if (select_flag) {
-            p.read(5, 'select_data_omitted');
-        }
-
-        const retrieval_flag = (flags >> 14) & 1;
-        p.details.retrieval_flag = {
-            value: retrieval_flag,
-            offset: p.details.control_flags.offset + 0.125,
-            length: 0.125,
-        };
-
-        if (retrieval_flag) {
-            const rFlags = p.readUint16('retrieval_flags');
-            if (p.stopped) return { type: 'DSM-CC Control', ...p.details };
-            const jump_flag = (rFlags >> 15) & 1;
-            const play_flag = (rFlags >> 14) & 1;
-
-            if (jump_flag) {
-                p.readUint8('jump_direction_indicator');
-                parseTimeCode(p);
-            }
-            if (play_flag) {
-                p.readUint8('play_flags');
-                parseTimeCode(p);
-            }
-        }
-        return { type: 'DSM-CC Control', ...p.details };
-    } else if (command_id === 0x02) {
-        // Acknowledgement
-        const ackFlags = p.readUint16('ack_flags');
-        if (p.stopped) return { type: 'DSM-CC Ack', ...p.details };
-
-        const cmd_status = (ackFlags >> 0) & 1;
-        const retrieval_ack = (ackFlags >> 14) & 1;
-        const storage_ack = (ackFlags >> 13) & 1;
-        p.details.retrieval_ack = {
-            value: retrieval_ack,
-            offset: p.details.ack_flags.offset + 0.125,
-            length: 0.125,
-        };
-        p.details.storage_ack = {
-            value: storage_ack,
-            offset: p.details.ack_flags.offset + 0.25,
-            length: 0.125,
-        };
-        p.details.cmd_status = {
-            value: cmd_status,
-            offset: p.details.ack_flags.offset + 1.875,
-            length: 0.125,
-        };
-
-        if (cmd_status === 1 && (retrieval_ack || storage_ack)) {
-            parseTimeCode(p);
-        }
-        return { type: 'DSM-CC Ack', ...p.details };
-    }
-
-    return { type: 'DSM-CC Unknown', ...p.details };
-}
-
-export const dsmccTooltipData = {
-    'DSM-CC Section/Packet': {
-        text: 'Digital Storage Media Command and Control. A protocol for controlling playback of stored or broadcast media, used in interactive TV and other applications.',
-        ref: 'Annex B & ISO/IEC 13818-6',
-    },
-    'DSM-CC Control': {
-        text: 'A DSM-CC control command message.',
-        ref: 'Table B.3',
-    },
-    'DSM-CC Ack': {
-        text: 'A DSM-CC acknowledgement message.',
-        ref: 'Table B.5',
-    },
-    'DSM-CC Control@command_id': {
-        text: 'Identifies the message as a control command (0x01).',
-        ref: 'Table B.2',
-    },
-    'DSM-CC Ack@command_id': {
-        text: 'Identifies the message as an acknowledgement (0x02).',
-        ref: 'Table B.2',
-    },
-    'DSM-CC Control@select_flag': {
-        text: 'When set to 1, specifies a bitstream selection operation.',
-        ref: 'Clause B.3.5',
-    },
-    'DSM-CC Control@retrieval_flag': {
-        text: 'When set to 1, specifies a playback (retrieval) action.',
-        ref: 'Clause B.3.5',
-    },
-    'DSM-CC Control@storage_flag': {
-        text: 'When set to 1, specifies a storage operation.',
-        ref: 'Clause B.3.5',
-    },
-    'DSM-CC Control@bitstream_id': {
-        text: 'A 32-bit identifier specifying which bitstream to select.',
-        ref: 'Clause B.3.5',
-    },
-    'DSM-CC Control@select_mode': {
-        text: 'Specifies the mode of operation (1=Storage, 2=Retrieval).',
-        ref: 'Table B.4',
-    },
-    'DSM-CC Control@jump_flag': {
-        text: 'When set to 1, specifies a jump to a new PTS.',
-        ref: 'Clause B.3.5',
-    },
-    'DSM-CC Control@play_flag': {
-        text: 'When set to 1, specifies to play the stream.',
-        ref: 'Clause B.3.5',
-    },
-    'DSM-CC Control@pause_mode': {
-        text: 'When set to 1, specifies to pause playback.',
-        ref: 'Clause B.3.5',
-    },
-    'DSM-CC Control@resume_mode': {
-        text: 'When set to 1, specifies to resume playback.',
-        ref: 'Clause B.3.5',
-    },
-    'DSM-CC Control@stop_mode': {
-        text: 'When set to 1, specifies to stop the current operation.',
-        ref: 'Clause B.3.5',
-    },
-    'DSM-CC Control@direction_indicator': {
-        text: 'Indicates playback direction (1=forward, 0=backward).',
-        ref: 'Clause B.3.5',
-    },
-    'DSM-CC Control@speed_mode': {
-        text: 'Specifies playback speed (1=normal, 0=fast).',
-        ref: 'Clause B.3.5',
-    },
-    'DSM-CC Control@record_flag': {
-        text: 'When set to 1, requests recording of the bitstream.',
-        ref: 'Clause B.3.5',
-    },
-    'DSM-CC Ack@select_ack': {
-        text: 'Acknowledges a select command.',
-        ref: 'Clause B.3.7',
-    },
-    'DSM-CC Ack@retrieval_ack': {
-        text: 'Acknowledges a retrieval command.',
-        ref: 'Clause B.3.7',
-    },
-    'DSM-CC Ack@storage_ack': {
-        text: 'Acknowledges a storage command.',
-        ref: 'Clause B.3.7',
-    },
-    'DSM-CC Ack@error_ack': {
-        text: 'Indicates a DSM error (e.g., End of File).',
-        ref: 'Clause B.3.7',
-    },
-    'DSM-CC Ack@cmd_status': {
-        text: 'Indicates if the command was accepted (1) or rejected (0).',
-        ref: 'Clause B.3.7',
-    },
-    'DSM-CC Control@infinite_time_flag': {
-        text: 'When set to 1, indicates an infinite time period for an operation.',
-        ref: 'Clause B.3.9',
-    },
-    'DSM-CC Ack@infinite_time_flag': {
-        text: 'When set to 1, indicates an infinite time period for an operation.',
-        ref: 'Clause B.3.9',
-    },
-    'DSM-CC Control@PTS': {
-        text: 'Specifies a relative duration for an operation, in 90kHz clock ticks.',
-        ref: 'Clause B.3.8',
-    },
-    'DSM-CC Ack@PTS': {
-        text: 'Reports the current operational PTS value, in 90kHz clock ticks.',
-        ref: 'Clause B.3.8',
-    },
-};
diff --git a/js/infrastructure/segment/ts/parsers/header.js b/js/infrastructure/segment/ts/parsers/header.js
deleted file mode 100644
index 81b1058..0000000
--- a/js/infrastructure/segment/ts/parsers/header.js
+++ /dev/null
@@ -1,52 +0,0 @@
-// Parses the fixed-size 4-byte MPEG-2 Transport Stream packet header.
-// Decodes fields such as PID, continuity_counter, and control flags.
-
-/**
- * Parses the 4-byte Transport Stream packet header.
- * @param {DataView} view - A DataView pointing to the start of the TS packet.
- * @param {number} baseOffset - The offset of the packet within the entire segment.
- * @returns {object} The parsed header data with byte-level metadata.
- */
-export function parseHeader(view, baseOffset) {
-    const byte0 = view.getUint8(0);
-    const byte1 = view.getUint8(1);
-    const byte2 = view.getUint8(2);
-    const byte3 = view.getUint8(3);
-
-    const pid = ((byte1 & 0x1f) << 8) | byte2;
-
-    return {
-        sync_byte: { value: byte0, offset: baseOffset, length: 1 },
-        transport_error_indicator: {
-            value: (byte1 >> 7) & 1,
-            offset: baseOffset + 1,
-            length: 0.125,
-        },
-        payload_unit_start_indicator: {
-            value: (byte1 >> 6) & 1,
-            offset: baseOffset + 1,
-            length: 0.125,
-        },
-        transport_priority: {
-            value: (byte1 >> 5) & 1,
-            offset: baseOffset + 1,
-            length: 0.125,
-        },
-        pid: { value: pid, offset: baseOffset + 1, length: 1.625 },
-        transport_scrambling_control: {
-            value: (byte3 >> 6) & 3,
-            offset: baseOffset + 3,
-            length: 0.25,
-        },
-        adaptation_field_control: {
-            value: (byte3 >> 4) & 3,
-            offset: baseOffset + 3,
-            length: 0.25,
-        },
-        continuity_counter: {
-            value: byte3 & 0x0f,
-            offset: baseOffset + 3,
-            length: 0.5,
-        },
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/ipmp.js b/js/infrastructure/segment/ts/parsers/ipmp.js
deleted file mode 100644
index 584f727..0000000
--- a/js/infrastructure/segment/ts/parsers/ipmp.js
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Parses the payload of an IPMP Control Information Table (IPMP-CIT) section.
- * The internal structure is complex and defined in ISO/IEC 13818-11. This parser
- * identifies its presence and basic structure.
- * @param {DataView} view - A DataView of the IPMP-CIT section's payload.
- * @param {number} baseOffset - The offset of the payload within the segment.
- * @returns {object} An object containing parsed IPMP-CIT information.
- */
-export function parseIpmpPayload(view, baseOffset) {
-    // A full parser is out of scope, but we can identify its presence.
-    return {
-        type: 'IPMP-CIT',
-        info: {
-            value: 'IPMP Control Information Table present.',
-            offset: baseOffset,
-            length: view.byteLength,
-        },
-    };
-}
-
-export const ipmpTooltipData = {
-    'IPMP-CIT': {
-        text: 'IPMP Control Information Table. Contains information for Intellectual Property Management and Protection systems.',
-        ref: 'Clause 2.4.4.1, ISO/IEC 13818-11',
-    },
-};
diff --git a/js/infrastructure/segment/ts/parsers/pack-header.js b/js/infrastructure/segment/ts/parsers/pack-header.js
deleted file mode 100644
index d579e82..0000000
--- a/js/infrastructure/segment/ts/parsers/pack-header.js
+++ /dev/null
@@ -1,109 +0,0 @@
-/**
- * Parses the 42-bit System Clock Reference (SCR).
- * @param {DataView} view - A DataView starting at the 6-byte SCR field.
- * @returns {BigInt} The combined 42-bit value.
- */
-function parseScr(view) {
-    const byte0 = view.getUint8(0);
-    const byte1 = view.getUint8(1);
-    const byte2 = view.getUint8(2);
-    const byte3 = view.getUint8(3);
-    const byte4 = view.getUint8(4);
-    const byte5 = view.getUint8(5);
-
-    const base_high = BigInt(byte0 & 0x38) >> 3n; // 3 bits
-    const base_mid =
-        (BigInt(byte0 & 0x03) << 13n) |
-        (BigInt(byte1) << 5n) |
-        (BigInt(byte2 >> 3) & 0x1fn); // 15 bits
-    const base_low =
-        (BigInt(byte2 & 0x03) << 13n) |
-        (BigInt(byte3) << 5n) |
-        (BigInt(byte4 >> 3) & 0x1fn); // 15 bits
-    const base = (base_high << 30n) | (base_mid << 15n) | base_low;
-
-    const extension = ((BigInt(byte4) & 0x03n) << 7n) | BigInt(byte5 >> 1); // 9 bits
-
-    return base * 300n + extension;
-}
-
-/**
- * Parses a Program Stream Pack Header.
- * @param {DataView} view - A DataView of the pack header.
- * @param {number} baseOffset - The offset of the pack header within the segment.
- * @returns {object} The parsed pack header.
- */
-export function parsePackHeader(view, baseOffset) {
-    const details = {};
-    let offset = 0;
-
-    if (view.byteLength < 4) return details;
-    details.pack_start_code = {
-        value: `0x${view.getUint32(0).toString(16)}`,
-        offset: baseOffset,
-        length: 4,
-    };
-    offset += 4;
-
-    if (view.byteLength < offset + 6) return details;
-    const scrView = new DataView(view.buffer, view.byteOffset + offset, 6);
-    details.system_clock_reference = {
-        value: parseScr(scrView).toString(),
-        offset: baseOffset + offset,
-        length: 6,
-    };
-    offset += 6;
-
-    if (view.byteLength < offset + 3) return details;
-    const muxRateVal =
-        (view.getUint8(offset) << 14) |
-        (view.getUint8(offset + 1) << 6) |
-        (view.getUint8(offset + 2) >> 2);
-    details.program_mux_rate = {
-        value: muxRateVal,
-        offset: baseOffset + offset,
-        length: 3,
-    };
-    offset += 3;
-
-    const stuffingLength = view.getUint8(offset - 1) & 0x07;
-    details.pack_stuffing_length = {
-        value: stuffingLength,
-        offset: baseOffset + offset - 1,
-        length: 0.375,
-    };
-
-    if (stuffingLength > 0) {
-        if (view.byteLength < offset + stuffingLength) return details;
-        details.stuffing_bytes = {
-            value: `${stuffingLength} bytes`,
-            offset: baseOffset + offset,
-            length: stuffingLength,
-        };
-    }
-
-    return details;
-}
-
-export const packHeaderTooltipData = {
-    pack_header: {
-        text: 'A Program Stream Pack Header, providing timing and bitrate information.',
-        ref: 'Clause 2.5.3.3',
-    },
-    'pack_header@pack_start_code': {
-        text: 'The start code for a pack (0x000001BA).',
-        ref: 'Clause 2.5.3.4',
-    },
-    'pack_header@system_clock_reference': {
-        text: 'System Clock Reference (SCR). A timestamp indicating the intended arrival time of this byte at the decoder.',
-        ref: 'Clause 2.5.3.4',
-    },
-    'pack_header@program_mux_rate': {
-        text: 'The rate at which the P-STD receives the program stream during this pack, in units of 50 bytes/second.',
-        ref: 'Clause 2.5.3.4',
-    },
-    'pack_header@pack_stuffing_length': {
-        text: 'The number of stuffing bytes that follow.',
-        ref: 'Clause 2.5.3.4',
-    },
-};
diff --git a/js/infrastructure/segment/ts/parsers/pat.js b/js/infrastructure/segment/ts/parsers/pat.js
deleted file mode 100644
index 35fdf3c..0000000
--- a/js/infrastructure/segment/ts/parsers/pat.js
+++ /dev/null
@@ -1,58 +0,0 @@
-// Parses the payload of a Program Association Table (PAT) section.
-// Extracts the mapping between program_number and the PID for the
-// corresponding Program Map Table (PMT).
-
-/**
- * Parses the program associations from a PAT section payload.
- * @param {DataView} view - A DataView of the PAT section's payload.
- * @param {number} baseOffset - The offset of the payload within the segment.
- * @returns {object} An object containing the parsed PAT data.
- */
-export function parsePatPayload(view, baseOffset) {
-    const programs = [];
-    for (let offset = 0; offset + 4 <= view.byteLength; offset += 4) {
-        const programNum = view.getUint16(offset);
-        const pid = view.getUint16(offset + 2) & 0x1fff;
-
-        if (programNum === 0) {
-            programs.push({
-                type: 'network',
-                pid: {
-                    value: pid,
-                    offset: baseOffset + offset + 2,
-                    length: 1.625,
-                },
-            });
-        } else {
-            programs.push({
-                type: 'program',
-                program_number: {
-                    value: programNum,
-                    offset: baseOffset + offset,
-                    length: 2,
-                },
-                program_map_PID: {
-                    value: pid,
-                    offset: baseOffset + offset + 2,
-                    length: 1.625,
-                },
-            });
-        }
-    }
-    return { type: 'PAT', programs };
-}
-
-export const patTooltipData = {
-    PAT: {
-        text: 'Program Association Table. Lists all programs in a stream, mapping each to the PID of its Program Map Table (PMT).',
-        ref: 'Clause 2.4.4.4',
-    },
-    'PAT@network_pid': {
-        text: 'The PID for the Network Information Table (NIT).',
-        ref: 'Table 2-30',
-    },
-    'PAT@program_map_PID': {
-        text: 'The PID of the Transport Stream packets which shall contain the Program Map Table for this program.',
-        ref: 'Table 2-30',
-    },
-};
diff --git a/js/infrastructure/segment/ts/parsers/pes.js b/js/infrastructure/segment/ts/parsers/pes.js
deleted file mode 100644
index dae8755..0000000
--- a/js/infrastructure/segment/ts/parsers/pes.js
+++ /dev/null
@@ -1,568 +0,0 @@
-// Parsers a Packetized Elementary Stream (PES) packet header found
-// within the payload of a TS packet. This includes decoding the stream_id
-// and extracting critical timing information like the Presentation
-// Time Stamp (PTS) and Decoding Time Stamp (DTS), as well as all
-// optional and extension fields.
-import { parsePackHeader } from './pack-header.js';
-
-function parseTimestamp(view, offset) {
-    const byte0 = view.getUint8(offset);
-    const byte1 = view.getUint8(offset + 1);
-    const byte2 = view.getUint8(offset + 2);
-    const byte3 = view.getUint8(offset + 3);
-    const byte4 = view.getUint8(offset + 4);
-
-    const high = BigInt((byte0 & 0x0e) >> 1);
-    const mid = BigInt((byte1 << 7) | (byte2 >> 1));
-    const low = BigInt((byte3 << 7) | (byte4 >> 1));
-
-    return (high << 30n) | (mid << 15n) | low;
-}
-
-function parseEscr(view, offset) {
-    const byte0 = view.getUint8(offset);
-    const byte1 = view.getUint8(offset + 1);
-    const byte2 = view.getUint8(offset + 2);
-    const byte3 = view.getUint8(offset + 3);
-    const byte4 = view.getUint8(offset + 4);
-    const byte5 = view.getUint8(offset + 5);
-
-    const high = BigInt(byte0 & 0x38) >> 3n; // 3 bits
-    const mid_high =
-        (BigInt(byte0 & 0x03) << 13n) |
-        (BigInt(byte1) << 5n) |
-        (BigInt(byte2 >> 3) & 0x1fn); // 15 bits
-    const mid_low =
-        (BigInt(byte2 & 0x03) << 13n) |
-        (BigInt(byte3) << 5n) |
-        (BigInt(byte4 >> 3) & 0x1fn); // 15 bits
-    const base = (high << 30n) | (mid_high << 15n) | mid_low;
-
-    const extension = ((BigInt(byte4) & 0x03n) << 7n) | BigInt(byte5 >> 1); // 9 bits
-
-    return base * 300n + extension;
-}
-
-/**
- * Parses the header of a PES packet.
- * @param {DataView} view - A DataView of the PES packet payload.
- * @param {number} baseOffset - The offset of the PES packet within the segment.
- * @returns {{header: object, payloadOffset: number} | null} The parsed PES header and the offset to the payload, or null.
- */
-export function parsePesHeader(view, baseOffset) {
-    if (view.byteLength < 6 || view.getUint32(0) >>> 8 !== 0x000001) {
-        return null;
-    }
-
-    const streamIdByte = view.getUint8(3);
-    const pes_packet_length = view.getUint16(4);
-
-    const pes = {
-        packet_start_code_prefix: {
-            value: '0x000001',
-            offset: baseOffset,
-            length: 3,
-        },
-        stream_id: {
-            value: `0x${streamIdByte.toString(16).padStart(2, '0')}`,
-            offset: baseOffset + 3,
-            length: 1,
-        },
-        pes_packet_length: {
-            value: pes_packet_length,
-            offset: baseOffset + 4,
-            length: 2,
-        },
-    };
-
-    // stream_id values for streams that do not have the optional PES header fields
-    const isSimpleFormat =
-        streamIdByte === 0xbc || // program_stream_map
-        streamIdByte === 0xbe || // padding_stream
-        streamIdByte === 0xbf || // private_stream_2
-        streamIdByte === 0xf0 || // ECM
-        streamIdByte === 0xf1 || // EMM
-        streamIdByte === 0xff || // program_stream_directory
-        streamIdByte === 0xf2 || // DSMCC_stream
-        streamIdByte === 0xf8; // H.222.1 type E stream
-
-    if (isSimpleFormat) {
-        return { header: pes, payloadOffset: 6 };
-    }
-
-    if (view.byteLength < 9) return { header: pes, payloadOffset: 6 };
-
-    const flags1 = view.getUint8(6);
-    const flags2 = view.getUint8(7);
-    const pes_header_data_length = view.getUint8(8);
-    const payloadOffset = 9 + pes_header_data_length;
-    const optionalFieldsEnd = 9 + pes_header_data_length;
-
-    // --- Flags Byte 1 ---
-    pes.marker_bits_2 = {
-        value: (flags1 >> 6) & 3,
-        offset: baseOffset + 6,
-        length: 0.25,
-    };
-    pes.scrambling_control = {
-        value: (flags1 >> 4) & 3,
-        offset: baseOffset + 6,
-        length: 0.25,
-    };
-    pes.priority = {
-        value: (flags1 >> 3) & 1,
-        offset: baseOffset + 6,
-        length: 0.125,
-    };
-    pes.data_alignment_indicator = {
-        value: (flags1 >> 2) & 1,
-        offset: baseOffset + 6,
-        length: 0.125,
-    };
-    pes.copyright = {
-        value: (flags1 >> 1) & 1,
-        offset: baseOffset + 6,
-        length: 0.125,
-    };
-    pes.original_or_copy = {
-        value: flags1 & 1,
-        offset: baseOffset + 6,
-        length: 0.125,
-    };
-
-    // --- Flags Byte 2 ---
-    const ptsDtsFlags = (flags2 >> 6) & 3;
-    const escrFlag = (flags2 >> 5) & 1;
-    const esRateFlag = (flags2 >> 4) & 1;
-    const dsmTrickModeFlag = (flags2 >> 3) & 1;
-    const additionalCopyInfoFlag = (flags2 >> 2) & 1;
-    const pesCrcFlag = (flags2 >> 1) & 1;
-    const pesExtensionFlag = flags2 & 1;
-
-    pes.pts_dts_flags = {
-        value: ptsDtsFlags,
-        offset: baseOffset + 7,
-        length: 0.25,
-    };
-    pes.escr_flag = { value: escrFlag, offset: baseOffset + 7, length: 0.125 };
-    pes.es_rate_flag = {
-        value: esRateFlag,
-        offset: baseOffset + 7,
-        length: 0.125,
-    };
-    pes.dsm_trick_mode_flag = {
-        value: dsmTrickModeFlag,
-        offset: baseOffset + 7,
-        length: 0.125,
-    };
-    pes.additional_copy_info_flag = {
-        value: additionalCopyInfoFlag,
-        offset: baseOffset + 7,
-        length: 0.125,
-    };
-    pes.pes_crc_flag = {
-        value: pesCrcFlag,
-        offset: baseOffset + 7,
-        length: 0.125,
-    };
-    pes.pes_extension_flag = {
-        value: pesExtensionFlag,
-        offset: baseOffset + 7,
-        length: 0.125,
-    };
-    pes.pes_header_data_length = {
-        value: pes_header_data_length,
-        offset: baseOffset + 8,
-        length: 1,
-    };
-
-    let optionalFieldsOffset = 9;
-
-    if (ptsDtsFlags === 0b10 && optionalFieldsOffset + 5 <= optionalFieldsEnd) {
-        pes.pts = {
-            value: parseTimestamp(view, optionalFieldsOffset).toString(),
-            offset: baseOffset + optionalFieldsOffset,
-            length: 5,
-        };
-        optionalFieldsOffset += 5;
-    } else if (
-        ptsDtsFlags === 0b11 &&
-        optionalFieldsOffset + 10 <= optionalFieldsEnd
-    ) {
-        pes.pts = {
-            value: parseTimestamp(view, optionalFieldsOffset).toString(),
-            offset: baseOffset + optionalFieldsOffset,
-            length: 5,
-        };
-        pes.dts = {
-            value: parseTimestamp(view, optionalFieldsOffset + 5).toString(),
-            offset: baseOffset + optionalFieldsOffset + 5,
-            length: 5,
-        };
-        optionalFieldsOffset += 10;
-    }
-
-    if (escrFlag && optionalFieldsOffset + 6 <= optionalFieldsEnd) {
-        pes.ESCR = {
-            value: parseEscr(view, optionalFieldsOffset).toString(),
-            offset: baseOffset + optionalFieldsOffset,
-            length: 6,
-        };
-        optionalFieldsOffset += 6;
-    }
-
-    if (esRateFlag && optionalFieldsOffset + 3 <= optionalFieldsEnd) {
-        const rateBytes = view.getUint32(optionalFieldsOffset - 1); // Not byte aligned
-        pes.ES_rate = {
-            value: (rateBytes >> 1) & 0x3fffff,
-            offset: baseOffset + optionalFieldsOffset,
-            length: 3,
-        };
-        optionalFieldsOffset += 3;
-    }
-
-    if (dsmTrickModeFlag && optionalFieldsOffset + 1 <= optionalFieldsEnd) {
-        const trickModeByte = view.getUint8(optionalFieldsOffset);
-        const trick_mode_control = (trickModeByte >> 5) & 0x07;
-        pes.trick_mode_control = {
-            value: trick_mode_control,
-            offset: baseOffset + optionalFieldsOffset,
-            length: 0.375,
-        };
-
-        switch (trick_mode_control) {
-            case 0b000: // fast_forward
-            case 0b011: // fast_reverse
-                pes.field_id = {
-                    value: (trickModeByte >> 3) & 0x03,
-                    offset: baseOffset + optionalFieldsOffset,
-                    length: 0.25,
-                };
-                pes.intra_slice_refresh = {
-                    value: (trickModeByte >> 2) & 0x01,
-                    offset: baseOffset + optionalFieldsOffset,
-                    length: 0.125,
-                };
-                pes.frequency_truncation = {
-                    value: trickModeByte & 0x03,
-                    offset: baseOffset + optionalFieldsOffset,
-                    length: 0.25,
-                };
-                break;
-            case 0b001: // slow_motion
-            case 0b100: // slow_reverse
-                pes.rep_cntrl = {
-                    value: trickModeByte & 0x1f,
-                    offset: baseOffset + optionalFieldsOffset,
-                    length: 0.625,
-                };
-                break;
-            case 0b010: // freeze_frame
-                pes.field_id = {
-                    value: (trickModeByte >> 3) & 0x03,
-                    offset: baseOffset + optionalFieldsOffset,
-                    length: 0.25,
-                };
-                break;
-        }
-        optionalFieldsOffset += 1;
-    }
-
-    if (
-        additionalCopyInfoFlag &&
-        optionalFieldsOffset + 1 <= optionalFieldsEnd
-    ) {
-        pes.additional_copy_info = {
-            value: view.getUint8(optionalFieldsOffset) & 0x7f,
-            offset: baseOffset + optionalFieldsOffset,
-            length: 1,
-        };
-        optionalFieldsOffset += 1;
-    }
-
-    if (pesCrcFlag && optionalFieldsOffset + 2 <= optionalFieldsEnd) {
-        pes.previous_PES_packet_CRC = {
-            value: view.getUint16(optionalFieldsOffset),
-            offset: baseOffset + optionalFieldsOffset,
-            length: 2,
-        };
-        optionalFieldsOffset += 2;
-    }
-
-    if (pesExtensionFlag && optionalFieldsOffset + 1 <= optionalFieldsEnd) {
-        const extFlags = view.getUint8(optionalFieldsOffset);
-        const pesPrivateDataFlag = (extFlags >> 7) & 1;
-        const packHeaderFieldFlag = (extFlags >> 6) & 1;
-        const programPacketSequenceCounterFlag = (extFlags >> 5) & 1;
-        const pStdBufferFlag = (extFlags >> 4) & 1;
-        const pesExtensionFlag2 = extFlags & 1;
-
-        pes.PES_private_data_flag = {
-            value: pesPrivateDataFlag,
-            offset: baseOffset + optionalFieldsOffset,
-            length: 0.125,
-        };
-        pes.pack_header_field_flag = {
-            value: packHeaderFieldFlag,
-            offset: baseOffset + optionalFieldsOffset,
-            length: 0.125,
-        };
-        pes.program_packet_sequence_counter_flag = {
-            value: programPacketSequenceCounterFlag,
-            offset: baseOffset + optionalFieldsOffset,
-            length: 0.125,
-        };
-        pes.P_STD_buffer_flag = {
-            value: pStdBufferFlag,
-            offset: baseOffset + optionalFieldsOffset,
-            length: 0.125,
-        };
-        pes.PES_extension_flag_2 = {
-            value: pesExtensionFlag2,
-            offset: baseOffset + optionalFieldsOffset,
-            length: 0.125,
-        };
-        optionalFieldsOffset += 1;
-
-        if (
-            pesPrivateDataFlag &&
-            optionalFieldsOffset + 16 <= optionalFieldsEnd
-        ) {
-            pes.PES_private_data = {
-                value: '128 bits of private data',
-                offset: baseOffset + optionalFieldsOffset,
-                length: 16,
-            };
-            optionalFieldsOffset += 16;
-        }
-        if (
-            packHeaderFieldFlag &&
-            optionalFieldsOffset + 1 <= optionalFieldsEnd
-        ) {
-            const packFieldLength = view.getUint8(optionalFieldsOffset);
-            pes.pack_field_length = {
-                value: packFieldLength,
-                offset: baseOffset + optionalFieldsOffset,
-                length: 1,
-            };
-            optionalFieldsOffset += 1;
-            if (optionalFieldsOffset + packFieldLength <= optionalFieldsEnd) {
-                const packHeaderView = new DataView(
-                    view.buffer,
-                    view.byteOffset + optionalFieldsOffset,
-                    packFieldLength
-                );
-                pes.pack_header = parsePackHeader(
-                    packHeaderView,
-                    baseOffset + optionalFieldsOffset
-                );
-                optionalFieldsOffset += packFieldLength;
-            }
-        }
-        if (
-            programPacketSequenceCounterFlag &&
-            optionalFieldsOffset + 2 <= optionalFieldsEnd
-        ) {
-            const seqCounterByte1 = view.getUint8(optionalFieldsOffset);
-            const seqCounterByte2 = view.getUint8(optionalFieldsOffset + 1);
-            pes.program_packet_sequence_counter = {
-                value: seqCounterByte1 & 0x7f,
-                offset: baseOffset + optionalFieldsOffset,
-                length: 1,
-            };
-            pes.MPEG1_MPEG2_identifier = {
-                value: (seqCounterByte2 >> 6) & 1,
-                offset: baseOffset + optionalFieldsOffset + 1,
-                length: 0.125,
-            };
-            pes.original_stuff_length = {
-                value: seqCounterByte2 & 0x3f,
-                offset: baseOffset + optionalFieldsOffset + 1,
-                length: 0.75,
-            };
-            optionalFieldsOffset += 2;
-        }
-        if (pStdBufferFlag && optionalFieldsOffset + 2 <= optionalFieldsEnd) {
-            const pStdBufferBytes = view.getUint16(optionalFieldsOffset);
-            pes.P_STD_buffer_scale = {
-                value: (pStdBufferBytes >> 13) & 1,
-                offset: baseOffset + optionalFieldsOffset,
-                length: 0.125,
-            };
-            pes.P_STD_buffer_size = {
-                value: pStdBufferBytes & 0x1fff,
-                offset: baseOffset + optionalFieldsOffset,
-                length: 1.625,
-            };
-            optionalFieldsOffset += 2;
-        }
-        if (
-            pesExtensionFlag2 &&
-            optionalFieldsOffset + 1 <= optionalFieldsEnd
-        ) {
-            const ext2len = view.getUint8(optionalFieldsOffset) & 0x7f;
-            if (optionalFieldsOffset + 1 + ext2len <= optionalFieldsEnd) {
-                const ext2Flags = view.getUint8(optionalFieldsOffset + 1);
-                const streamIdExtFlag = (ext2Flags >> 7) & 1;
-
-                pes.PES_extension_field_length = {
-                    value: ext2len,
-                    offset: baseOffset + optionalFieldsOffset,
-                    length: 1,
-                };
-                pes.stream_id_extension_flag = {
-                    value: streamIdExtFlag,
-                    offset: baseOffset + optionalFieldsOffset + 1,
-                    length: 0.125,
-                };
-
-                if (streamIdExtFlag === 0) {
-                    pes.stream_id_extension = {
-                        value: ext2Flags & 0x7f,
-                        offset: baseOffset + optionalFieldsOffset + 1,
-                        length: 0.875,
-                    };
-                } else {
-                    const trefExtFlag = ext2Flags & 1;
-                    pes.tref_extension_flag = {
-                        value: trefExtFlag,
-                        offset: baseOffset + optionalFieldsOffset + 1,
-                        length: 0.125,
-                    };
-                    if (trefExtFlag === 0) {
-                        pes.TREF = {
-                            value: parseTimestamp(
-                                view,
-                                optionalFieldsOffset + 2
-                            ).toString(),
-                            offset: baseOffset + optionalFieldsOffset + 2,
-                            length: 5,
-                        };
-                    }
-                }
-                optionalFieldsOffset += 1 + ext2len;
-            }
-        }
-    }
-
-    return { header: pes, payloadOffset };
-}
-
-export const pesTooltipData = {
-    PES: {
-        text: 'Packetized Elementary Stream. Contains elementary stream data (e.g., video or audio frames) and timing information.',
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@packet_start_code_prefix': {
-        text: 'A unique 24-bit code (0x000001) that identifies the start of a PES packet.',
-        ref: 'Table 2-21',
-    },
-    'PES@stream_id': {
-        text: 'Identifies the type of elementary stream (e.g., 0xE0 for video).',
-        ref: 'Table 2-22',
-    },
-    'PES@pes_packet_length': {
-        text: 'The number of bytes in the PES packet following this field. A value of 0 is only allowed for video in a transport stream.',
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@pts_dts_flags': {
-        text: 'Indicates whether Presentation Time Stamp (PTS) and/or Decoding Time Stamp (DTS) are present.',
-        ref: 'Table 2-21',
-    },
-    'PES@pts': {
-        text: 'Presentation Time Stamp. Specifies the time at which a presentation unit is to be presented.',
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@dts': {
-        text: 'Decoding Time Stamp. Specifies the time at which a presentation unit is to be decoded.',
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@escr_flag': {
-        text: 'If set to 1, indicates the Elementary Stream Clock Reference (ESCR) field is present.',
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@ESCR': {
-        text: 'Elementary Stream Clock Reference. A time stamp from which decoders of PES streams may derive timing.',
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@es_rate_flag': {
-        text: 'If set to 1, indicates the ES_rate field is present.',
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@ES_rate': {
-        text: 'The rate at which the system target decoder receives bytes of the PES packet in a PES stream, in units of 50 bytes/second.',
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@dsm_trick_mode_flag': {
-        text: "A 1-bit flag which when set to '1' indicates the presence of an 8-bit trick mode field.",
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@trick_mode_control': {
-        text: 'A 3-bit field that indicates which trick mode is applied to the associated video stream.',
-        ref: 'Clause 2.4.3.7, Table 2-24',
-    },
-    'PES@additional_copy_info_flag': {
-        text: 'If set to 1, indicates the additional_copy_info field is present.',
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@additional_copy_info': {
-        text: 'Private data relating to copyright information.',
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@pes_crc_flag': {
-        text: 'If set to 1, indicates the previous_PES_packet_CRC field is present.',
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@previous_PES_packet_CRC': {
-        text: 'A 16-bit CRC field calculated over the data bytes of the previous PES packet.',
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@pes_extension_flag': {
-        text: "A 1-bit flag which when set to '1' indicates that an extension field exists in this PES packet header.",
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@pack_header_field_flag': {
-        text: 'If set to 1, indicates that a program stream pack header is stored in this PES packet header.',
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@program_packet_sequence_counter_flag': {
-        text: 'If set to 1, indicates the program_packet_sequence_counter and related fields are present.',
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@program_packet_sequence_counter': {
-        text: 'An optional 7-bit counter that increments with each successive PES packet of a program, allowing reconstruction of the original packet sequence.',
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@P_STD_buffer_flag': {
-        text: 'If set to 1, indicates the P-STD buffer scale and size fields are present.',
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@P_STD_buffer_size': {
-        text: 'Defines the size of the input buffer in the P-STD for this elementary stream.',
-        ref: 'Clause 2.4.3.7',
-    },
-    'PES@pes_extension_flag_2': {
-        text: 'A flag indicating the presence of further extension fields, like TREF or stream_id_extension.',
-        ref: 'Clause 2.4.3.7, Table 2-21',
-    },
-    'PES@PES_extension_field_length': {
-        text: 'The length in bytes of the data following this field in the PES extension.',
-        ref: 'Clause 2.4.3.7, Table 2-21',
-    },
-    'PES@stream_id_extension_flag': {
-        text: 'Indicates if the stream_id_extension field is present (flag=0) or if other extension flags are present (flag=1).',
-        ref: 'Clause 2.4.3.7, Table 2-21',
-    },
-    'PES@stream_id_extension': {
-        text: 'An extension to the stream_id field, allowing for more stream types to be identified.',
-        ref: 'Clause 2.4.3.7, Table 2-27',
-    },
-    'PES@tref_extension_flag': {
-        text: 'Indicates if the Timestamp Reference (TREF) field is present.',
-        ref: 'Clause 2.4.3.7, Table 2-21',
-    },
-    'PES@TREF': {
-        text: 'Timestamp Reference. Indicates the decoding time of a corresponding access unit in a reference elementary stream.',
-        ref: 'Clause 2.4.3.7',
-    },
-};
diff --git a/js/infrastructure/segment/ts/parsers/pmt.js b/js/infrastructure/segment/ts/parsers/pmt.js
deleted file mode 100644
index abdab07..0000000
--- a/js/infrastructure/segment/ts/parsers/pmt.js
+++ /dev/null
@@ -1,91 +0,0 @@
-import { parseDescriptors } from './descriptors/index.js';
-
-// Parses the payload of a Program Map Table (PMT) section.
-// Extracts the PCR_PID and the list of elementary streams, including
-// their stream_type, elementary_PID, and any associated descriptors.
-
-/**
- * Parses the elementary stream mappings from a PMT section payload.
- * @param {DataView} view - A DataView of the PMT section's payload.
- * @param {number} baseOffset - The offset of the payload within the segment.
- * @returns {object} An object containing the PCR PID and a list of streams.
- */
-export function parsePmtPayload(view, baseOffset) {
-    const pcr_pid = view.getUint16(0) & 0x1fff;
-    const program_info_length = view.getUint16(2) & 0x0fff;
-
-    const programDescriptorsView = new DataView(
-        view.buffer,
-        view.byteOffset + 4,
-        program_info_length
-    );
-    const program_descriptors = parseDescriptors(
-        programDescriptorsView,
-        baseOffset + 4
-    );
-
-    const streams = [];
-    let streamInfoOffset = 4 + program_info_length;
-    while (streamInfoOffset < view.byteLength) {
-        if (streamInfoOffset + 5 > view.byteLength) break;
-        const stream_type = view.getUint8(streamInfoOffset);
-        const elementary_PID = view.getUint16(streamInfoOffset + 1) & 0x1fff;
-        const es_info_length = view.getUint16(streamInfoOffset + 3) & 0x0fff;
-
-        const descriptorsView = new DataView(
-            view.buffer,
-            view.byteOffset + streamInfoOffset + 5,
-            es_info_length
-        );
-        const es_descriptors = parseDescriptors(
-            descriptorsView,
-            baseOffset + streamInfoOffset + 5
-        );
-
-        streams.push({
-            stream_type: {
-                value: `0x${stream_type.toString(16).padStart(2, '0')}`,
-                offset: baseOffset + streamInfoOffset,
-                length: 1,
-            },
-            elementary_PID: {
-                value: elementary_PID,
-                offset: baseOffset + streamInfoOffset + 1,
-                length: 1.625,
-            },
-            es_info_length: {
-                value: es_info_length,
-                offset: baseOffset + streamInfoOffset + 3,
-                length: 1.5,
-            },
-            es_descriptors,
-        });
-        streamInfoOffset += 5 + es_info_length;
-    }
-
-    return {
-        type: 'PMT',
-        pcr_pid: { value: pcr_pid, offset: baseOffset, length: 1.625 },
-        program_descriptors,
-        streams,
-    };
-}
-
-export const pmtTooltipData = {
-    PMT: {
-        text: 'Program Map Table. Lists all elementary streams (video, audio, etc.) that constitute a single program.',
-        ref: 'Clause 2.4.4.9',
-    },
-    'PMT@pcr_pid': {
-        text: 'The PID of the transport stream packets that carry the PCR fields valid for this program.',
-        ref: 'Table 2-33',
-    },
-    'PMT@stream_type': {
-        text: 'An 8-bit field specifying the type of the elementary stream.',
-        ref: 'Table 2-34',
-    },
-    'PMT@elementary_PID': {
-        text: 'The PID of the transport stream packets that carry the elementary stream data.',
-        ref: 'Table 2-33',
-    },
-};
diff --git a/js/infrastructure/segment/ts/parsers/private-section.js b/js/infrastructure/segment/ts/parsers/private-section.js
deleted file mode 100644
index ce4da78..0000000
--- a/js/infrastructure/segment/ts/parsers/private-section.js
+++ /dev/null
@@ -1,82 +0,0 @@
-/**
- * Parses the payload of a private_section.
- * This can have a "long" format (with versioning, etc.) or a "short" format.
- * The format is determined by the section_syntax_indicator from the parent PSI section.
- * @param {DataView} view - A DataView of the private section's payload.
- * @param {number} baseOffset - The offset of the payload within the segment.
- * @param {number} section_syntax_indicator - The indicator from the PSI header.
- * @param {number} section_length - The total section length.
- * @returns {object} An object containing parsed private section information.
- */
-export function parsePrivateSectionPayload(
-    view,
-    baseOffset,
-    section_syntax_indicator,
-    section_length
-) {
-    if (section_syntax_indicator === 0) {
-        // Short format: the entire payload is private data.
-        return {
-            type: 'Private Section (short)',
-            private_data: {
-                value: `${view.byteLength} bytes of private data`,
-                offset: baseOffset,
-                length: view.byteLength,
-            },
-        };
-    }
-
-    // Long format: has additional header fields before the private data.
-    const table_id_extension = view.getUint16(0);
-    const version_byte = view.getUint8(2);
-    const version_number = (version_byte >> 1) & 0x1f;
-    const current_next_indicator = version_byte & 1;
-    const section_number = view.getUint8(3);
-    const last_section_number = view.getUint8(4);
-
-    const privateDataOffset = 5;
-    const privateDataLength = section_length - (privateDataOffset + 4); // 5 bytes of header + 4 bytes CRC
-
-    const private_data = {
-        value: `${privateDataLength} bytes of private data`,
-        offset: baseOffset + privateDataOffset,
-        length: privateDataLength,
-    };
-
-    return {
-        type: 'Private Section (long)',
-        table_id_extension: {
-            value: table_id_extension,
-            offset: baseOffset,
-            length: 2,
-        },
-        version_number: {
-            value: version_number,
-            offset: baseOffset + 2,
-            length: 0.625,
-        },
-        current_next_indicator: {
-            value: current_next_indicator,
-            offset: baseOffset + 2,
-            length: 0.125,
-        },
-        section_number: {
-            value: section_number,
-            offset: baseOffset + 3,
-            length: 1,
-        },
-        last_section_number: {
-            value: last_section_number,
-            offset: baseOffset + 4,
-            length: 1,
-        },
-        private_data,
-    };
-}
-
-export const privateSectionTooltipData = {
-    'Private Section': {
-        text: 'A section containing user-defined private data. The structure and meaning of this data is not defined by the MPEG-2 specification.',
-        ref: 'Clause 2.4.4.11',
-    },
-};
diff --git a/js/infrastructure/segment/ts/parsers/psi-section.js b/js/infrastructure/segment/ts/parsers/psi-section.js
deleted file mode 100644
index 04cd7c8..0000000
--- a/js/infrastructure/segment/ts/parsers/psi-section.js
+++ /dev/null
@@ -1,183 +0,0 @@
-// ... (MPEG_CRC_TABLE and calculateCRC32 function are unchanged) ...
-
-const MPEG_CRC_TABLE = [
-    0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
-    0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
-    0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70, 0x48d0c6c7,
-    0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
-    0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3,
-    0x709f7b7a, 0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
-    0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef,
-    0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
-    0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb,
-    0xceb42022, 0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
-    0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
-    0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
-    0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4,
-    0x0808d07d, 0x0cc9cdca, 0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
-    0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08,
-    0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
-    0xaca5c697, 0xac64db20, 0xa127fdf9, 0xa5e6e04e, 0xbba1b04b, 0xbf60adfc,
-    0xb2238b25, 0xb6e29692, 0x8eaf2b2f, 0x8a6e3698, 0x872d1041, 0x83ec0df6,
-    0x9dabcdf3, 0x9968d044, 0x942bf69d, 0x90eafb2a, 0xe0b41de7, 0xe4750050,
-    0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
-    0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
-    0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
-    0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56, 0x4bc510e1,
-    0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
-    0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5,
-    0x3f9b762c, 0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
-    0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e, 0xf5ee4bb9,
-    0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
-    0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd,
-    0xcda1f604, 0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
-    0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
-    0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
-    0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2,
-    0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
-    0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e,
-    0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
-    0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a,
-    0x2d15ebe3, 0x29d4f654,
-];
-
-function calculateCRC32(view) {
-    let crc = 0xffffffff;
-    for (let i = 0; i < view.byteLength; i++) {
-        const byte = view.getUint8(i);
-        crc = (crc << 8) ^ MPEG_CRC_TABLE[((crc >> 24) ^ byte) & 0xff];
-    }
-    return crc >>> 0; // Ensure unsigned 32-bit
-}
-
-/**
- * Parses the common header of a PSI section.
- * @param {DataView} view - A DataView of the complete PSI section data.
- * @returns {{header: object, payload: DataView, crc: string, isValid: boolean}} Parsed data.
- */
-export function parsePsiSection(view) {
-    if (view.byteLength < 3) {
-        return {
-            header: { error: 'Section too short for header' },
-            payload: new DataView(new ArrayBuffer(0)),
-            crc: 'N/A',
-            isValid: false,
-        };
-    }
-
-    const table_id = view.getUint8(0);
-    const section_syntax_indicator = view.getUint8(1) >> 7;
-    const section_length = view.getUint16(1) & 0x0fff;
-
-    if (section_syntax_indicator === 0) {
-        // Short format section (e.g., used by SCTE-35 in private_section).
-        // It has no CRC and a simpler header. The section_length is just the payload.
-        const totalSectionLength = 3 + section_length;
-        if (totalSectionLength > view.byteLength) {
-            return {
-                header: {
-                    table_id: `0x${table_id.toString(16)}`,
-                    error: 'Invalid short section length',
-                    section_length,
-                },
-                payload: new DataView(new ArrayBuffer(0)),
-                crc: null, // No CRC for short sections
-                isValid: false,
-            };
-        }
-        const payload = new DataView(
-            view.buffer,
-            view.byteOffset + 3,
-            section_length
-        );
-        return {
-            header: {
-                table_id: `0x${table_id.toString(16).padStart(2, '0')}`,
-                section_syntax_indicator,
-                section_length,
-            },
-            payload,
-            crc: null, // No CRC for short sections
-            isValid: true, // Cannot validate without CRC
-        };
-    }
-
-    // --- Long format section (with CRC) from here on ---
-    if (section_length > 1021) {
-        return {
-            header: {
-                table_id: `0x${table_id.toString(16)}`,
-                error: 'Section length exceeds maximum (1021)',
-                section_length,
-            },
-            payload: new DataView(new ArrayBuffer(0)),
-            crc: '0x00000000',
-            isValid: false,
-        };
-    }
-
-    const totalSectionLength = 3 + section_length;
-    if (totalSectionLength > view.byteLength) {
-        return {
-            header: {
-                table_id: `0x${table_id.toString(16)}`,
-                error: 'Section length extends beyond packet payload',
-                section_length,
-            },
-            payload: new DataView(new ArrayBuffer(0)),
-            crc: '0x00000000',
-            isValid: false,
-        };
-    }
-
-    // A long section must contain at least the 5-byte header extension and 4-byte CRC
-    if (section_length < 9) {
-        return {
-            header: {
-                table_id: `0x${table_id.toString(16)}`,
-                error: 'Section length too short for long format (must be >= 9)',
-                section_length,
-            },
-            payload: new DataView(new ArrayBuffer(0)),
-            crc: '0x00000000',
-            isValid: false,
-        };
-    }
-
-    const dataForCrcView = new DataView(
-        view.buffer,
-        view.byteOffset,
-        totalSectionLength - 4
-    );
-    const calculatedCrc = calculateCRC32(dataForCrcView);
-    const readCrc = view.getUint32(totalSectionLength - 4);
-    const isValid = calculatedCrc === readCrc;
-
-    const header = {
-        table_id: `0x${table_id.toString(16).padStart(2, '0')}`,
-        section_syntax_indicator,
-        section_length,
-        table_id_extension: view.getUint16(3),
-        version_number: (view.getUint8(5) >> 1) & 0x1f,
-        current_next_indicator: view.getUint8(5) & 0x01,
-        section_number: view.getUint8(6),
-        last_section_number: view.getUint8(7),
-    };
-
-    const payloadOffset = 8;
-    const payloadEndOffset = totalSectionLength - 4; // Start of CRC
-    const payloadLength = payloadEndOffset - payloadOffset;
-
-    const payload = new DataView(
-        view.buffer,
-        view.byteOffset + payloadOffset,
-        payloadLength
-    );
-
-    return {
-        header,
-        payload,
-        crc: `0x${readCrc.toString(16).padStart(8, '0')}`,
-        isValid,
-    };
-}
diff --git a/js/infrastructure/segment/ts/parsers/tsdt.js b/js/infrastructure/segment/ts/parsers/tsdt.js
deleted file mode 100644
index 2cc3581..0000000
--- a/js/infrastructure/segment/ts/parsers/tsdt.js
+++ /dev/null
@@ -1,24 +0,0 @@
-import { parseDescriptors } from './descriptors/index.js';
-
-// Parses the payload of a Transport Stream Description Table (TSDT) section.
-// Extracts descriptors that apply to the entire transport stream.
-
-/**
- * Parses descriptors from a TSDT section payload.
- * @param {DataView} view - A DataView of the TSDT section's payload.
- * @param {number} baseOffset - The offset of the payload within the segment.
- * @returns {object} An object containing parsed TSDT information.
- */
-export function parseTsdtPayload(view, baseOffset) {
-    return {
-        type: 'TSDT',
-        descriptors: parseDescriptors(view, baseOffset),
-    };
-}
-
-export const tsdtTooltipData = {
-    TSDT: {
-        text: 'Transport Stream Description Table. Contains descriptors that apply to the entire transport stream.',
-        ref: 'Clause 2.4.4.13',
-    },
-};
diff --git a/js/infrastructure/segment/vtt/parser.js b/js/infrastructure/segment/vtt/parser.js
deleted file mode 100644
index 9c5a241..0000000
--- a/js/infrastructure/segment/vtt/parser.js
+++ /dev/null
@@ -1,167 +0,0 @@
-/**
- * A simple, robust parser for the WebVTT file format.
- * https://www.w3.org/TR/webvtt1/
- */
-
-function parseTimestamp(timestampStr) {
-    if (!timestampStr) return null;
-    const [timePart, msPart] = timestampStr.split('.');
-    if (!msPart || msPart.length !== 3 || !timePart) return null;
-
-    const parts = timePart.split(':').map((p) => parseInt(p, 10));
-    const milliseconds = parseInt(msPart, 10);
-
-    let hours = 0,
-        minutes = 0,
-        seconds = 0;
-
-    if (parts.length === 3) {
-        [hours, minutes, seconds] = parts;
-    } else if (parts.length === 2) {
-        [minutes, seconds] = parts;
-    } else {
-        return null; // Invalid format
-    }
-
-    if (
-        isNaN(hours) ||
-        isNaN(minutes) ||
-        isNaN(seconds) ||
-        isNaN(milliseconds)
-    ) {
-        return null;
-    }
-
-    return hours * 3600 + minutes * 60 + seconds + milliseconds / 1000;
-}
-
-function parseCue(blockLines, result, firstLineNumber) {
-    const cue = {
-        id: null,
-        startTime: null,
-        endTime: null,
-        settings: {},
-        payload: [],
-    };
-    let lineIndex = 0;
-
-    if (!blockLines[lineIndex].includes('-->')) {
-        cue.id = blockLines[lineIndex].trim();
-        lineIndex++;
-    }
-
-    if (
-        lineIndex >= blockLines.length ||
-        !blockLines[lineIndex].includes('-->')
-    ) {
-        result.errors.push(
-            `Malformed cue at line ${firstLineNumber}: missing timestamp.`
-        );
-        return;
-    }
-
-    const timestampLine = blockLines[lineIndex];
-    const parts = timestampLine.split(/\s+/).filter((p) => p);
-
-    if (parts.length < 3 || parts[1] !== '-->') {
-        result.errors.push(
-            `Invalid timestamp format at line ${
-                firstLineNumber + lineIndex
-            }: "${timestampLine}"`
-        );
-        return;
-    }
-
-    cue.startTime = parseTimestamp(parts[0]);
-    cue.endTime = parseTimestamp(parts[2]);
-
-    if (cue.startTime === null || cue.endTime === null) {
-        result.errors.push(
-            `Invalid timestamp value at line ${
-                firstLineNumber + lineIndex
-            }: "${timestampLine}"`
-        );
-        return;
-    }
-
-    if (parts.length > 3) {
-        parts.slice(3).forEach((setting) => {
-            const [key, value] = setting.split(':');
-            if (key && value) {
-                cue.settings[key] = value;
-            }
-        });
-    }
-    lineIndex++;
-
-    cue.payload = blockLines.slice(lineIndex);
-    result.cues.push(cue);
-}
-
-function processBlock(blockLines, result, firstLineNumber) {
-    const firstLine = blockLines[0].trim();
-    if (firstLine.startsWith('STYLE')) {
-        result.styles.push(blockLines.slice(1).join('\n'));
-    } else if (firstLine.startsWith('REGION')) {
-        const region = {};
-        blockLines.slice(1).forEach((line) => {
-            const [key, value] = line.split(':');
-            if (key && value) {
-                region[key.trim()] = value.trim();
-            }
-        });
-        result.regions.push(region);
-    } else if (firstLine.startsWith('NOTE')) {
-        // Ignore NOTE blocks
-    } else {
-        // Assume it's a cue
-        parseCue(blockLines, result, firstLineNumber);
-    }
-}
-
-/**
- * Parses a WebVTT file string into a structured object.
- * @param {string} vttString The raw content of the .vtt file.
- * @returns {{
- *   regions: object[],
- *   styles: string[],
- *   cues: object[],
- *   errors: string[]
- * }}
- */
-export function parseVTT(vttString) {
-    const lines = vttString.replace(/\r\n/g, '\n').split('\n');
-    const result = { regions: [], styles: [], cues: [], errors: [] };
-    let i = 0;
-
-    if (i >= lines.length || !lines[i].startsWith('WEBVTT')) {
-        result.errors.push(
-            'Invalid WEBVTT signature. File must start with "WEBVTT".'
-        );
-        return result;
-    }
-    i++;
-
-    let currentBlockLines = [];
-    let blockStartLine = 0;
-
-    for (; i < lines.length; i++) {
-        const line = lines[i];
-        if (line.trim() === '') {
-            if (currentBlockLines.length > 0) {
-                processBlock(currentBlockLines, result, blockStartLine);
-                currentBlockLines = [];
-            }
-        } else {
-            if (currentBlockLines.length === 0) {
-                blockStartLine = i + 1;
-            }
-            currentBlockLines.push(line);
-        }
-    }
-    if (currentBlockLines.length > 0) {
-        processBlock(currentBlockLines, result, blockStartLine);
-    }
-
-    return result;
-}
diff --git a/js/services/cmafService.js b/js/services/cmafService.js
deleted file mode 100644
index 9018dc7..0000000
--- a/js/services/cmafService.js
+++ /dev/null
@@ -1,111 +0,0 @@
-import { eventBus } from '../app/event-bus.js';
-import { storeActions } from '../app/store.js';
-import {
-    validateCmafTrack,
-    validateCmafSwitchingSets,
-} from '../domain/cmaf/validator.js';
-import { resolveBaseUrl } from '../infrastructure/manifest/dash/recursive-parser.js';
-import { findInitSegmentUrl } from '../infrastructure/manifest/dash/segment-parser.js';
-import { getParsedSegment } from './segmentService.js';
-
-/**
- * A private, isolated segment fetcher for this service that does not interact
- * with the global store or cache directly, but uses the public segment service API.
- * @param {string} url The URL of the ISOBFF segment to fetch and parse.
- * @returns {Promise<object>} The parsed segment data.
- * @throws {Error} If the fetch or parsing fails.
- */
-async function _fetchAndParseIsobmff(url) {
-    // Re-use the main segment service, which now handles caching and parsing.
-    return getParsedSegment(url);
-}
-
-/**
- * Runs all CMAF validation checks for a given stream and stores the results.
- * @param {import('../app/types.ts').Stream} stream
- */
-async function runCmafValidation(stream) {
-    if (stream.protocol !== 'dash') {
-        return;
-    }
-
-    try {
-        const manifestElement = stream.manifest.serializedManifest;
-        const allResults = [];
-
-        // --- Track Conformance Validation ---
-        const firstPeriod = stream.manifest?.periods[0];
-        const firstAS = firstPeriod?.adaptationSets.find(
-            (as) => as.contentType === 'video'
-        );
-        const firstRep = firstAS?.representations[0];
-
-        if (firstRep && firstAS && firstPeriod) {
-            const resolvedBaseUrl = resolveBaseUrl(
-                stream.baseUrl,
-                manifestElement,
-                firstPeriod.serializedManifest,
-                firstAS.serializedManifest,
-                firstRep.serializedManifest
-            );
-            const initUrl = findInitSegmentUrl(
-                firstRep,
-                firstAS,
-                firstPeriod,
-                resolvedBaseUrl
-            );
-            const mediaSegment = stream.dashRepresentationState
-                .get(`${firstPeriod.id}-${firstRep.id}`)
-                ?.segments.find((s) => /** @type {any} */ (s).type === 'Media');
-
-            const mediaUrl = mediaSegment
-                ? /** @type {any} */ (mediaSegment).resolvedUrl
-                : undefined;
-
-            if (initUrl && mediaUrl) {
-                const [initData, mediaData] = await Promise.all([
-                    _fetchAndParseIsobmff(initUrl),
-                    _fetchAndParseIsobmff(mediaUrl),
-                ]);
-                const trackResults = validateCmafTrack(
-                    /** @type {any} */ (initData).data,
-                    /** @type {any} */ (mediaData).data
-                );
-                allResults.push(...trackResults);
-            }
-        }
-
-        // --- Switching Set Validation ---
-        const switchingSetResults = await validateCmafSwitchingSets(
-            stream,
-            _fetchAndParseIsobmff
-        );
-        allResults.push(...switchingSetResults);
-
-        // Store results on the stream object
-        const semanticData = new Map(stream.semanticData);
-        semanticData.set('cmafValidation', allResults);
-        storeActions.updateStream(stream.id, { semanticData });
-    } catch (e) {
-        console.error(`[CMAF Service] Error during validation: ${e.message}`);
-        const semanticData = new Map(stream.semanticData);
-        semanticData.set('cmafValidation', [
-            {
-                id: 'CMAF-META',
-                text: 'CMAF Conformance',
-                status: 'fail',
-                details: `Validation failed to run: ${e.message}`,
-            },
-        ]);
-        storeActions.updateStream(stream.id, { semanticData });
-    }
-}
-
-/**
- * Initializes the CMAF service to listen for analysis completion events.
- */
-export function initializeCmafService() {
-    eventBus.subscribe('state:analysis-complete', ({ streams }) => {
-        streams.forEach(runCmafValidation);
-    });
-}
diff --git a/js/services/debugService.js b/js/services/debugService.js
deleted file mode 100644
index a057944..0000000
--- a/js/services/debugService.js
+++ /dev/null
@@ -1,66 +0,0 @@
-import { useStore } from '../app/store.js';
-import { showToast } from '../ui/components/toast.js';
-
-/**
- * Serializes the application state for debugging, handling complex types.
- * @param {object} state The application state from the store.
- * @returns {string} A JSON string representation of the state.
- */
-function serializeStateForDebug(state) {
-    const replacer = (key, value) => {
-        if (value instanceof Map) {
-            return {
-                __dataType: 'Map',
-                value: Array.from(value.entries()),
-            };
-        }
-        if (value instanceof Set) {
-            return {
-                __dataType: 'Set',
-                value: Array.from(value.values()),
-            };
-        }
-        if (key === 'serializedManifest') {
-            return '[Circular/ParsedObject]';
-        }
-        return value;
-    };
-
-    const debugData = {
-        timestamp: new Date().toISOString(),
-        appState: state,
-    };
-
-    return JSON.stringify(debugData, replacer, 2);
-}
-
-/**
- * Gathers the current application state, serializes it, and copies it to the clipboard.
- * Shows success or failure toasts to the user.
- */
-export function copyDebugInfoToClipboard() {
-    const state = useStore.getState();
-
-    try {
-        const jsonString = serializeStateForDebug(state);
-
-        navigator.clipboard
-            .writeText(jsonString)
-            .then(() => {
-                showToast({
-                    message: 'Debug info copied to clipboard!',
-                    type: 'pass',
-                });
-            })
-            .catch((err) => {
-                console.error('Failed to copy debug info:', err);
-                showToast({
-                    message: 'Failed to copy debug info.',
-                    type: 'fail',
-                });
-            });
-    } catch (error) {
-        console.error('Error serializing debug state:', error);
-        showToast({ message: 'Error creating debug info.', type: 'fail' });
-    }
-}
diff --git a/js/services/hlsVariantPollerService.js b/js/services/hlsVariantPollerService.js
deleted file mode 100644
index 353d64b..0000000
--- a/js/services/hlsVariantPollerService.js
+++ /dev/null
@@ -1,175 +0,0 @@
-import { eventBus } from '../app/event-bus.js';
-import { useStore, storeActions } from '../app/store.js';
-
-const pollers = new Map();
-let managerInterval = null;
-
-export async function pollHlsVariant(streamId, variantUri) {
-    const stream = useStore.getState().streams.find((s) => s.id === streamId);
-    if (!stream) {
-        stopPoller(streamId, variantUri);
-        return;
-    }
-
-    // NOTE: The fetch/parse is now offloaded to the main worker via streamService.
-    // This poller's job is just to trigger the request at intervals.
-    eventBus.dispatch('hls:media-playlist-fetch-request', {
-        streamId,
-        variantUri,
-        isBackground: true, // Signal that this is a background poll
-    });
-}
-
-function startPoller(stream, variantUri) {
-    const pollerKey = `${stream.id}-${variantUri}`;
-    if (pollers.has(pollerKey)) return;
-
-    // Perform an immediate fetch first
-    pollHlsVariant(stream.id, variantUri);
-
-    // Then set up the interval
-    const pollInterval = (stream.manifest?.minBufferTime || 2) * 1000;
-    const intervalId = setInterval(
-        () => pollHlsVariant(stream.id, variantUri),
-        pollInterval
-    );
-    pollers.set(pollerKey, intervalId);
-}
-
-function stopPoller(streamId, variantUri) {
-    const pollerKey = `${streamId}-${variantUri}`;
-    if (pollers.has(pollerKey)) {
-        clearInterval(pollers.get(pollerKey));
-        pollers.delete(pollerKey);
-    }
-}
-
-export function manageHlsPollers() {
-    const hlsStreams = useStore
-        .getState()
-        .streams.filter(
-            (s) => s.protocol === 'hls' && s.manifest?.type === 'dynamic'
-        );
-
-    for (const stream of hlsStreams) {
-        for (const [variantUri, state] of stream.hlsVariantState.entries()) {
-            const pollerKey = `${stream.id}-${variantUri}`;
-            const shouldBePolling = state.isPolling && state.isExpanded;
-            const isCurrentlyPolling = pollers.has(pollerKey);
-
-            if (shouldBePolling && !isCurrentlyPolling) {
-                startPoller(stream, variantUri);
-            } else if (!shouldBePolling && isCurrentlyPolling) {
-                stopPoller(stream.id, variantUri);
-            }
-        }
-    }
-}
-
-function updateVariantState(streamId, variantUri, updates) {
-    const stream = useStore.getState().streams.find((s) => s.id === streamId);
-    if (stream) {
-        const newVariantState = new Map(stream.hlsVariantState);
-        const currentState = newVariantState.get(variantUri);
-        if (currentState) {
-            newVariantState.set(variantUri, { ...currentState, ...updates });
-            storeActions.updateStream(streamId, {
-                hlsVariantState: newVariantState,
-            });
-        }
-    }
-}
-
-export function initializeHlsVariantPoller() {
-    if (managerInterval) clearInterval(managerInterval);
-    managerInterval = setInterval(manageHlsPollers, 1000);
-
-    // --- State Update Listeners ---
-    eventBus.subscribe(
-        'hls-explorer:toggle-variant',
-        ({ streamId, variantUri }) => {
-            const stream = useStore
-                .getState()
-                .streams.find((s) => s.id === streamId);
-            const variantState = stream?.hlsVariantState.get(variantUri);
-            if (variantState) {
-                const isNowExpanded = !variantState.isExpanded;
-                const needsFetch =
-                    isNowExpanded &&
-                    variantState.segments.length === 0 &&
-                    !variantState.error;
-
-                // Atomically update both `isExpanded` and `isLoading`
-                updateVariantState(streamId, variantUri, {
-                    isExpanded: isNowExpanded,
-                    isLoading: needsFetch, // Set loading state here
-                });
-
-                // Then, if needed, trigger the fetch. The state is already updated.
-                if (needsFetch) {
-                    eventBus.dispatch('hls:media-playlist-fetch-request', {
-                        streamId,
-                        variantUri,
-                        isBackground: false, // This is a user action
-                    });
-                }
-            }
-        }
-    );
-
-    eventBus.subscribe(
-        'hls-explorer:toggle-polling',
-        ({ streamId, variantUri }) => {
-            const stream = useStore
-                .getState()
-                .streams.find((s) => s.id === streamId);
-            const variantState = stream?.hlsVariantState.get(variantUri);
-            if (variantState) {
-                updateVariantState(streamId, variantUri, {
-                    isPolling: !variantState.isPolling,
-                });
-            }
-        }
-    );
-
-    eventBus.subscribe(
-        'hls-explorer:set-display-mode',
-        ({ streamId, variantUri, mode }) => {
-            updateVariantState(streamId, variantUri, { displayMode: mode });
-        }
-    );
-
-    // --- Post-Analysis Initialization Logic ---
-    eventBus.subscribe('state:analysis-complete', ({ streams }) => {
-        // After analysis, if there's an HLS master playlist, pre-fetch the segments for the first variant.
-        const firstHlsStream = streams.find(
-            (s) => s.protocol === 'hls' && s.manifest?.isMaster
-        );
-        if (firstHlsStream) {
-            const firstVariantUri = firstHlsStream.hlsVariantState
-                .keys()
-                .next().value;
-            if (firstVariantUri) {
-                updateVariantState(firstHlsStream.id, firstVariantUri, {
-                    isLoading: true,
-                });
-                eventBus.dispatch('hls:media-playlist-fetch-request', {
-                    streamId: firstHlsStream.id,
-                    variantUri: firstVariantUri,
-                    isBackground: false, // Initial load is a foreground action
-                });
-            }
-        }
-    });
-}
-
-export function stopAllHlsVariantPolling() {
-    if (managerInterval) {
-        clearInterval(managerInterval);
-        managerInterval = null;
-    }
-    for (const intervalId of pollers.values()) {
-        clearInterval(intervalId);
-    }
-    pollers.clear();
-}
diff --git a/js/services/liveUpdateProcessor.js b/js/services/liveUpdateProcessor.js
deleted file mode 100644
index 25b6251..0000000
--- a/js/services/liveUpdateProcessor.js
+++ /dev/null
@@ -1,240 +0,0 @@
-import { useStore, storeActions } from '../app/store.js';
-import { eventBus } from '../app/event-bus.js';
-import { generateFeatureAnalysis } from '../domain/feature-analysis/analyzer.js';
-import { parseAllSegmentUrls as parseDashSegments } from '../infrastructure/manifest/dash/segment-parser.js';
-import { diffManifest } from '../shared/utils/diff.js';
-import xmlFormatter from 'xml-formatter';
-
-/**
- * A more specific stream type where the protocol is guaranteed to be 'dash' or 'hls'.
- * @typedef {import('../app/types.ts').Stream & { protocol: 'dash' | 'hls' }} KnownProtocolStream
- */
-
-/**
- * Checks for future SCTE-35 events and schedules a high-priority poll.
- * @param {KnownProtocolStream} stream The stream being updated.
- * @param {import('../app/types.ts').Manifest} newManifestObject The newly parsed manifest IR.
- */
-function schedulePollsFromScte35(stream, newManifestObject) {
-    if (stream.manifest.type !== 'dynamic' || !newManifestObject.events) {
-        return;
-    }
-
-    const now = Date.now();
-    const preRollBufferMs = 1000; // Poll 1 second before the event
-
-    for (const event of newManifestObject.events) {
-        if (!event.scte35 || /** @type {any} */ (event.scte35).error) {
-            continue;
-        }
-
-        const command = /** @type {any} */ (event.scte35).splice_command;
-        if (
-            !command ||
-            !command.splice_time ||
-            !command.splice_time.time_specified
-        ) {
-            continue;
-        }
-
-        const ptsTime = command.splice_time.pts_time;
-        const ptsAdjustment =
-            /** @type {any} */ (event.scte35).pts_adjustment || 0;
-        const adjustedPts = ptsTime + ptsAdjustment;
-
-        // Find the most recent Program Clock Reference (PCR) from a segment to anchor our wall-clock calculation
-        // This is a simplified approach; a real-world client would maintain a running timeline.
-        // For our purposes, we anchor to availabilityStartTime.
-        const availabilityStartTime =
-            newManifestObject.availabilityStartTime?.getTime();
-        if (!availabilityStartTime) continue;
-
-        const eventMediaTimeSeconds = adjustedPts / 90000;
-        const eventWallClockTime =
-            availabilityStartTime + eventMediaTimeSeconds * 1000;
-
-        const pollTime = eventWallClockTime - preRollBufferMs;
-
-        if (pollTime > now) {
-            eventBus.dispatch('monitor:schedule-one-time-poll', {
-                streamId: stream.id,
-                pollTime: pollTime,
-                reason: `SCTE-35 ${command.type || 'Event'}`,
-            });
-        }
-    }
-}
-
-/**
- * Compares two sets of compliance results to see if any new issues have appeared.
- * @param {import('../app/types.ts').ComplianceResult[]} oldResults
- * @param {import('../app/types.ts').ComplianceResult[]} newResults
- * @returns {boolean}
- */
-function checkForNewIssues(oldResults, newResults) {
-    if (!Array.isArray(newResults)) return false; // Defensive guard
-    if (!oldResults) {
-        // If there were no old results, any new issue is considered "new".
-        return newResults.some(
-            (res) => res.status === 'fail' || res.status === 'warn'
-        );
-    }
-
-    const oldIssueIds = new Set(
-        oldResults
-            .filter((r) => r.status === 'fail' || r.status === 'warn')
-            .map((r) => r.id)
-    );
-
-    return newResults.some(
-        (r) =>
-            (r.status === 'fail' || r.status === 'warn') &&
-            !oldIssueIds.has(r.id)
-    );
-}
-
-/**
- * The main handler for processing a live manifest update. This version is optimized
- * to build a partial update object, avoiding expensive deep clones of the entire stream state.
- * @param {object} updateData The event data from `livestream:manifest-updated`.
- */
-function processLiveUpdate(updateData) {
-    const {
-        streamId,
-        newManifestString,
-        newManifestObject,
-        oldManifestString,
-        complianceResults,
-        serializedManifest,
-    } = updateData;
-    const stream = useStore.getState().streams.find((s) => s.id === streamId);
-
-    if (!stream || stream.protocol === 'unknown') return;
-
-    // --- Create a new manifestUpdates array ---
-    let formattedOld = oldManifestString;
-    let formattedNew = newManifestString;
-
-    if (stream.protocol === 'dash') {
-        formattedOld = xmlFormatter(oldManifestString, { indentation: '  ' });
-        formattedNew = xmlFormatter(newManifestString, { indentation: '  ' });
-    }
-
-    const diffHtml = diffManifest(formattedOld, formattedNew, stream.protocol);
-    const previousResults = stream.manifestUpdates[0]?.complianceResults;
-    const hasNewIssues = checkForNewIssues(previousResults, complianceResults);
-
-    const newUpdate = {
-        timestamp: new Date().toLocaleTimeString(),
-        diffHtml,
-        rawManifest: newManifestString,
-        complianceResults,
-        hasNewIssues,
-        serializedManifest,
-    };
-
-    const newManifestUpdates = [newUpdate, ...stream.manifestUpdates].slice(
-        0,
-        20
-    );
-
-    // --- Recalculate feature analysis ---
-    const newFeatureAnalysisState = {
-        ...stream.featureAnalysis,
-        manifestCount: stream.featureAnalysis.manifestCount + 1,
-        results: new Map(stream.featureAnalysis.results),
-    };
-
-    const newAnalysisResults = generateFeatureAnalysis(
-        newManifestObject,
-        stream.protocol,
-        serializedManifest
-    );
-
-    Object.entries(newAnalysisResults).forEach(([name, result]) => {
-        const existing = newFeatureAnalysisState.results.get(name);
-        if (result.used && (!existing || !existing.used)) {
-            newFeatureAnalysisState.results.set(name, {
-                used: true,
-                details: result.details,
-            });
-        }
-    });
-
-    // --- Recalculate segment state ---
-    let newDashState, newHlsState;
-    if (stream.protocol === 'dash') {
-        newDashState = new Map(stream.dashRepresentationState);
-        const newSegmentsByCompositeKey = parseDashSegments(
-            serializedManifest,
-            stream.baseUrl
-        );
-        Object.entries(newSegmentsByCompositeKey).forEach(
-            ([compositeKey, newSegments]) => {
-                const repState = newDashState.get(compositeKey);
-                if (repState) {
-                    const existingUrls = new Set(
-                        repState.segments.map(
-                            (s) => /** @type {any} */ (s).resolvedUrl
-                        )
-                    );
-                    newSegments.forEach((newSeg) => {
-                        if (
-                            !existingUrls.has(
-                                /** @type {any} */ (newSeg).resolvedUrl
-                            )
-                        ) {
-                            repState.segments.push(newSeg);
-                        }
-                    });
-                    repState.freshSegmentUrls = new Set(
-                        newSegments.map(
-                            (s) => /** @type {any} */ (s).resolvedUrl
-                        )
-                    );
-                }
-            }
-        );
-    } else {
-        // HLS
-        newHlsState = new Map(stream.hlsVariantState);
-        if (!newManifestObject.isMaster) {
-            const variant = newHlsState.get(stream.originalUrl);
-            if (variant) {
-                variant.segments = newManifestObject.segments || [];
-                variant.freshSegmentUrls = new Set(
-                    variant.segments.map(
-                        (s) => /** @type {any} */ (s).resolvedUrl
-                    )
-                );
-            }
-        }
-    }
-
-    // --- Schedule polls based on SCTE-35 ---
-    schedulePollsFromScte35(
-        /** @type {KnownProtocolStream} */ (stream),
-        newManifestObject
-    );
-
-    // --- Construct the partial update payload ---
-    const updatePayload = {
-        rawManifest: newManifestString,
-        manifest: newManifestObject,
-        manifestUpdates: newManifestUpdates,
-        featureAnalysis: newFeatureAnalysisState,
-        dashRepresentationState: newDashState,
-        hlsVariantState: newHlsState,
-    };
-
-    // --- Dispatch the update action ---
-    storeActions.updateStream(streamId, updatePayload);
-    eventBus.dispatch('stream:data-updated', { streamId });
-}
-
-/**
- * Initializes the service by subscribing to the live manifest update event.
- */
-export function initializeLiveUpdateProcessor() {
-    eventBus.subscribe('livestream:manifest-updated', processLiveUpdate);
-}
diff --git a/js/services/modalService.js b/js/services/modalService.js
deleted file mode 100644
index 9c882de..0000000
--- a/js/services/modalService.js
+++ /dev/null
@@ -1,29 +0,0 @@
-import { storeActions } from '../app/store.js';
-
-/**
- * Opens the global modal with specific content.
- * @param {object} options
- * @param {string} options.title - The title to display in the modal header.
- * @param {string} options.url - The URL or identifier for the content being displayed.
- * @param {{ type: string; data: any; }} options.content - A serializable object describing the content to be rendered.
- */
-export function openModalWithContent({ title, url, content }) {
-    storeActions.setModalState({
-        isModalOpen: true,
-        modalTitle: title,
-        modalUrl: url,
-        modalContent: content,
-    });
-}
-
-/**
- * Closes the global modal and resets its state.
- */
-export function closeModal() {
-    storeActions.setModalState({
-        isModalOpen: false,
-        modalTitle: '',
-        modalUrl: '',
-        modalContent: null,
-    });
-}
diff --git a/js/services/primaryStreamMonitorService.js b/js/services/primaryStreamMonitorService.js
deleted file mode 100644
index 5ef27ff..0000000
--- a/js/services/primaryStreamMonitorService.js
+++ /dev/null
@@ -1,218 +0,0 @@
-import { eventBus } from '../app/event-bus.js';
-import { useStore } from '../app/store.js';
-
-const pollers = new Map();
-const oneTimePollers = new Map(); // Store for high-priority, one-off polls
-let managerInterval = null;
-
-// The monitor service will have its own dedicated worker to avoid conflicts with the main analysis worker.
-const liveUpdateWorker = new Worker('/dist/worker.js', { type: 'module' });
-
-liveUpdateWorker.onmessage = (event) => {
-    const { type, payload } = event.data;
-
-    if (type === 'live-update-parsed') {
-        const {
-            streamId,
-            newManifestObject,
-            finalManifestString,
-            oldRawManifest,
-            complianceResults,
-            serializedManifest,
-        } = payload;
-        eventBus.dispatch('livestream:manifest-updated', {
-            streamId,
-            newManifestString: finalManifestString,
-            newManifestObject,
-            oldManifestString: oldRawManifest,
-            complianceResults,
-            serializedManifest,
-        });
-    } else if (type === 'live-update-error') {
-        console.error(
-            `[LiveStreamMonitor] Worker failed to parse update for stream ${payload.streamId}:`,
-            payload.error
-        );
-    }
-};
-
-/**
- * The core polling function. Fetches the latest manifest for a live stream,
- * delegates parsing to the worker, and awaits the parsed result.
- * @param {number} streamId The ID of the stream to poll.
- */
-async function monitorStream(streamId) {
-    const stream = useStore.getState().streams.find((s) => s.id === streamId);
-    if (!stream || !stream.originalUrl) {
-        stopMonitoring(streamId); // Stop if stream is gone
-        return;
-    }
-
-    try {
-        const response = await fetch(stream.originalUrl);
-        if (!response.ok) return;
-        const newManifestString = await response.text();
-
-        if (newManifestString === stream.rawManifest) {
-            return;
-        }
-
-        // Offload the parsing to the worker
-        liveUpdateWorker.postMessage({
-            type: 'parse-live-update',
-            payload: {
-                streamId: stream.id,
-                newManifestString,
-                oldRawManifest: stream.rawManifest,
-                protocol: stream.protocol,
-                baseUrl: stream.baseUrl,
-                hlsDefinedVariables: stream.hlsDefinedVariables,
-                // For HLS delta updates, the worker needs the old parsed object.
-                oldManifestObjectForDelta: stream.manifest?.serializedManifest,
-            },
-        });
-    } catch (e) {
-        console.error(
-            `[LiveStreamMonitor] Error fetching update for stream ${stream.id}:`,
-            e
-        );
-    }
-}
-
-/**
- * Starts the polling monitor for a given stream if it's dynamic.
- * @param {import('../app/types.js').Stream} stream
- */
-function startMonitoring(stream) {
-    if (pollers.has(stream.id)) {
-        return; // Already monitoring
-    }
-
-    if (stream.manifest?.type === 'dynamic' && stream.originalUrl) {
-        const updatePeriodSeconds =
-            stream.manifest.minimumUpdatePeriod ||
-            stream.manifest.minBufferTime ||
-            2;
-        const pollInterval = Math.max(updatePeriodSeconds * 1000, 2000); // Enforce min 2s poll
-
-        const pollerId = setInterval(
-            () => monitorStream(stream.id),
-            pollInterval
-        );
-        pollers.set(stream.id, pollerId);
-    }
-}
-
-/**
- * Stops the polling monitor for a specific stream.
- * @param {number} streamId
- */
-function stopMonitoring(streamId) {
-    if (pollers.has(streamId)) {
-        clearInterval(pollers.get(streamId));
-        pollers.delete(streamId);
-    }
-    // Also clear any scheduled one-time polls for this stream
-    if (oneTimePollers.has(streamId)) {
-        clearTimeout(oneTimePollers.get(streamId));
-        oneTimePollers.delete(streamId);
-    }
-}
-
-/**
- * This manager function runs to synchronize the polling state
- * with the per-stream state. Now exported for deterministic testing.
- */
-export function managePollers() {
-    const dynamicStreams = useStore
-        .getState()
-        .streams.filter((s) => s.manifest?.type === 'dynamic');
-
-    dynamicStreams.forEach((stream) => {
-        const isCurrentlyPolling = pollers.has(stream.id);
-
-        if (stream.isPolling && !isCurrentlyPolling) {
-            startMonitoring(stream);
-        } else if (!stream.isPolling && isCurrentlyPolling) {
-            stopMonitoring(stream.id);
-        }
-    });
-
-    // Clean up pollers for streams that no longer exist
-    for (const streamId of pollers.keys()) {
-        if (!dynamicStreams.some((s) => s.id === streamId)) {
-            stopMonitoring(streamId);
-        }
-    }
-}
-
-/**
- * Schedules a high-priority, one-time poll for a specific stream.
- * @param {object} detail The event detail.
- * @param {number} detail.streamId The ID of the stream.
- * @param {number} detail.pollTime The UTC timestamp when the poll should execute.
- * @param {string} detail.reason A description of why the poll is being scheduled.
- */
-function scheduleOneTimePoll({ streamId, pollTime, reason }) {
-    const now = Date.now();
-    const delay = pollTime - now;
-
-    if (delay <= 0) {
-        return; // Event is in the past
-    }
-
-    // Do not schedule if another one-time poll is already pending for this stream
-    if (oneTimePollers.has(streamId)) {
-        return;
-    }
-
-    console.log(
-        `[Monitor] Scheduling high-priority poll for stream ${streamId} in ${delay}ms. Reason: ${reason}`
-    );
-
-    const timerId = setTimeout(() => {
-        console.log(
-            `[Monitor] Executing high-priority poll for stream ${streamId}. Reason: ${reason}`
-        );
-        monitorStream(streamId);
-        oneTimePollers.delete(streamId);
-    }, delay);
-
-    oneTimePollers.set(streamId, timerId);
-}
-
-/**
- * Initializes the monitoring service.
- */
-export function initializeLiveStreamMonitor() {
-    if (managerInterval) {
-        clearInterval(managerInterval);
-    }
-    // The interval is for the live application, tests will call managePollers directly.
-    managerInterval = setInterval(managePollers, 1000);
-    eventBus.subscribe('state:stream-updated', managePollers);
-    eventBus.subscribe('state:analysis-complete', managePollers);
-    eventBus.subscribe('manifest:force-reload', ({ streamId }) =>
-        monitorStream(streamId)
-    );
-    eventBus.subscribe('monitor:schedule-one-time-poll', scheduleOneTimePoll);
-}
-
-/**
- * Stops all active polling monitors and the manager itself.
- */
-export function stopAllMonitoring() {
-    if (managerInterval) {
-        clearInterval(managerInterval);
-        managerInterval = null;
-    }
-    for (const pollerId of pollers.values()) {
-        clearInterval(pollerId);
-    }
-    pollers.clear();
-
-    for (const timerId of oneTimePollers.values()) {
-        clearTimeout(timerId);
-    }
-    oneTimePollers.clear();
-}
diff --git a/js/services/segmentService.js b/js/services/segmentService.js
deleted file mode 100644
index e3661b0..0000000
--- a/js/services/segmentService.js
+++ /dev/null
@@ -1,119 +0,0 @@
-import { useSegmentCacheStore } from '../app/store.js';
-import { eventBus } from '../app/event-bus.js';
-
-const parsingWorker = new Worker('/dist/worker.js', {
-    type: 'module',
-});
-
-parsingWorker.onmessage = (event) => {
-    const { url, parsedData, error } = event.data;
-    const { get, set } = useSegmentCacheStore.getState();
-
-    const entry = get(url);
-    if (!entry) return;
-
-    const finalEntry = {
-        status: error ? 500 : entry.status,
-        data: entry.data,
-        parsedData: parsedData,
-    };
-
-    set(url, finalEntry);
-    eventBus.dispatch('segment:loaded', { url, entry: finalEntry });
-};
-
-parsingWorker.onerror = (error) => {
-    console.error('An error occurred in the parsing worker:', error);
-};
-
-/**
- * The internal implementation that performs the fetch and dispatches to the worker.
- * @param {string} url The URL of the segment to fetch.
- */
-async function _fetchAndParseSegment(url) {
-    const { set } = useSegmentCacheStore.getState();
-    try {
-        const pendingEntry = { status: -1, data: null, parsedData: null };
-        set(url, pendingEntry);
-        eventBus.dispatch('segment:pending', { url });
-
-        const response = await fetch(url, { method: 'GET', cache: 'no-store' });
-        const data = response.ok ? await response.arrayBuffer() : null;
-
-        const entryWithData = {
-            status: response.status,
-            data,
-            parsedData: null,
-        };
-        set(url, entryWithData);
-
-        if (data) {
-            parsingWorker.postMessage({
-                type: 'parse-segment',
-                payload: { url, data },
-            });
-        } else {
-            const errorEntry = {
-                status: response.status,
-                data: null,
-                parsedData: { error: `HTTP ${response.status}` },
-            };
-            set(url, errorEntry);
-            eventBus.dispatch('segment:loaded', { url, entry: errorEntry });
-        }
-    } catch (error) {
-        console.error(`Failed to fetch segment ${url}:`, error);
-        const errorEntry = {
-            status: 0,
-            data: null,
-            parsedData: { error: error.message },
-        };
-        set(url, errorEntry);
-        eventBus.dispatch('segment:loaded', { url, entry: errorEntry });
-    }
-}
-
-/**
- * Public API to get a parsed segment. Returns a promise that resolves with the parsed data.
- * Handles caching, fetching, and event orchestration internally.
- * @param {string} url The URL of the segment to retrieve.
- * @returns {Promise<object>} A promise that resolves with the parsed segment data.
- */
-export function getParsedSegment(url) {
-    const { get } = useSegmentCacheStore.getState();
-    const cachedEntry = get(url);
-
-    if (cachedEntry && cachedEntry.status !== -1 && cachedEntry.parsedData) {
-        if (cachedEntry.parsedData.error) {
-            return Promise.reject(new Error(cachedEntry.parsedData.error));
-        }
-        return Promise.resolve(cachedEntry.parsedData);
-    }
-
-    return new Promise((resolve, reject) => {
-        const onSegmentLoaded = ({ url: loadedUrl, entry }) => {
-            if (loadedUrl === url) {
-                unsubscribe();
-                if (entry.status !== 200) {
-                    reject(new Error(`HTTP ${entry.status} for ${url}`));
-                } else if (entry.parsedData?.error) {
-                    reject(new Error(entry.parsedData.error));
-                } else {
-                    resolve(entry.parsedData);
-                }
-            }
-        };
-
-        const unsubscribe = eventBus.subscribe(
-            'segment:loaded',
-            onSegmentLoaded
-        );
-
-        if (!cachedEntry || cachedEntry.status !== -1) {
-            _fetchAndParseSegment(url);
-        }
-    });
-}
-
-// Service setup: listen for legacy requests to fetch segments.
-eventBus.subscribe('segment:fetch', ({ url }) => _fetchAndParseSegment(url));
diff --git a/js/services/shareService.js b/js/services/shareService.js
deleted file mode 100644
index 109c6fb..0000000
--- a/js/services/shareService.js
+++ /dev/null
@@ -1,37 +0,0 @@
-import { useStore } from '../app/store.js';
-import { showToast } from '../ui/components/toast.js';
-
-/**
- * Constructs a shareable URL from the current streams in the state and
- * copies it to the user's clipboard.
- */
-export function copyShareUrlToClipboard() {
-    const streams = useStore.getState().streams;
-
-    if (streams.length === 0) {
-        return;
-    }
-
-    const url = new URL(window.location.origin + window.location.pathname);
-    streams.forEach((stream) => {
-        if (stream.originalUrl) {
-            url.searchParams.append('url', stream.originalUrl);
-        }
-    });
-
-    navigator.clipboard
-        .writeText(url.href)
-        .then(() => {
-            showToast({
-                message: 'Shareable URL copied to clipboard!',
-                type: 'pass',
-            });
-        })
-        .catch((err) => {
-            console.error('Failed to copy URL: ', err);
-            showToast({
-                message: 'Failed to copy URL to clipboard.',
-                type: 'fail',
-            });
-        });
-}
diff --git a/js/services/streamActionsService.js b/js/services/streamActionsService.js
deleted file mode 100644
index 9dfb468..0000000
--- a/js/services/streamActionsService.js
+++ /dev/null
@@ -1,59 +0,0 @@
-import { eventBus } from '../app/event-bus.js';
-import { storeActions, useStore } from '../app/store.js';
-
-/**
- * Toggles the polling state for all live streams.
- */
-export function toggleAllLiveStreamsPolling() {
-    const { streams } = useStore.getState();
-    const isAnyPolling = streams.some(
-        (s) => s.manifest?.type === 'dynamic' && s.isPolling
-    );
-    storeActions.setAllLiveStreamsPolling(!isAnyPolling);
-}
-
-/**
- * Dispatches an event to request fetching and parsing of a single segment.
- * @param {string} url The URL of the segment to load.
- */
-export function loadSegment(url) {
-    eventBus.dispatch('segment:fetch', { url });
-}
-
-/**
- * Reloads the manifest for a given stream, handling different protocols and states.
- * @param {import('../app/types.ts').Stream | null} stream The stream to reload.
- */
-export function reloadStream(stream) {
-    if (!stream) {
-        return;
-    }
-
-    // A stream loaded from a file will not have an originalUrl.
-    if (!stream.originalUrl) {
-        eventBus.dispatch('ui:show-status', {
-            message: 'Cannot reload a manifest from a local file.',
-            type: 'warn',
-            duration: 4000,
-        });
-        return;
-    }
-
-    const urlToReload = stream.activeMediaPlaylistUrl || stream.originalUrl;
-
-    eventBus.dispatch('ui:show-status', {
-        message: `Reloading manifest for ${stream.name}...`,
-        type: 'info',
-        duration: 2000,
-    });
-
-    if (stream.protocol === 'hls' && stream.activeMediaPlaylistUrl) {
-        eventBus.dispatch('hls:media-playlist-reload', {
-            streamId: stream.id,
-            url: urlToReload,
-        });
-    } else {
-        // This handles DASH and the HLS Master Playlist case
-        eventBus.dispatch('manifest:force-reload', { streamId: stream.id });
-    }
-}
diff --git a/js/services/streamService.js b/js/services/streamService.js
deleted file mode 100644
index 52d58ac..0000000
--- a/js/services/streamService.js
+++ /dev/null
@@ -1,247 +0,0 @@
-import { eventBus } from '../app/event-bus.js';
-import { useStore, storeActions } from '../app/store.js';
-import { isDebugMode } from '../shared/utils/env.js';
-import { debugLog } from '../shared/utils/debug.js';
-
-/** @typedef {import('../app/types.js').SerializedStream} SerializedStream */
-
-const analysisWorker = new Worker('/dist/worker.js', { type: 'module' });
-let analysisStartTime = 0;
-
-analysisWorker.onmessage = (event) => {
-    /** @type {{type: string, payload: any}} */
-    const { type, payload } = event.data;
-
-    switch (type) {
-        case 'analysis-complete': {
-            /** @type {SerializedStream[]} */
-            const results = payload.streams;
-            // Reconstruct Map objects from the serialized arrays
-            results.forEach((stream) => {
-                // @ts-ignore
-                stream.hlsVariantState = new Map(stream.hlsVariantState || []);
-                // @ts-ignore
-                stream.dashRepresentationState = new Map(
-                    stream.dashRepresentationState || []
-                );
-                if (stream.featureAnalysis) {
-                    // @ts-ignore
-                    stream.featureAnalysis.results = new Map(
-                        stream.featureAnalysis.results || []
-                    );
-                }
-                // @ts-ignore
-                stream.semanticData = new Map(stream.semanticData || []);
-                // @ts-ignore
-                stream.mediaPlaylists = new Map(stream.mediaPlaylists || []);
-            });
-            storeActions.completeAnalysis(
-                /** @type {import('../app/types.js').Stream[]} */ (
-                    /** @type {any} */ (results)
-                )
-            );
-            const tEndTotal = performance.now();
-            debugLog(
-                'StreamService',
-                `Total Analysis Pipeline (success): ${(
-                    tEndTotal - analysisStartTime
-                ).toFixed(2)}ms`
-            );
-            break;
-        }
-        case 'analysis-error': {
-            eventBus.dispatch('analysis:error', {
-                message: payload.message,
-                error: payload.error,
-            });
-            break;
-        }
-        case 'analysis-failed': {
-            eventBus.dispatch('analysis:failed');
-            const tEnd = performance.now();
-            debugLog(
-                'StreamService',
-                `Total Analysis Pipeline (failed): ${(
-                    tEnd - analysisStartTime
-                ).toFixed(2)}ms`
-            );
-            break;
-        }
-        case 'status-update': {
-            eventBus.dispatch('ui:show-status', {
-                message: payload.message,
-                type: 'info',
-                duration: 2000,
-            });
-            break;
-        }
-        case 'hls-media-playlist-fetched': {
-            const {
-                streamId,
-                variantUri,
-                manifest,
-                manifestString,
-                segments,
-                freshSegmentUrls,
-            } = payload;
-            const stream = useStore
-                .getState()
-                .streams.find((s) => s.id === streamId);
-            if (stream) {
-                // Update hlsVariantState for segment explorer
-                const newVariantState = new Map(stream.hlsVariantState);
-                const currentState = newVariantState.get(variantUri);
-                if (currentState) {
-                    newVariantState.set(variantUri, {
-                        ...currentState,
-                        segments,
-                        freshSegmentUrls: new Set(freshSegmentUrls),
-                        isLoading: false,
-                        error: null,
-                    });
-                }
-
-                // Update mediaPlaylists cache for interactive manifest view
-                const newMediaPlaylists = new Map(stream.mediaPlaylists);
-                newMediaPlaylists.set(variantUri, {
-                    manifest: manifest,
-                    rawManifest: manifestString,
-                    lastFetched: new Date(),
-                });
-
-                storeActions.updateStream(streamId, {
-                    hlsVariantState: newVariantState,
-                    mediaPlaylists: newMediaPlaylists,
-                });
-            }
-            break;
-        }
-        case 'hls-media-playlist-error': {
-            const { streamId, variantUri, error } = payload;
-            const stream = useStore
-                .getState()
-                .streams.find((s) => s.id === streamId);
-            if (stream) {
-                const newVariantState = new Map(stream.hlsVariantState);
-                const currentState = newVariantState.get(variantUri);
-                if (currentState) {
-                    newVariantState.set(variantUri, {
-                        ...currentState,
-                        isLoading: false,
-                        error,
-                    });
-                    storeActions.updateStream(streamId, {
-                        hlsVariantState: newVariantState,
-                    });
-                }
-            }
-            break;
-        }
-    }
-};
-
-async function analyzeStreams(inputs) {
-    analysisStartTime = performance.now();
-    debugLog('StreamService', 'Starting analysis pipeline...');
-    eventBus.dispatch('analysis:started');
-
-    const workerInputs = [];
-    for (const input of inputs) {
-        try {
-            eventBus.dispatch('ui:show-status', {
-                message: `Fetching ${input.url || input.file.name}...`,
-                type: 'info',
-                duration: 2000,
-            });
-            let manifestString = '';
-            if (input.url) {
-                const response = await fetch(input.url);
-                if (!response.ok) {
-                    eventBus.dispatch('analysis:error', {
-                        message: `HTTP Error ${response.status} for ${input.url}`,
-                    });
-                    continue;
-                }
-                manifestString = await response.text();
-            } else {
-                manifestString = await input.file.text();
-            }
-            workerInputs.push({
-                ...input,
-                manifestString,
-                isDebug: isDebugMode,
-            });
-        } catch (e) {
-            eventBus.dispatch('analysis:error', {
-                message: `Failed to fetch or read input: ${e.message}`,
-            });
-        }
-    }
-
-    if (workerInputs.length > 0) {
-        debugLog(
-            'StreamService',
-            `Pre-processing complete. Dispatching ${workerInputs.length} stream(s) to worker.`
-        );
-        analysisWorker.postMessage({
-            type: 'start-analysis',
-            payload: { inputs: workerInputs },
-        });
-    } else {
-        eventBus.dispatch('analysis:failed');
-    }
-}
-
-function fetchHlsMediaPlaylist({ streamId, variantUri }) {
-    const stream = useStore.getState().streams.find((s) => s.id === streamId);
-    if (!stream) return;
-
-    // Offload the fetch and parse to the worker
-    analysisWorker.postMessage({
-        type: 'fetch-hls-media-playlist',
-        payload: {
-            streamId,
-            variantUri,
-            hlsDefinedVariables: stream.hlsDefinedVariables,
-        },
-    });
-}
-
-/**
- * Handles activating a media playlist for the interactive view.
- * @param {object} payload
- * @param {number} payload.streamId
- * @param {string} payload.url
- */
-function activateHlsMediaPlaylist({ streamId, url }) {
-    if (url === 'master') {
-        storeActions.updateStream(streamId, { activeMediaPlaylistUrl: null });
-        return;
-    }
-
-    const stream = useStore.getState().streams.find((s) => s.id === streamId);
-    if (!stream) return;
-
-    if (!stream.mediaPlaylists.has(url)) {
-        // Not cached, so we need to fetch it. The 'hls:media-playlist-fetch-request'
-        // is now more generic and used by the explorer too.
-        eventBus.dispatch('hls:media-playlist-fetch-request', {
-            streamId,
-            variantUri: url,
-            isBackground: false, // This is a user action
-        });
-    }
-    // Set the active URL. If it wasn't cached, the view will re-render
-    // with a loading state until the fetch completes and updates the store again.
-    storeActions.updateStream(streamId, { activeMediaPlaylistUrl: url });
-}
-
-eventBus.subscribe('analysis:request', ({ inputs }) => analyzeStreams(inputs));
-eventBus.subscribe(
-    'hls:media-playlist-fetch-request',
-    ({ streamId, variantUri }) =>
-        fetchHlsMediaPlaylist({ streamId, variantUri })
-);
-eventBus.subscribe('hls:media-playlist-activate', (payload) =>
-    activateHlsMediaPlaylist(payload)
-);
diff --git a/js/shared/constants.js b/js/shared/constants.js
deleted file mode 100644
index ed6da29..0000000
--- a/js/shared/constants.js
+++ /dev/null
@@ -1,2 +0,0 @@
-export const tooltipTriggerClasses =
-    'cursor-help border-b border-dotted border-blue-500/40 transition-colors hover:bg-blue-500/15 hover:border-solid';
diff --git a/js/shared/utils/clipboard.js b/js/shared/utils/clipboard.js
deleted file mode 100644
index e890a77..0000000
--- a/js/shared/utils/clipboard.js
+++ /dev/null
@@ -1,32 +0,0 @@
-import { showToast } from '../../ui/components/toast.js';
-
-/**
- * Copies a given text string to the clipboard and shows a toast notification.
- * @param {string} text The text to copy.
- * @param {string} successMessage The message to show in the toast on success.
- */
-export function copyTextToClipboard(text, successMessage) {
-    if (!navigator.clipboard) {
-        showToast({
-            message: 'Clipboard API not available in this browser.',
-            type: 'fail',
-        });
-        return;
-    }
-
-    navigator.clipboard
-        .writeText(text)
-        .then(() => {
-            showToast({
-                message: successMessage,
-                type: 'pass',
-            });
-        })
-        .catch((err) => {
-            console.error('Failed to copy text:', err);
-            showToast({
-                message: 'Failed to copy to clipboard.',
-                type: 'fail',
-            });
-        });
-}
diff --git a/js/shared/utils/debug.js b/js/shared/utils/debug.js
deleted file mode 100644
index 288acbb..0000000
--- a/js/shared/utils/debug.js
+++ /dev/null
@@ -1,12 +0,0 @@
-const DEBUG_ENABLED = new URLSearchParams(window.location.search).has('debug');
-
-/**
- * Logs a message to the console only if debugging is enabled via `?debug=true` in the URL.
- * @param {string} component The name of the component/module logging the message.
- * @param {...any} args The arguments to log.
- */
-export function debugLog(component, ...args) {
-    if (DEBUG_ENABLED) {
-        console.log(`[DEBUG - ${component}]`, ...args);
-    }
-}
diff --git a/js/shared/utils/diff.js b/js/shared/utils/diff.js
deleted file mode 100644
index 191de54..0000000
--- a/js/shared/utils/diff.js
+++ /dev/null
@@ -1,36 +0,0 @@
-import { diffWords } from 'diff';
-import {
-    highlightDash,
-    highlightHls,
-} from '../../ui/shared/syntax-highlighter.js';
-
-/**
- * Diffs two pre-formatted manifest strings and returns an HTML string showing the new version,
- * with word-level additions highlighted and syntax highlighting applied.
- * @param {string} oldManifest The original manifest string.
- * @param {string} newManifest The new manifest string.
- * @param {'dash' | 'hls'} protocol The protocol of the manifest.
- * @returns {string} An HTML string representing the new state with highlights.
- */
-export function diffManifest(oldManifest, newManifest, protocol) {
-    const changes = diffWords(oldManifest, newManifest);
-    let html = '';
-
-    const highlightFn = protocol === 'dash' ? highlightDash : highlightHls;
-
-    changes.forEach((part) => {
-        if (part.removed) {
-            return; // Skip removed parts entirely
-        }
-
-        const highlightedValue = highlightFn(part.value);
-
-        if (part.added) {
-            html += `<span class="bg-emerald-500/40 text-green-50 rounded-sm font-medium">${highlightedValue}</span>`;
-        } else {
-            html += highlightedValue;
-        }
-    });
-
-    return html;
-}
diff --git a/js/shared/utils/drm.js b/js/shared/utils/drm.js
deleted file mode 100644
index e73747c..0000000
--- a/js/shared/utils/drm.js
+++ /dev/null
@@ -1,23 +0,0 @@
-/**
- * A map of well-known DRM system UUIDs (schemeIdUri) to their common, human-readable names.
- * The keys are lowercased for case-insensitive matching.
- */
-export const knownDrmSchemes = {
-    'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'Widevine',
-    'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'PlayReady',
-    'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'Adobe PrimeTime',
-    'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'ClearKey',
-    'urn:uuid:94ce86fb-07ff-4f43-adb8-93d2fa968ca2': 'FairPlay',
-    'urn:mpeg:dash:mp4protection:2011': 'MPEG Common Encryption (CENC)',
-};
-
-/**
- * Gets a human-readable name for a given DRM schemeIdUri.
- * @param {string | null} schemeIdUri The URI from the ContentProtection element.
- * @returns {string} The friendly name of the DRM system or a formatted version of the URI if unknown.
- */
-export function getDrmSystemName(schemeIdUri) {
-    if (!schemeIdUri) return 'Unknown Scheme';
-    const lowerCaseUri = schemeIdUri.toLowerCase();
-    return knownDrmSchemes[lowerCaseUri] || `Unknown (${schemeIdUri})`;
-}
diff --git a/js/shared/utils/env.js b/js/shared/utils/env.js
deleted file mode 100644
index ba1dea2..0000000
--- a/js/shared/utils/env.js
+++ /dev/null
@@ -1,8 +0,0 @@
-const urlParams = new URLSearchParams(window.location.search);
-
-/**
- * A flag indicating if the application is in debug mode.
- * Activated by adding `?debug=1` to the URL.
- * @type {boolean}
- */
-export const isDebugMode = urlParams.get('debug') === '1';
diff --git a/js/shared/utils/format.js b/js/shared/utils/format.js
deleted file mode 100644
index 477d9d8..0000000
--- a/js/shared/utils/format.js
+++ /dev/null
@@ -1,11 +0,0 @@
-/**
- * Formats a bitrate in bits per second into a human-readable string (kbps or Mbps).
- * @param {number | string} bps The bitrate in bits per second.
- * @returns {string} The formatted bitrate string or 'N/A'.
- */
-export const formatBitrate = (bps) => {
-    const numBps = typeof bps === 'string' ? parseFloat(bps) : bps;
-    if (!numBps || isNaN(numBps)) return 'N/A';
-    if (numBps >= 1000000) return `${(numBps / 1000000).toFixed(2)} Mbps`;
-    return `${(numBps / 1000).toFixed(0)} kbps`;
-};
diff --git a/js/shared/utils/stream-storage.js b/js/shared/utils/stream-storage.js
deleted file mode 100644
index a92dd3f..0000000
--- a/js/shared/utils/stream-storage.js
+++ /dev/null
@@ -1,166 +0,0 @@
-import { showToast } from '../../ui/components/toast.js';
-
-const HISTORY_KEY = 'stream-analyzer_history';
-const PRESETS_KEY = 'stream-analyzer_presets';
-const LAST_USED_KEY = 'stream-analyzer_last-used';
-const MAX_HISTORY_ITEMS = 10;
-const MAX_PRESETS = 50;
-
-// Re-use the worker from streamService to avoid creating multiple workers.
-const metadataWorker = new Worker('/dist/worker.js', { type: 'module' });
-let metadataRequestId = 0;
-const metadataCallbacks = new Map();
-
-metadataWorker.onmessage = (event) => {
-    const { type, payload } = event.data;
-    if (type === 'manifest-metadata-result') {
-        const { id, metadata, error } = payload;
-        if (metadataCallbacks.has(id)) {
-            const { resolve, reject } = metadataCallbacks.get(id);
-            if (error) {
-                reject(new Error(error));
-            } else {
-                resolve(metadata);
-            }
-            metadataCallbacks.delete(id);
-        }
-    }
-};
-
-/**
- * Reads a list of streams from localStorage.
- * @param {string} key The localStorage key.
- * @returns {Array<object>}
- */
-function getStreams(key) {
-    try {
-        return JSON.parse(localStorage.getItem(key) || '[]');
-    } catch (e) {
-        console.error(`Error reading from localStorage key "${key}":`, e);
-        return [];
-    }
-}
-
-/**
- * Writes a list of streams to localStorage.
- * @param {string} key The localStorage key.
- * @param {Array<object>} streams The array of streams to save.
- */
-function setStreams(key, streams) {
-    try {
-        localStorage.setItem(key, JSON.stringify(streams));
-    } catch (e) {
-        console.error(`Error writing to localStorage key "${key}":`, e);
-    }
-}
-
-export const getHistory = () => getStreams(HISTORY_KEY);
-export const getPresets = () => getStreams(PRESETS_KEY);
-export const getLastUsedStreams = () => getStreams(LAST_USED_KEY);
-export const saveLastUsedStreams = (streams) =>
-    setStreams(LAST_USED_KEY, streams);
-
-/**
- * Saves a stream object to the history.
- * @param {import('../../app/types.js').Stream} stream The stream object to save.
- */
-export function saveToHistory(stream) {
-    if (!stream || !stream.originalUrl) return;
-
-    const history = getHistory();
-    const presets = getPresets();
-    const isPreset = presets.some((p) => p.url === stream.originalUrl);
-    if (isPreset) return; // Don't add presets to history
-
-    const newHistory = history.filter(
-        (item) => item.url !== stream.originalUrl
-    );
-    newHistory.unshift({
-        name: stream.name,
-        url: stream.originalUrl,
-        protocol: stream.protocol,
-        type: stream.manifest?.type === 'dynamic' ? 'live' : 'vod',
-    });
-
-    if (newHistory.length > MAX_HISTORY_ITEMS) {
-        newHistory.length = MAX_HISTORY_ITEMS;
-    }
-    setStreams(HISTORY_KEY, newHistory);
-}
-
-/**
- * Saves a stream object as a preset.
- * @param {object} preset The preset object to save.
- * @param {string} preset.name
- * @param {string} preset.url
- * @param {'dash'|'hls'|'unknown'} preset.protocol
- * @param {'live'|'vod'} preset.type
- */
-export function savePreset({ name, url, protocol, type }) {
-    const presets = getPresets();
-    const newPresets = presets.filter((item) => item.url !== url);
-    newPresets.unshift({ name, url, protocol, type });
-
-    if (newPresets.length > MAX_PRESETS) {
-        newPresets.length = MAX_PRESETS;
-    }
-    setStreams(PRESETS_KEY, newPresets);
-    showToast({
-        message: `Preset "${name}" saved!`,
-        type: 'pass',
-    });
-}
-
-/**
- * Deletes an item from history by its URL.
- * @param {string} url The URL of the history item to delete.
- */
-export function deleteHistoryItem(url) {
-    const history = getHistory();
-    const newHistory = history.filter((item) => item.url !== url);
-    setStreams(HISTORY_KEY, newHistory);
-}
-
-/**
- * Deletes a preset by its URL.
- * @param {string} url The URL of the preset to delete.
- */
-export function deletePreset(url) {
-    const presets = getPresets();
-    const newPresets = presets.filter((item) => item.url !== url);
-    setStreams(PRESETS_KEY, newPresets);
-}
-
-/**
- * Fetches a manifest URL and asks the worker to determine its metadata.
- * @param {string} url The manifest URL.
- * @returns {Promise<{protocol: 'dash'|'hls', type: 'live'|'vod'}>}
- */
-export async function fetchStreamMetadata(url) {
-    showToast({ message: 'Fetching stream metadata...', type: 'info' });
-    try {
-        const response = await fetch(url);
-        if (!response.ok) {
-            throw new Error(`HTTP ${response.status} fetching manifest`);
-        }
-        const manifestString = await response.text();
-
-        return new Promise((resolve, reject) => {
-            const id = metadataRequestId++;
-            metadataCallbacks.set(id, { resolve, reject });
-            metadataWorker.postMessage({
-                type: 'get-manifest-metadata',
-                payload: { id, manifestString },
-            });
-            setTimeout(() => {
-                if (metadataCallbacks.has(id)) {
-                    reject(new Error('Metadata request timed out.'));
-                    metadataCallbacks.delete(id);
-                }
-            }, 5000); // 5-second timeout
-        });
-    } catch (e) {
-        showToast({ message: `Error: ${e.message}`, type: 'fail' });
-        throw e;
-    }
-}
diff --git a/js/shared/utils/time.js b/js/shared/utils/time.js
deleted file mode 100644
index 3390dc0..0000000
--- a/js/shared/utils/time.js
+++ /dev/null
@@ -1,16 +0,0 @@
-/**
- * Parses an ISO 8601 duration string (e.g., "PT2.00S") into seconds.
- * @param {string | null} durationStr The duration string.
- * @returns {number | null} The duration in seconds, or null if invalid.
- */
-export const parseDuration = (durationStr) => {
-    if (!durationStr) return null;
-    const match = durationStr.match(
-        /PT(?:(\d+(?:\.\d+)?)H)?(?:(\d+(?:\.\d+)?)M)?(?:(\d+(?:\.\d+)?)S)?/
-    );
-    if (!match) return null;
-    const hours = parseFloat(match[1] || '0');
-    const minutes = parseFloat(match[2] || '0');
-    const seconds = parseFloat(match[3] || '0');
-    return hours * 3600 + minutes * 60 + seconds;
-};
diff --git a/js/types/globals.d.ts b/js/types/globals.d.ts
deleted file mode 100644
index 89ac2e9..0000000
--- a/js/types/globals.d.ts
+++ /dev/null
@@ -1,21 +0,0 @@
-// js/types/globals.d.ts
-
-// This file is for declaring types for global variables and properties
-// that are not part of the standard library or imported modules.
-// This is common when using scripts loaded from a CDN.
-
-interface Window {
-    // Functions defined in index.html for on-demand script loading
-    loadGoogleAnalytics: () => void;
-    loadSentry: () => void;
-    loadClarity: () => void;
-    gaLoaded?: boolean;
-    sentryLoaded?: boolean;
-    clarityLoaded?: boolean;
-
-    // The CookieConsent library object
-    CookieConsent: any;
-
-    // Google Analytics dataLayer
-    dataLayer: any[];
-}
diff --git a/js/ui/components/hex-view.js b/js/ui/components/hex-view.js
deleted file mode 100644
index 1e5e684..0000000
--- a/js/ui/components/hex-view.js
+++ /dev/null
@@ -1,238 +0,0 @@
-import { html } from 'lit-html';
-import { unsafeHTML } from 'lit-html/directives/unsafe-html.js';
-
-/**
- * Renders the full grid content as three separate HTML strings for each column.
- * @param {Uint8Array} view - The byte array view.
- * @param {number} start - The starting byte offset to render.
- * @param {number} end - The ending byte offset to render.
- * @param {Map<number, object>} byteMap - The pre-built map of byte properties.
- * @param {object} allTooltips - The aggregated tooltip data for all formats.
- * @param {object} inspectorState - The current state of the inspector (hovered/selected items).
- * @returns {{offsets: string, hexes: string, asciis: string}}
- */
-function renderHexGridContent(
-    view,
-    start,
-    end,
-    byteMap,
-    allTooltips,
-    inspectorState
-) {
-    let offsetsHtml = '';
-    let hexHtml = '';
-    let asciiHtml = '';
-
-    const { itemForDisplay, fieldForDisplay } = inspectorState;
-
-    const rowCount = Math.ceil((end - start) / 16);
-
-    for (let row = 0; row < rowCount; row++) {
-        const rowStartOffset = start + row * 16;
-        offsetsHtml += `<div class="text-gray-500 select-none text-right">${rowStartOffset
-            .toString(16)
-            .padStart(8, '0')
-            .toUpperCase()}</div>`;
-
-        let hexRow = '';
-        let asciiRow = '';
-
-        for (let col = 0; col < 16; col++) {
-            const byteOffset = rowStartOffset + col;
-            if (byteOffset < end) {
-                const byte = view[byteOffset];
-                const mapEntry = byteMap.get(byteOffset);
-                const prevMapEntry = byteMap.get(byteOffset - 1);
-
-                let tooltipText = '';
-                let isoRefText = '';
-                let fieldBoundaryClass = '';
-                let highlightClasses = '';
-
-                if (mapEntry) {
-                    const item = mapEntry.box || mapEntry.packet;
-                    const fieldName = mapEntry.fieldName;
-
-                    // --- Dynamic Highlighting Logic ---
-                    if (
-                        itemForDisplay &&
-                        item &&
-                        item.offset === itemForDisplay.offset
-                    ) {
-                        highlightClasses += ' is-box-hover-highlighted';
-                        if (fieldForDisplay && fieldName === fieldForDisplay) {
-                            highlightClasses += ' is-field-hover-highlighted';
-                        }
-                    }
-                    if (
-                        itemForDisplay?.isChunk &&
-                        byteOffset >= itemForDisplay.offset &&
-                        byteOffset < itemForDisplay.offset + itemForDisplay.size
-                    ) {
-                        highlightClasses += ' is-box-hover-highlighted';
-                    }
-
-                    // --- Tooltip Logic ---
-                    const boxType = item?.type;
-                    let primaryTooltip = fieldName;
-                    let primaryIsoRef = '';
-
-                    if (boxType) {
-                        const boxInfo = allTooltips[boxType];
-                        const fieldInfo =
-                            allTooltips[`${boxType}@${fieldName}`];
-
-                        if (fieldInfo && fieldInfo.text) {
-                            primaryTooltip = fieldInfo.text;
-                            primaryIsoRef = fieldInfo.ref || '';
-                        } else if (
-                            boxInfo &&
-                            boxInfo.text &&
-                            (fieldName === 'Box Header' ||
-                                fieldName === 'TS Header')
-                        ) {
-                            primaryTooltip = boxInfo.text;
-                            primaryIsoRef = boxInfo.ref || '';
-                        }
-                    }
-                    tooltipText = primaryTooltip;
-                    isoRefText = primaryIsoRef;
-
-                    // --- Field Boundary Logic ---
-                    if (
-                        prevMapEntry &&
-                        mapEntry.fieldName !== prevMapEntry.fieldName &&
-                        (mapEntry.box?.offset === prevMapEntry.box?.offset ||
-                            mapEntry.packet?.offset ===
-                                prevMapEntry.packet?.offset) &&
-                        byteOffset % 16 !== 0
-                    ) {
-                        fieldBoundaryClass = 'border-l-2 border-white/10';
-                    }
-                }
-
-                const bgColor = mapEntry?.color?.bg || '';
-                const styleAttr = mapEntry?.color?.style || '';
-                const hexByte = byte
-                    .toString(16)
-                    .padStart(2, '0')
-                    .toUpperCase();
-                const commonAttrs = `data-byte-offset="${byteOffset}" data-box-offset="${mapEntry?.box?.offset}" data-tooltip="${tooltipText}" data-iso="${isoRefText}"`;
-                hexRow += `<span ${commonAttrs} class="hex-byte relative ${bgColor} ${fieldBoundaryClass} ${highlightClasses}" style="${styleAttr}">${hexByte}</span>`;
-
-                const asciiChar =
-                    byte >= 32 && byte <= 126
-                        ? String.fromCharCode(byte).replace('<', '&lt;')
-                        : '.';
-                asciiRow += `<span ${commonAttrs} class="ascii-char relative ${bgColor} ${fieldBoundaryClass} ${highlightClasses}" style="${styleAttr}">${asciiChar}</span>`;
-            } else {
-                hexRow += '<span></span>';
-                asciiRow += '<span></span>';
-            }
-        }
-        hexHtml += `<div class="hex-row">${hexRow}</div>`;
-        asciiHtml += `<div class="ascii-row">${asciiRow}</div>`;
-    }
-    return { offsets: offsetsHtml, hexes: hexHtml, asciis: asciiHtml };
-}
-
-export const hexViewTemplate = (
-    buffer,
-    byteMap,
-    currentPage,
-    bytesPerPage,
-    onPageChange,
-    allTooltips,
-    inspectorState
-) => {
-    const totalPages = Math.ceil(buffer.byteLength / bytesPerPage);
-    const startOffset = (currentPage - 1) * bytesPerPage;
-    const view = new Uint8Array(buffer);
-    const endByte = Math.min(startOffset + bytesPerPage, view.length);
-
-    const { offsets, hexes, asciis } = renderHexGridContent(
-        view,
-        startOffset,
-        endByte,
-        byteMap,
-        allTooltips,
-        inspectorState
-    );
-
-    return html`
-        <style>
-            .hex-row,
-            .ascii-row {
-                display: grid;
-                grid-template-columns: repeat(16, minmax(0, 1fr));
-            }
-            .hex-byte,
-            .ascii-char {
-                text-align: center;
-                padding: 0 0.125rem;
-            }
-        </style>
-        <div
-            class="bg-slate-800 rounded-lg font-mono text-sm leading-relaxed flex flex-col h-full"
-        >
-            <div class="flex-grow overflow-y-auto p-4">
-                <div
-                    class="grid grid-cols-[auto_1fr_auto] gap-x-4 sticky top-0 bg-slate-800 pb-2 mb-2 border-b border-gray-600 z-20"
-                >
-                    <div class="text-gray-400 font-semibold text-right">
-                        Offset
-                    </div>
-                    <div class="text-gray-400 font-semibold text-center">
-                        Hexadecimal
-                    </div>
-                    <div class="text-gray-400 font-semibold text-center">
-                        ASCII
-                    </div>
-                </div>
-                <div
-                    id="hex-grid-content"
-                    class="grid grid-cols-[auto_1fr_auto] gap-x-4"
-                >
-                    <div class="pr-4 leading-loose">${unsafeHTML(offsets)}</div>
-                    <div class="hex-content-grid leading-loose">
-                        ${unsafeHTML(hexes)}
-                    </div>
-                    <div class="text-cyan-400 ascii-content-grid leading-loose">
-                        ${unsafeHTML(asciis)}
-                    </div>
-                </div>
-            </div>
-
-            ${totalPages > 1
-                ? html`
-                      <div
-                          class="flex-shrink-0 text-center text-sm text-gray-500 py-2 border-t border-gray-700"
-                      >
-                          Showing bytes ${startOffset} -
-                          ${Math.min(
-                              startOffset + bytesPerPage - 1,
-                              buffer.byteLength - 1
-                          )}
-                          of ${buffer.byteLength}
-                          (${(buffer.byteLength / 1024).toFixed(2)} KB)
-                          <button
-                              @click=${() => onPageChange(-1)}
-                              ?disabled=${currentPage === 1}
-                              class="px-2 py-1 rounded bg-gray-600 hover:bg-gray-500 disabled:opacity-50 mx-1"
-                          >
-                              &lt;
-                          </button>
-                          Page ${currentPage} of ${totalPages}
-                          <button
-                              @click=${() => onPageChange(1)}
-                              ?disabled=${currentPage === totalPages}
-                              class="px-2 py-1 rounded bg-gray-600 hover:bg-gray-500 disabled:opacity-50 mx-1"
-                          >
-                              &gt;
-                          </button>
-                      </div>
-                  `
-                : ''}
-        </div>
-    `;
-};
diff --git a/js/ui/components/loader.js b/js/ui/components/loader.js
deleted file mode 100644
index fa05a99..0000000
--- a/js/ui/components/loader.js
+++ /dev/null
@@ -1,58 +0,0 @@
-import { eventBus } from '../../app/event-bus.js';
-
-let dom;
-
-/**
- * Displays the global loader with a specific message.
- * @param {string} [message='Processing...'] The message to display under the loader.
- */
-export function showLoader(message = 'Processing...') {
-    if (!dom || !dom.globalLoader || !dom.loaderMessage) return;
-    dom.loaderMessage.textContent = message;
-    dom.globalLoader.classList.remove('hidden');
-    dom.globalLoader.classList.add('flex');
-}
-
-/**
- * Hides the global loader.
- */
-export function hideLoader() {
-    if (!dom || !dom.globalLoader) return;
-    dom.globalLoader.classList.add('hidden');
-    dom.globalLoader.classList.remove('flex');
-}
-
-/**
- * Initializes the loader component, setting up event listeners to automate its visibility.
- * @param {object} domContext The application's DOM context.
- */
-export function initializeLoader(domContext) {
-    dom = domContext;
-
-    // --- Primary Analysis Flow ---
-    eventBus.subscribe('analysis:started', () =>
-        showLoader('Analyzing streams...')
-    );
-    eventBus.subscribe('analysis:complete', hideLoader);
-    eventBus.subscribe('analysis:failed', hideLoader);
-    eventBus.subscribe('analysis:error', hideLoader);
-
-    // --- Segment Loading ---
-    eventBus.subscribe('segment:pending', () =>
-        showLoader('Loading segment...')
-    );
-    eventBus.subscribe('segment:loaded', hideLoader);
-
-    // --- HLS Media Playlist Loading ---
-    eventBus.subscribe(
-        'hls:media-playlist-fetch-request',
-        ({ isBackground }) => {
-            // Only show loader for user-initiated (foreground) fetches.
-            if (!isBackground) {
-                showLoader('Fetching media playlist...');
-            }
-        }
-    );
-    eventBus.subscribe('hls-media-playlist-fetched', hideLoader);
-    eventBus.subscribe('hls-media-playlist-error', hideLoader);
-}
diff --git a/js/ui/components/modal.js b/js/ui/components/modal.js
deleted file mode 100644
index af5162d..0000000
--- a/js/ui/components/modal.js
+++ /dev/null
@@ -1,89 +0,0 @@
-import { html, render } from 'lit-html';
-import { useStore } from '../../app/store.js';
-import { closeModal } from '../../services/modalService.js';
-import { getSegmentAnalysisTemplate } from '../views/segment-analysis/index.js';
-import { scte35DetailsTemplate } from '../shared/scte35-details.js';
-
-let dom;
-
-/**
- * Generates the correct lit-html template based on the modal content object.
- * @param {{ type: string; data: any; } | null} modalContent
- * @returns {import('lit-html').TemplateResult}
- */
-function getContentTemplate(modalContent) {
-    if (!modalContent) {
-        return html``;
-    }
-
-    switch (modalContent.type) {
-        case 'segmentAnalysis':
-            return getSegmentAnalysisTemplate(
-                modalContent.data.parsedData,
-                modalContent.data.parsedDataB
-            );
-        case 'scte35':
-            return scte35DetailsTemplate(modalContent.data.scte35);
-        default:
-            return html`<p class="text-red-400">
-                Unknown modal content type: ${modalContent.type}
-            </p>`;
-    }
-}
-
-/**
- * Renders the modal based on the current state from the store.
- */
-function renderModal() {
-    if (!dom) return;
-
-    const { modalState } = useStore.getState();
-    const modalPanel = dom.segmentModal.querySelector('div');
-
-    if (modalState.isModalOpen) {
-        dom.modalTitle.textContent = modalState.modalTitle;
-        dom.modalSegmentUrl.textContent = modalState.modalUrl;
-
-        // The rendering logic is now inside the UI component.
-        const template = getContentTemplate(modalState.modalContent);
-        render(template, dom.modalContentArea);
-
-        dom.segmentModal.classList.remove('opacity-0', 'invisible');
-        dom.segmentModal.classList.add('opacity-100', 'visible');
-        modalPanel.classList.remove('scale-95');
-        modalPanel.classList.add('scale-100');
-    } else {
-        dom.segmentModal.classList.add('opacity-0', 'invisible');
-        dom.segmentModal.classList.remove('opacity-100', 'visible');
-        modalPanel.classList.add('scale-95');
-        modalPanel.classList.remove('scale-100');
-    }
-}
-
-/**
- * Initializes the modal component, setting up event listeners and subscribing to state changes.
- * @param {object} domContext The application's DOM context.
- */
-export function initializeModalComponent(domContext) {
-    dom = domContext;
-
-    // Set up event listeners once
-    dom.closeModalBtn.addEventListener('click', closeModal);
-    dom.segmentModal.addEventListener('click', (e) => {
-        // Close modal if the backdrop is clicked, but not the panel itself
-        if (e.target === dom.segmentModal) {
-            closeModal();
-        }
-    });
-
-    // Subscribe to the store. The listener will receive the new and old state.
-    useStore.subscribe((state, prevState) => {
-        // Only re-render if the modal state slice has changed.
-        if (state.modalState !== prevState.modalState) {
-            renderModal();
-        }
-    });
-
-    // Manually call render once at initialization to sync with initial state.
-    renderModal();
-}
diff --git a/js/ui/components/segment-row.js b/js/ui/components/segment-row.js
deleted file mode 100644
index b947681..0000000
--- a/js/ui/components/segment-row.js
+++ /dev/null
@@ -1,209 +0,0 @@
-import { html } from 'lit-html';
-import {
-    useStore,
-    storeActions,
-    useSegmentCacheStore,
-} from '../../app/store.js';
-import { eventBus } from '../../app/event-bus.js';
-import { loadSegment } from '../../services/streamActionsService.js';
-
-function handleSegmentCheck(e) {
-    const checkbox = /** @type {HTMLInputElement} */ (e.target);
-    const url = checkbox.value;
-    if (checkbox.checked) {
-        if (useStore.getState().segmentsForCompare.length >= 2) {
-            checkbox.checked = false;
-            return;
-        }
-        storeActions.addSegmentToCompare(url);
-    } else {
-        storeActions.removeSegmentFromCompare(url);
-    }
-}
-
-const getLoadStatusIcon = (cacheEntry) => {
-    if (!cacheEntry)
-        return html`<div
-            class="flex-shrink-0 w-2.5 h-2.5 rounded-sm border border-gray-500 bg-gray-800"
-            title="Status: Not Loaded"
-        ></div>`;
-    if (cacheEntry.status === -1)
-        return html`<div
-            class="flex-shrink-0 w-2.5 h-2.5 rounded-full bg-gray-500 animate-pulse"
-            title="Status: Pending"
-        ></div>`;
-    if (cacheEntry.status !== 200) {
-        const statusText =
-            cacheEntry.status === 0
-                ? 'Network Error'
-                : `HTTP ${cacheEntry.status}`;
-        return html`<div
-            class="flex-shrink-0 w-2.5 h-2.5 rounded-full bg-red-500"
-            title="Status: ${statusText}"
-        ></div>`;
-    }
-    return html`<div
-        class="flex-shrink-0 w-2.5 h-2.5 rounded-full bg-green-500"
-        title="Status: Loaded OK"
-    ></div>`;
-};
-
-const getFreshnessIcon = (isFresh) => {
-    if (isFresh === null) return ''; // Not applicable for DASH
-    if (isFresh)
-        return html`<div
-            class="flex-shrink-0 w-2.5 h-2.5 rounded-full bg-cyan-400"
-            title="Fresh: Segment is in the latest playlist"
-        ></div>`;
-    return html`<div
-        class="flex-shrink-0 w-2.5 h-2.5 rounded-sm bg-gray-600"
-        title="Stale: Segment is no longer in the latest playlist"
-    ></div>`;
-};
-
-const getActions = (cacheEntry, seg, isFresh) => {
-    if (seg.gap) {
-        return html`<span class="text-xs text-gray-500 italic font-semibold"
-            >GAP Segment</span
-        >`;
-    }
-
-    const analyzeHandler = (e) => {
-        const url = /** @type {HTMLElement} */ (e.currentTarget).dataset.url;
-        eventBus.dispatch('ui:request-segment-analysis', { url });
-    };
-    const viewRawHandler = (e) => {
-        const url = /** @type {HTMLElement} */ (e.currentTarget).dataset.url;
-        storeActions.setActiveSegmentUrl(url);
-        storeActions.setActiveTab('interactive-segment');
-    };
-    const loadHandler = () => {
-        loadSegment(seg.resolvedUrl);
-    };
-
-    if (!cacheEntry) {
-        return html`<button
-            @click=${loadHandler}
-            class="text-xs bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded"
-        >
-            Load
-        </button>`;
-    }
-    if (cacheEntry.status === -1) {
-        return html`<button
-            disabled
-            class="text-xs bg-gray-600 px-2 py-1 rounded opacity-50 cursor-wait"
-        >
-            Loading...
-        </button>`;
-    }
-    if (cacheEntry.status !== 200) {
-        // For HLS, stale segments shouldn't be reloaded. For DASH, isFresh is null.
-        return isFresh !== false
-            ? html`<button
-                  @click=${loadHandler}
-                  class="text-xs bg-yellow-600 hover:bg-yellow-700 px-2 py-1 rounded"
-              >
-                  Reload
-              </button>`
-            : html`<span class="text-xs text-gray-500 italic"
-                  >Stale Error</span
-              >`;
-    }
-    return html`
-        <button
-            class="text-xs bg-gray-600 hover:bg-gray-700 px-2 py-1 rounded"
-            data-url="${seg.resolvedUrl}"
-            @click=${viewRawHandler}
-        >
-            View Raw
-        </button>
-        <button
-            class="text-xs bg-purple-600 hover:bg-purple-700 px-2 py-1 rounded"
-            data-url="${seg.resolvedUrl}"
-            @click=${analyzeHandler}
-        >
-            Analyze
-        </button>
-    `;
-};
-
-/**
- * Renders a single row in a segment explorer table.
- * @param {object} seg - The segment data object.
- * @param {boolean | null} isFresh - Whether the segment is in the latest playlist (HLS only).
- * @returns {import('lit-html').TemplateResult}
- */
-export const segmentRowTemplate = (seg, isFresh) => {
-    const { segmentsForCompare } = useStore.getState();
-    const { get: getFromCache } = useSegmentCacheStore.getState();
-
-    const cacheEntry = getFromCache(seg.resolvedUrl);
-    const isChecked = segmentsForCompare.includes(seg.resolvedUrl);
-
-    let stateClasses = 'hover:bg-gray-800/80 transition-colors duration-200';
-    if (seg.gap) {
-        stateClasses = 'bg-gray-800/50 text-gray-600 italic';
-    }
-
-    const timingContent =
-        seg.type === 'Media' && !seg.gap
-            ? html`${(seg.time / seg.timescale).toFixed(2)}s
-              (+${(seg.duration / seg.timescale).toFixed(2)}s)`
-            : 'N/A';
-
-    // Add data attributes for live highlighting if the segment has UTC times
-    const startTimeAttr = seg.startTimeUTC
-        ? `data-start-time=${seg.startTimeUTC}`
-        : '';
-    const endTimeAttr = seg.endTimeUTC ? `data-end-time=${seg.endTimeUTC}` : '';
-
-    return html`
-        <tr
-            class="segment-row ${stateClasses}"
-            data-url="${seg.resolvedUrl}"
-            ${startTimeAttr}
-            ${endTimeAttr}
-        >
-            <td class="px-3 py-1.5">
-                <input
-                    type="checkbox"
-                    class="bg-gray-700 border-gray-500 rounded focus:ring-blue-500 disabled:opacity-50"
-                    .value=${seg.resolvedUrl}
-                    ?checked=${isChecked}
-                    ?disabled=${seg.gap}
-                    @change=${handleSegmentCheck}
-                />
-            </td>
-            <td class="px-3 py-1.5">
-                <div class="flex items-center space-x-2">
-                    ${seg.gap ? '' : getLoadStatusIcon(cacheEntry)}
-                    ${getFreshnessIcon(isFresh)}
-                    <div>
-                        <span>${seg.type === 'Init' ? 'Init' : 'Media'}</span
-                        ><span class="block text-xs text-gray-500"
-                            >#${seg.number}</span
-                        >
-                    </div>
-                </div>
-            </td>
-            <td class="px-3 py-1.5">
-                <span class="text-xs font-mono">${timingContent}</span>
-            </td>
-            <td class="px-3 py-1.5">
-                <div class="flex justify-between items-center">
-                    <span
-                        class="font-mono ${seg.gap
-                            ? ''
-                            : 'text-cyan-400'} truncate"
-                        title="${seg.resolvedUrl}"
-                        >${seg.template || 'GAP'}</span
-                    >
-                    <div class="flex items-center space-x-2 flex-shrink-0 ml-4">
-                        ${getActions(cacheEntry, seg, isFresh)}
-                    </div>
-                </div>
-            </td>
-        </tr>
-    `;
-};
diff --git a/js/ui/components/stream-inputs.js b/js/ui/components/stream-inputs.js
deleted file mode 100644
index 494f35d..0000000
--- a/js/ui/components/stream-inputs.js
+++ /dev/null
@@ -1,400 +0,0 @@
-import { html, render } from 'lit-html';
-import { useStore, storeActions } from '../../app/store.js';
-import { exampleStreams } from '../../data/example-streams.js';
-import {
-    getHistory,
-    getPresets,
-    savePreset,
-    deleteHistoryItem,
-    deletePreset,
-    fetchStreamMetadata,
-} from '../../shared/utils/stream-storage.js';
-import { showToast } from './toast.js';
-
-const getBadge = (text, colorClasses) => {
-    if (!text) return '';
-    return html`<span
-        class="text-xs font-semibold px-2 py-0.5 rounded-full ${colorClasses}"
-        >${text.toUpperCase()}</span
-    >`;
-};
-
-const handleDropdownItemClick = (e) => {
-    const item = /** @type {HTMLElement} */ (e.currentTarget);
-    const group = item.closest('.stream-input-group');
-    const urlInput = /** @type {HTMLInputElement} */ (
-        group.querySelector('.input-url')
-    );
-    if (item.dataset.url) {
-        urlInput.value = item.dataset.url;
-        /** @type {HTMLInputElement} */ (
-            group.querySelector('.input-name')
-        ).value = item.dataset.name || '';
-        /** @type {HTMLInputElement} */ (
-            group.querySelector('.input-file')
-        ).value = '';
-        // Manually trigger the input event to update the save button state
-        urlInput.dispatchEvent(new Event('input', { bubbles: true }));
-    }
-    // Hide dropdown
-    const dropdown = group.querySelector('.preset-dropdown');
-    if (dropdown) dropdown.classList.add('hidden');
-};
-
-const renderStreamListItem = (stream, isPreset, presets) => {
-    const protocolBadge =
-        stream.protocol === 'dash'
-            ? getBadge('DASH', 'bg-blue-800 text-blue-200')
-            : stream.protocol === 'hls'
-              ? getBadge('HLS', 'bg-purple-800 text-purple-200')
-              : '';
-    const typeBadge =
-        stream.type === 'live'
-            ? getBadge('LIVE', 'bg-red-800 text-red-200')
-            : stream.type === 'vod'
-              ? getBadge('VOD', 'bg-green-800 text-green-200')
-              : '';
-
-    const handleDelete = (e) => {
-        e.preventDefault();
-        e.stopPropagation();
-        if (confirm(`Are you sure you want to delete "${stream.name}"?`)) {
-            if (isPreset) {
-                deletePreset(stream.url);
-            } else {
-                deleteHistoryItem(stream.url);
-            }
-            // Re-render via store change is not ideal here as it re-renders EVERYTHING.
-            // For this specific, non-state-critical dropdown, a local re-render is acceptable.
-            const group = e.target.closest('.stream-input-group');
-            if (group) {
-                const newHistory = getHistory();
-                const newPresets = getPresets();
-                const id = parseInt(group.dataset.id, 10);
-                const isFirst =
-                    useStore
-                        .getState()
-                        .streamInputIds.indexOf(
-                            parseInt(group.dataset.id, 10)
-                        ) === 0;
-                const newTemplate = streamInputTemplate(
-                    id,
-                    isFirst,
-                    newHistory,
-                    newPresets
-                );
-                const tempDiv = document.createElement('div');
-                document.body.appendChild(tempDiv);
-                render(newTemplate, tempDiv);
-                const newGroup = tempDiv.querySelector('.stream-input-group');
-                group.parentElement.replaceChild(newGroup, group);
-                document.body.removeChild(tempDiv);
-            }
-        }
-    };
-
-    return html`<li
-        class="group px-3 py-2 hover:bg-gray-700 cursor-pointer flex justify-between items-center"
-        data-url="${stream.url}"
-        data-name="${stream.name}"
-        @click=${handleDropdownItemClick}
-    >
-        <div class="flex flex-col min-w-0">
-            <span
-                class="font-semibold text-gray-200 truncate"
-                title="${stream.name}"
-                >${stream.name}</span
-            >
-            <span
-                class="text-xs text-gray-400 font-mono truncate"
-                title="${stream.url}"
-                >${stream.url}</span
-            >
-        </div>
-        <div class="flex-shrink-0 flex items-center gap-2 ml-4">
-            ${protocolBadge} ${typeBadge}
-            <button
-                @click=${handleDelete}
-                class="w-6 h-6 rounded-full flex items-center justify-center text-gray-500 hover:bg-red-800 hover:text-white opacity-0 group-hover:opacity-100 transition-opacity"
-                title="Delete item"
-            >
-                <span class="text-xl">&times;</span>
-            </button>
-        </div>
-    </li>`;
-};
-
-const renderDropdownSection = (title, items, isPreset = false, presets) => {
-    if (!items || items.length === 0) return '';
-    return html`<div>
-        <h4
-            class="font-bold text-gray-200 text-xs tracking-wider uppercase px-3 pt-3 pb-2 sticky top-0 bg-gray-900 z-10 border-b border-gray-800/50"
-        >
-            ${title}
-        </h4>
-        <ul class="divide-y divide-gray-700/50">
-            ${items.map((item) =>
-                renderStreamListItem(item, isPreset, presets)
-            )}
-        </ul>
-    </div>`;
-};
-
-const renderExampleCategory = (title, items, presets) => {
-    if (!items || items.length === 0) return '';
-    return html`<div>
-        <h5 class="font-medium text-gray-400 px-3 pt-2 pb-1">${title}</h5>
-        <ul class="divide-y divide-gray-700/50">
-            ${items.map((item) => renderStreamListItem(item, false, presets))}
-        </ul>
-    </div>`;
-};
-
-const handleFileChange = (e) => {
-    const fileInput = /** @type {HTMLInputElement} */ (e.target);
-    const group = fileInput.closest('.stream-input-group');
-    if (fileInput.files[0]) {
-        /** @type {HTMLInputElement} */ (
-            group.querySelector('.input-url')
-        ).value = '';
-        const dropdown = group.querySelector('.preset-dropdown');
-        if (dropdown) dropdown.classList.add('hidden');
-    }
-};
-
-const handleSavePreset = async (e) => {
-    const button = /** @type {HTMLButtonElement} */ (e.target);
-    const group = button.closest('.stream-input-group');
-    const nameInput = /** @type {HTMLInputElement} */ (
-        group.querySelector('.input-name')
-    );
-    const urlInput = /** @type {HTMLInputElement} */ (
-        group.querySelector('.input-url')
-    );
-
-    const name = nameInput.value.trim();
-    const url = urlInput.value.trim();
-
-    if (!name || !url) {
-        showToast({
-            message:
-                'Please provide both a URL and a custom name to save a preset.',
-            type: 'warn',
-        });
-        return;
-    }
-
-    button.disabled = true;
-    button.textContent = 'Saving...';
-
-    try {
-        const { protocol, type } = await fetchStreamMetadata(url);
-        savePreset({ name, url, protocol, type });
-        nameInput.value = '';
-        button.textContent = 'Saved!';
-    } catch (err) {
-        console.error('Failed to save preset:', err);
-        button.textContent = 'Save as Preset';
-        button.disabled = false;
-    }
-};
-
-const streamInputTemplate = (streamId, isFirstStream, history, presets) => {
-    const { streamInputIds } = useStore.getState();
-    const presetUrls = new Set(presets.map((p) => p.url));
-    const groupedExamples = exampleStreams.reduce(
-        (acc, stream) => {
-            const { protocol, type } = stream;
-            if (!acc[protocol]) acc[protocol] = {};
-            if (!acc[protocol][type]) acc[protocol][type] = [];
-            acc[protocol][type].push(stream);
-            return acc;
-        },
-        { dash: {}, hls: {} }
-    );
-
-    const removeHandler = (e) => {
-        const groupEl = /** @type {HTMLElement} */ (e.target).closest(
-            '.stream-input-group'
-        );
-        if (groupEl) {
-            const idToRemove = parseInt(
-                /** @type {HTMLElement} */ (groupEl).dataset.id
-            );
-            storeActions.removeStreamInputId(idToRemove);
-        }
-    };
-
-    const handleUrlInput = (e) => {
-        const input = /** @type {HTMLInputElement} */ (e.target);
-        const group = input.closest('.stream-input-group');
-        const saveButton = /** @type {HTMLButtonElement} */ (
-            group.querySelector('.save-preset-btn')
-        );
-        const url = input.value.trim();
-        saveButton.disabled = presetUrls.has(url) || url === '';
-        saveButton.textContent = 'Save as Preset';
-    };
-
-    const toggleDropdown = (groupEl, show) => {
-        const dropdown = groupEl.querySelector('.preset-dropdown');
-        if (dropdown) {
-            dropdown.classList.toggle('hidden', !show);
-        }
-    };
-
-    const handleFocusIn = (e) => {
-        toggleDropdown(
-            /** @type {HTMLElement} */ (e.currentTarget).closest(
-                '.stream-input-group'
-            ),
-            true
-        );
-    };
-    let hideTimeout;
-    const handleFocusOut = (e) => {
-        const groupEl = /** @type {HTMLElement} */ (e.currentTarget).closest(
-            '.stream-input-group'
-        );
-        hideTimeout = setTimeout(() => {
-            toggleDropdown(groupEl, false);
-        }, 150);
-    };
-    const handleDropdownFocusIn = () => clearTimeout(hideTimeout);
-
-    return html`<div
-        data-testid="stream-input-group"
-        class="stream-input-group ${!isFirstStream
-            ? 'border-t border-gray-700 pt-6 mt-6'
-            : ''}"
-        data-id="${streamId}"
-    >
-        <div class="flex items-center justify-between mb-3">
-            <h3 class="text-lg font-semibold text-gray-300">
-                Stream ${streamInputIds.indexOf(streamId) + 1}
-            </h3>
-            ${!isFirstStream
-                ? html`<button
-                      class="remove-stream-btn text-red-400 hover:text-red-600 font-bold text-sm"
-                      @click=${removeHandler}
-                  >
-                      &times; Remove
-                  </button>`
-                : ''}
-        </div>
-        <div class="space-y-4">
-            <div
-                class="relative"
-                @focusin=${handleFocusIn}
-                @focusout=${handleFocusOut}
-            >
-                <div class="flex flex-col md:flex-row items-center gap-4">
-                    <input
-                        type="url"
-                        id="url-${streamId}"
-                        class="input-url w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-blue-500"
-                        placeholder="Enter Manifest URL or click to see presets..."
-                        .value=${isFirstStream && history.length > 0
-                            ? history[0].url
-                            : ''}
-                        @input=${handleUrlInput}
-                        autocomplete="off"
-                    />
-                    <label
-                        for="file-${streamId}"
-                        class="block w-full md:w-auto cursor-pointer bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md text-center flex-shrink-0"
-                        >Upload File</label
-                    >
-                    <input
-                        type="file"
-                        id="file-${streamId}"
-                        class="input-file hidden"
-                        accept=".mpd, .xml, .m3u8"
-                        @change=${handleFileChange}
-                    />
-                </div>
-                <div
-                    class="preset-dropdown hidden absolute top-full left-0 right-0 mt-2 z-30 bg-gray-800 border border-gray-700 rounded-lg shadow-xl max-h-96 overflow-y-auto"
-                    @focusin=${handleDropdownFocusIn}
-                >
-                    ${renderDropdownSection('Saved', presets, true, presets)}
-                    ${renderDropdownSection('Recent', history, false, presets)}
-                    <div>
-                        <h4
-                            class="font-bold text-gray-200 text-xs tracking-wider uppercase px-3 pt-3 pb-2 sticky top-0 bg-gray-900 z-10 border-b border-gray-800/50"
-                        >
-                            Examples
-                        </h4>
-                        <div class="p-2">
-                            ${Object.entries(groupedExamples).map(
-                                ([protocol, types]) => html`
-                                    <div class="mt-2">
-                                        <h5
-                                            class="font-semibold text-gray-300 text-sm px-3 py-2 bg-gray-900/50 rounded-t-md"
-                                        >
-                                            ${protocol.toUpperCase()}
-                                        </h5>
-                                        <div
-                                            class="border border-t-0 border-gray-700/50 rounded-b-md"
-                                        >
-                                            ${Object.entries(types).map(
-                                                ([type, items]) =>
-                                                    renderExampleCategory(
-                                                        `${type
-                                                            .charAt(0)
-                                                            .toUpperCase()}${type.slice(
-                                                            1
-                                                        )}`,
-                                                        items,
-                                                        presets
-                                                    )
-                                            )}
-                                        </div>
-                                    </div>
-                                `
-                            )}
-                        </div>
-                    </div>
-                </div>
-            </div>
-            <div
-                class="flex flex-col sm:flex-row items-center gap-4 pt-4 border-t border-gray-700"
-            >
-                <input
-                    type="text"
-                    id="name-${streamId}"
-                    class="input-name w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600"
-                    placeholder="Enter a custom name to save this URL"
-                />
-                <button
-                    class="save-preset-btn w-full sm:w-auto flex-shrink-0 bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-md transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
-                    @click=${handleSavePreset}
-                    ?disabled=${presetUrls.has(
-                        isFirstStream && history.length > 0
-                            ? history[0].url
-                            : ''
-                    )}
-                >
-                    Save as Preset
-                </button>
-            </div>
-        </div>
-    </div>`;
-};
-
-export function getStreamInputsTemplate() {
-    const { streamInputIds } = useStore.getState();
-    const history = getHistory();
-    const presets = getPresets();
-    return html`${streamInputIds.map((id, index) =>
-        streamInputTemplate(id, index === 0, history, presets)
-    )}`;
-}
-
-export function addStreamInput() {
-    storeActions.addStreamInputId();
-}
-
-export function resetAndRenderAllStreamInputs() {
-    storeActions.resetStreamInputIds();
-}
diff --git a/js/ui/components/toast.js b/js/ui/components/toast.js
deleted file mode 100644
index 0d41d6a..0000000
--- a/js/ui/components/toast.js
+++ /dev/null
@@ -1,45 +0,0 @@
-import { eventBus } from '../../app/event-bus.js';
-
-let toastContainer;
-
-/**
- * Initializes the toast manager by setting the container element.
- * @param {object} dom - The application's DOM context.
- */
-export function initializeToastManager(dom) {
-    toastContainer = dom.toastContainer;
-    eventBus.subscribe('ui:show-status', showToast);
-}
-
-/**
- * Displays a transient toast notification.
- * @param {object} options
- * @param {string} options.message - The message to display.
- * @param {'info' | 'pass' | 'warn' | 'fail'} options.type - The message type.
- * @param {number} [options.duration=4000] - The duration in ms to show the toast.
- */
-export function showToast({ message, type, duration = 4000 }) {
-    if (!toastContainer) return;
-
-    const toast = document.createElement('div');
-    const colors = {
-        pass: 'bg-green-600 border-green-500',
-        fail: 'bg-red-600 border-red-500',
-        warn: 'bg-yellow-600 border-yellow-500',
-        info: 'bg-blue-600 border-blue-500',
-    };
-    toast.className = `p-4 rounded-lg border text-white shadow-lg transition-all duration-300 ease-in-out transform translate-x-full opacity-0 ${colors[type]}`;
-    toast.textContent = message;
-    toastContainer.appendChild(toast);
-
-    // Animate in
-    setTimeout(() => {
-        toast.classList.remove('translate-x-full', 'opacity-0');
-    }, 10);
-
-    // Set timer to animate out and remove
-    setTimeout(() => {
-        toast.classList.add('opacity-0', 'translate-x-8');
-        toast.addEventListener('transitionend', () => toast.remove());
-    }, duration);
-}
diff --git a/js/ui/components/tooltip.js b/js/ui/components/tooltip.js
deleted file mode 100644
index 1e32c69..0000000
--- a/js/ui/components/tooltip.js
+++ /dev/null
@@ -1,80 +0,0 @@
-export function setupGlobalTooltipListener(dom) {
-    document.body.addEventListener('mouseover', (e) => {
-        const target = /** @type {HTMLElement} */ (e.target);
-
-        const tooltipTrigger = /** @type {HTMLElement} */ (
-            target.closest('[data-tooltip], [data-tooltip-html-b64]')
-        );
-
-        if (!tooltipTrigger) {
-            dom.globalTooltip.style.visibility = 'hidden';
-            dom.globalTooltip.style.opacity = '0';
-            return;
-        }
-
-        const b64Html = tooltipTrigger.dataset.tooltipHtmlB64;
-        let tooltipContent = '';
-
-        try {
-            if (b64Html) {
-                tooltipContent = atob(b64Html);
-            } else {
-                const text = tooltipTrigger.dataset.tooltip || '';
-                const isoRef = tooltipTrigger.dataset.iso || '';
-                if (!text) return; // Don't show empty tooltips
-
-                tooltipContent = `${text}${
-                    isoRef
-                        ? `<span class="block mt-1 font-medium text-emerald-300">${isoRef}</span>`
-                        : ''
-                }`;
-            }
-        } catch (error) {
-            console.error(
-                'Failed to decode or process tooltip content:',
-                error
-            );
-            tooltipContent = '<span class="text-red-400">Tooltip Error</span>';
-        }
-
-        if (!tooltipContent.trim()) {
-            dom.globalTooltip.style.visibility = 'hidden';
-            dom.globalTooltip.style.opacity = '0';
-            return;
-        }
-
-        dom.globalTooltip.innerHTML = tooltipContent;
-
-        const targetRect = tooltipTrigger.getBoundingClientRect();
-        const tooltipRect = dom.globalTooltip.getBoundingClientRect();
-
-        let left =
-            targetRect.left + targetRect.width / 2 - tooltipRect.width / 2;
-
-        if (left < 10) left = 10;
-        if (left + tooltipRect.width > window.innerWidth - 10) {
-            left = window.innerWidth - tooltipRect.width - 10;
-        }
-
-        dom.globalTooltip.style.left = `${left}px`;
-        dom.globalTooltip.style.top = `${
-            targetRect.top - tooltipRect.height - 8
-        }px`; // 8px spacing
-
-        dom.globalTooltip.style.visibility = 'visible';
-        dom.globalTooltip.style.opacity = '1';
-    });
-
-    document.body.addEventListener('mouseout', (e) => {
-        const target = /** @type {HTMLElement} */ (e.target);
-        const relatedTarget = /** @type {HTMLElement} */ (e.relatedTarget);
-        const tooltipTrigger = target.closest(
-            '[data-tooltip], [data-tooltip-html-b64]'
-        );
-
-        if (tooltipTrigger && !tooltipTrigger.contains(relatedTarget)) {
-            dom.globalTooltip.style.visibility = 'hidden';
-            dom.globalTooltip.style.opacity = '0';
-        }
-    });
-}
diff --git a/js/ui/mainRenderer.js b/js/ui/mainRenderer.js
deleted file mode 100644
index 1a7f859..0000000
--- a/js/ui/mainRenderer.js
+++ /dev/null
@@ -1,207 +0,0 @@
-import { html, render } from 'lit-html';
-import { useStore, storeActions } from '../app/store.js';
-import { getGlobalSummaryTemplate } from './views/summary/index.js';
-import { getComplianceReportTemplate } from './views/compliance/index.js';
-import { initializeTimelineView } from './views/timeline-visuals/index.js';
-import { getFeaturesAnalysisTemplate } from './views/feature-analysis/index.js';
-import { getInteractiveManifestTemplate } from './views/interactive-manifest/index.js';
-import { getInteractiveSegmentTemplate } from './views/interactive-segment/index.js';
-import { initializeSegmentExplorer } from './views/segment-explorer/index.js';
-import { getComparisonTemplate } from './views/comparison/index.js';
-import { manifestUpdatesTemplate } from './views/manifest-updates/index.js';
-import { getParserCoverageTemplate } from './views/parser-coverage/index.js';
-import { getIntegratorsReportTemplate } from './views/integrators-report/index.js';
-import { globalControlsTemplate } from './ui-controller.js';
-import { getStreamInputsTemplate } from './components/stream-inputs.js';
-import { debugLog } from '../shared/utils/debug.js';
-import { hideLoader } from './components/loader.js';
-import { isDebugMode } from '../shared/utils/env.js';
-
-/** @typedef {import('lit-html').TemplateResult} TemplateResult */
-
-let dom;
-// activeTab will now be managed by the store, no local variable needed.
-
-/**
- * Sets the DOM context for the renderer.
- * @param {object} domContext The application's DOM context.
- */
-export function initializeRenderer(domContext) {
-    dom = domContext;
-}
-
-/**
- * Populates the context switcher dropdown when multiple streams are present.
- */
-export function populateContextSwitcher() {
-    const { streams, activeStreamId } = useStore.getState();
-    if (streams.length > 1) {
-        dom.contextSwitcherWrapper.classList.remove('hidden');
-        const optionsTemplate = streams.map(
-            (s) =>
-                html`<option value="${s.id}">
-                    ${s.name} (${s.protocol.toUpperCase()})
-                </option>`
-        );
-        render(optionsTemplate, dom.contextSwitcher);
-        dom.contextSwitcher.value = String(activeStreamId);
-    } else {
-        dom.contextSwitcherWrapper.classList.add('hidden');
-    }
-}
-
-// setActiveTab is removed as it's now an action in the store.
-
-/**
- * The main application render function. Reads the current state from the store
- * and re-renders the entire UI declaratively.
- */
-export function renderApp() {
-    if (!dom) return;
-
-    const state = useStore.getState();
-    const { streams, activeStreamId, viewState, activeTab, activeSegmentUrl } =
-        state;
-    const activeStream = streams.find((s) => s.id === activeStreamId);
-
-    // --- Top-Level View State Management ---
-    const isResultsView = viewState === 'results' && streams.length > 0;
-
-    dom.inputSection.classList.toggle('hidden', isResultsView);
-    dom.results.classList.toggle('hidden', !isResultsView);
-    dom.newAnalysisBtn.classList.toggle('hidden', !isResultsView);
-    dom.shareAnalysisBtn.classList.toggle('hidden', !isResultsView);
-    dom.copyDebugBtn.classList.toggle('hidden', !isResultsView);
-    dom.analyzeBtn.textContent =
-        state.streamInputIds.length > 1 ? 'Analyze & Compare' : 'Analyze';
-
-    const globalControls = document.getElementById('global-stream-controls');
-    if (globalControls) {
-        globalControls.classList.toggle('hidden', !isResultsView);
-        render(globalControlsTemplate(streams), globalControls);
-    }
-
-    // Responsive header alignment
-    dom.mainHeader.classList.toggle('md:justify-center', !isResultsView);
-    dom.mainHeader.classList.toggle('md:justify-between', isResultsView);
-    dom.headerTitleGroup.classList.toggle('text-center', !isResultsView);
-    dom.headerTitleGroup.classList.toggle('md:text-left', isResultsView);
-    dom.headerUrlDisplay.classList.toggle('hidden', !isResultsView);
-
-    if (isResultsView) {
-        const urlHtml = streams
-            .map(
-                (s) =>
-                    `<div class="truncate" title="${s.originalUrl}">${s.originalUrl}</div>`
-            )
-            .join('');
-        dom.headerUrlDisplay.innerHTML = `<span class="font-bold text-gray-300 block mb-1">Analyzed Stream(s):</span>${urlHtml}`;
-    } else {
-        dom.headerUrlDisplay.innerHTML = '';
-    }
-
-    // --- Conditional Tab Visibility ---
-    const comparisonTabButton = document.getElementById('tab-btn-comparison');
-    if (comparisonTabButton) {
-        comparisonTabButton.classList.toggle('hidden', streams.length <= 1);
-        if (streams.length <= 1 && activeTab === 'comparison') {
-            storeActions.setActiveTab('summary');
-        }
-    }
-
-    const interactiveSegmentTabButton = document.getElementById(
-        'tab-btn-interactive-segment'
-    );
-    if (interactiveSegmentTabButton) {
-        interactiveSegmentTabButton.classList.toggle(
-            'hidden',
-            !activeSegmentUrl
-        );
-    }
-
-    const parserCoverageTabButton = document.getElementById(
-        'tab-btn-parser-coverage'
-    );
-    if (parserCoverageTabButton) {
-        parserCoverageTabButton.classList.toggle('hidden', !isDebugMode);
-    }
-
-    // --- Content Rendering Logic ---
-    if (isResultsView) {
-        populateContextSwitcher();
-        render(html``, dom.streamInputs); // Clear inputs
-
-        Object.entries(dom.tabContents).forEach(([tabName, container]) => {
-            if (!container) return;
-            debugLog(
-                'mainRenderer',
-                `Processing tab: ${tabName}. Active tab: ${activeTab}.`
-            );
-
-            if (tabName !== activeTab) {
-                render(html``, container);
-                container.classList.add('hidden');
-                return;
-            }
-
-            container.classList.remove('hidden');
-            debugLog(
-                'mainRenderer',
-                `Rendering active tab: ${tabName}. Stream available: ${!!activeStream}`
-            );
-
-            /** @type {TemplateResult} */
-            let template = html``;
-            if (tabName === 'comparison' && streams.length > 1) {
-                template = getComparisonTemplate(streams);
-            } else if (activeStream) {
-                switch (tabName) {
-                    case 'summary':
-                        template = getGlobalSummaryTemplate(activeStream);
-                        break;
-                    case 'integrators-report':
-                        template = getIntegratorsReportTemplate(activeStream);
-                        break;
-                    case 'compliance':
-                        template = getComplianceReportTemplate(activeStream);
-                        break;
-                    case 'features':
-                        template = getFeaturesAnalysisTemplate(activeStream);
-                        break;
-                    case 'interactive-manifest':
-                        template = getInteractiveManifestTemplate(activeStream);
-                        break;
-                    case 'interactive-segment':
-                        template = getInteractiveSegmentTemplate(dom);
-                        break;
-                    case 'updates':
-                        template = manifestUpdatesTemplate(activeStream);
-                        break;
-                    case 'parser-coverage':
-                        template = getParserCoverageTemplate(activeStream);
-                        break;
-                }
-            }
-
-            render(template, container);
-
-            if (tabName === 'timeline-visuals' && activeStream) {
-                initializeTimelineView(container, activeStream);
-            }
-            if (tabName === 'explorer' && activeStream) {
-                initializeSegmentExplorer(container, activeStream);
-            }
-        });
-    } else {
-        render(getStreamInputsTemplate(), dom.streamInputs);
-        Object.values(dom.tabContents).forEach((container) => {
-            if (container) {
-                render(html``, container);
-                container.classList.add('hidden');
-            }
-        });
-    }
-
-    // Hide loader after render is complete and the browser is about to paint the new view
-    hideLoader();
-}
diff --git a/js/ui/shared/dash-renderer.js b/js/ui/shared/dash-renderer.js
deleted file mode 100644
index 37779b1..0000000
--- a/js/ui/shared/dash-renderer.js
+++ /dev/null
@@ -1,209 +0,0 @@
-import { html } from 'lit-html';
-import { unsafeHTML } from 'lit-html/directives/unsafe-html.js';
-import { dashTooltipData } from '../views/interactive-manifest/components/dash/tooltip-data.js';
-import { tooltipTriggerClasses } from '../../shared/constants.js';
-
-const highlightColors = {
-    fail: 'bg-red-900/60',
-    warn: 'bg-yellow-900/60',
-    pass: 'bg-green-900/50',
-};
-
-const escapeHtml = (str) =>
-    str
-        .replace(/&/g, '&amp;')
-        .replace(/</g, '&lt;')
-        .replace(/>/g, '&gt;')
-        .replace(/"/g, '&quot;');
-
-const getTagHTML = (tagName, path, complianceResults) => {
-    const isClosing = tagName.startsWith('/');
-    const cleanTagName = isClosing ? tagName.substring(1) : tagName;
-    const tagInfo = dashTooltipData[cleanTagName];
-    const [prefix, localName] = cleanTagName.includes(':')
-        ? cleanTagName.split(':')
-        : [null, cleanTagName];
-    const displayPrefix = prefix
-        ? `<span class="text-gray-400">${prefix}:</span>`
-        : '';
-    const tagClass = 'text-blue-300';
-    let tooltipAttrs = tagInfo
-        ? `data-tooltip="${escapeHtml(tagInfo.text)}" data-iso="${escapeHtml(
-              tagInfo.isoRef
-          )}"`
-        : `data-tooltip="No definition for &lt;${cleanTagName}&gt;"`;
-
-    // Compliance highlighting overrides standard tooltips
-    const complianceResult = complianceResults.find(
-        (r) => r.location.path === path
-    );
-    if (complianceResult) {
-        tooltipAttrs = `data-tooltip="${escapeHtml(complianceResult.details)}" data-iso="${escapeHtml(complianceResult.isoRef)}"`;
-    }
-    const triggerClass =
-        tagInfo || complianceResult ? tooltipTriggerClasses : '';
-
-    return `&lt;${isClosing ? '/' : ''}<span class="${triggerClass}" ${tooltipAttrs}>${displayPrefix}<span class="${tagClass}">${localName}</span></span>`;
-};
-
-const getAttributeHTML = (tagName, attr, path, complianceResults) => {
-    const attrKey = `${tagName}@${attr.name}`;
-    const attrInfo = dashTooltipData[attrKey];
-    const nameClass = 'text-emerald-300';
-    const valueClass = 'text-yellow-300';
-    const isIgnoredAttr = ['xmlns', 'xmlns:xsi', 'xsi:schemaLocation'].includes(
-        attr.name
-    );
-
-    let dynamicClasses = '';
-    let tooltipAttrs = '';
-
-    // Prioritize compliance result for tooltip
-    const complianceResult = complianceResults.find(
-        (r) => r.location.path === path && r.details.includes(`@${attr.name}`)
-    );
-
-    if (complianceResult) {
-        dynamicClasses = tooltipTriggerClasses;
-        tooltipAttrs = `data-tooltip="${escapeHtml(complianceResult.details)}" data-iso="${escapeHtml(complianceResult.isoRef)}"`;
-    } else if (attrInfo) {
-        dynamicClasses = tooltipTriggerClasses;
-        tooltipAttrs = `data-tooltip="${escapeHtml(attrInfo.text)}" data-iso="${escapeHtml(attrInfo.isoRef)}"`;
-    } else if (!isIgnoredAttr) {
-        dynamicClasses = 'cursor-help bg-red-900/50 missing-tooltip-trigger';
-        tooltipAttrs = `data-tooltip="Tooltip definition missing for '${attr.name}' on &lt;${tagName}&gt;"`;
-    }
-
-    return `<span class="${nameClass} ${dynamicClasses}" ${tooltipAttrs}>${
-        attr.name
-    }</span>="<span class="${valueClass}">${escapeHtml(attr.value)}</span>"`;
-};
-
-const preformattedDash = (
-    node,
-    complianceResults,
-    path = 'MPD[0]',
-    depth = 0
-) => {
-    if (!node || typeof node.nodeType === 'undefined') {
-        return [];
-    }
-    const indent = '  '.repeat(depth);
-    switch (node.nodeType) {
-        case Node.ELEMENT_NODE: {
-            const el = /** @type {Element} */ (node);
-            const childNodes = Array.from(el.childNodes).filter(
-                (n) =>
-                    n.nodeType === Node.ELEMENT_NODE ||
-                    n.nodeType === Node.COMMENT_NODE ||
-                    (n.nodeType === Node.TEXT_NODE && n.textContent.trim())
-            );
-            const childElementCounts = {};
-
-            const complianceResult = complianceResults.find(
-                (r) => r.location.path === path
-            );
-            const highlightClass = complianceResult
-                ? `${highlightColors[complianceResult.status]} compliance-highlight`
-                : '';
-            const locationId = complianceResult
-                ? `loc-${complianceResult.id}`
-                : '';
-
-            const attrs = Array.from(el.attributes)
-                .map(
-                    (a) =>
-                        ` ${getAttributeHTML(el.tagName, a, path, complianceResults)}`
-                )
-                .join('');
-
-            const openingTagStart = `<div class="flex ${highlightClass}" id="${locationId}">
-                <span class="text-right text-gray-500 pr-4 select-none flex-shrink-0 w-12">${'' /*Line number placeholder*/}</span>
-                <span class="flex-grow whitespace-pre-wrap break-all">`;
-
-            if (childNodes.length > 0) {
-                const openingTag = `${openingTagStart}${indent}${getTagHTML(el.tagName, path, complianceResults)}${attrs}&gt;</span></div>`;
-                const childLines = childNodes.flatMap((c) => {
-                    const childElementName =
-                        c.nodeType === Node.ELEMENT_NODE
-                            ? /** @type {Element} */ (c).tagName
-                            : 'child';
-                    childElementCounts[childElementName] =
-                        (childElementCounts[childElementName] || 0) + 1;
-                    const childIndex = childElementCounts[childElementName] - 1;
-                    const childPath =
-                        c.nodeType === Node.ELEMENT_NODE
-                            ? `${path}.${childElementName}[${childIndex}]`
-                            : path;
-                    return preformattedDash(
-                        c,
-                        complianceResults,
-                        childPath,
-                        depth + 1
-                    );
-                });
-                const closingTag = `${openingTagStart}${indent}${getTagHTML(`/${el.tagName}`, path, complianceResults)}&gt;</span></div>`;
-                return [openingTag, ...childLines, closingTag];
-            } else {
-                return [
-                    `${openingTagStart}${indent}${getTagHTML(el.tagName, path, complianceResults)}${attrs} /&gt;</span></div>`,
-                ];
-            }
-        }
-        case Node.TEXT_NODE: {
-            return [
-                `<div class="flex"><span class="text-right text-gray-500 pr-4 select-none flex-shrink-0 w-12"></span><span class="flex-grow whitespace-pre-wrap break-all">${indent}<span class="text-gray-200">${escapeHtml(
-                    node.textContent.trim()
-                )}</span></span></div>`,
-            ];
-        }
-        case Node.COMMENT_NODE: {
-            return [
-                `<div class="flex"><span class="text-right text-gray-500 pr-4 select-none flex-shrink-0 w-12"></span><span class="flex-grow whitespace-pre-wrap break-all">${indent}<span class="text-gray-500 italic">&lt;!--${escapeHtml(
-                    node.textContent
-                )}--&gt;</span></span></div>`,
-            ];
-        }
-        default:
-            return [];
-    }
-};
-
-export const renderDashManifest = (manifestString, complianceResults = []) => {
-    let manifestElement;
-    const parser = new DOMParser();
-    const xmlDoc = parser.parseFromString(manifestString, 'application/xml');
-    const parserError = xmlDoc.querySelector('parsererror');
-
-    if (parserError) {
-        return html`<div class="text-red-400 p-4 font-mono">
-            <p class="font-bold">Failed to parse manifest XML.</p>
-            <pre class="mt-2 bg-gray-900 p-2 rounded">
-${parserError.textContent}</pre
-            >
-        </div>`;
-    }
-
-    manifestElement = xmlDoc.querySelector('MPD');
-
-    if (!manifestElement) {
-        return html`<div class="text-red-400 p-4">
-            Error: &lt;MPD&gt; root element not found.
-        </div>`;
-    }
-
-    // This creates an array of HTML strings, each wrapped in a div with a placeholder for the line number.
-    const allLinesHtml = preformattedDash(manifestElement, complianceResults);
-
-    // Now we add the line numbers.
-    const finalHtml = allLinesHtml
-        .map((line, index) => {
-            return line.replace(
-                /<span class="text-right.*?w-12">.*?<\/span>/,
-                `<span class="text-right text-gray-500 pr-4 select-none flex-shrink-0 w-12">${index + 1}</span>`
-            );
-        })
-        .join('');
-
-    return html`${unsafeHTML(finalHtml)}`;
-};
diff --git a/js/ui/shared/scte35-details.js b/js/ui/shared/scte35-details.js
deleted file mode 100644
index 978ee53..0000000
--- a/js/ui/shared/scte35-details.js
+++ /dev/null
@@ -1,135 +0,0 @@
-import { html } from 'lit-html';
-
-const detailRow = (label, value) => {
-    if (value === undefined || value === null) return '';
-    return html`
-        <dt class="text-gray-400 font-medium">${label}</dt>
-        <dd class="text-white font-mono break-all">${value}</dd>
-    `;
-};
-
-const commandDetailsTemplate = (command) => {
-    if (!command) return '';
-    switch (command.type) {
-        case 'Splice Insert':
-            return html`
-                ${detailRow('Splice Event ID', command.splice_event_id)}
-                ${detailRow(
-                    'Out of Network',
-                    command.out_of_network_indicator ? 'Yes' : 'No'
-                )}
-                ${detailRow(
-                    'Program Splice',
-                    command.program_splice_flag ? 'Yes' : 'No'
-                )}
-                ${detailRow(
-                    'Immediate',
-                    command.splice_immediate_flag ? 'Yes' : 'No'
-                )}
-                ${command.splice_time?.time_specified
-                    ? detailRow(
-                          'PTS Time',
-                          `${command.splice_time.pts_time} (${
-                              command.splice_time.pts_time / 90000
-                          }s)`
-                      )
-                    : ''}
-                ${command.break_duration?.auto_return
-                    ? detailRow(
-                          'Break Duration',
-                          `${command.break_duration.duration} (${
-                              command.break_duration.duration / 90000
-                          }s)`
-                      )
-                    : ''}
-                ${detailRow('Unique Program ID', command.unique_program_id)}
-                ${detailRow('Avail Num', command.avail_num)}
-                ${detailRow('Avails Expected', command.avails_expected)}
-            `;
-        case 'Time Signal':
-            return html`
-                ${command.splice_time?.time_specified
-                    ? detailRow(
-                          'PTS Time',
-                          `${command.splice_time.pts_time} (${
-                              command.splice_time.pts_time / 90000
-                          }s)`
-                      )
-                    : detailRow('PTS Time', 'Not Specified')}
-            `;
-        default:
-            return html`<p>Unsupported command type: ${command.type}</p>`;
-    }
-};
-
-const descriptorDetailsTemplate = (descriptor) => {
-    if (!descriptor) return '';
-    return html`
-        ${detailRow('Event ID', descriptor.segmentation_event_id)}
-        ${detailRow('UPID Type', descriptor.segmentation_upid_type)}
-        ${detailRow('UPID', descriptor.segmentation_upid)}
-        ${detailRow('Type', descriptor.segmentation_type_id)}
-        ${detailRow('Segment Num', descriptor.segment_num)}
-        ${detailRow('Segments Expected', descriptor.segments_expected)}
-        ${descriptor.segmentation_duration
-            ? detailRow(
-                  'Duration',
-                  `${descriptor.segmentation_duration} (${
-                      descriptor.segmentation_duration / 90000
-                  }s)`
-              )
-            : ''}
-    `;
-};
-
-export const scte35DetailsTemplate = (scte35) => {
-    if (!scte35 || scte35.error) {
-        return html`<p class="text-red-400">
-            Failed to parse SCTE-35 message: ${scte35?.error || 'Unknown Error'}
-        </p>`;
-    }
-
-    return html`
-        <div class="space-y-4 text-xs">
-            <div class="bg-gray-900 p-3 rounded-lg">
-                <h4 class="font-bold text-gray-300 mb-2">
-                    Splice Info Section
-                </h4>
-                <dl class="grid grid-cols-[auto_1fr] gap-x-4">
-                    ${detailRow('Table ID', scte35.table_id)}
-                    ${detailRow('Protocol Version', scte35.protocol_version)}
-                    ${detailRow(
-                        'PTS Adjustment',
-                        `${scte35.pts_adjustment} (${
-                            scte35.pts_adjustment / 90000
-                        }s)`
-                    )}
-                    ${detailRow('CW Index', scte35.cw_index)}
-                    ${detailRow('Tier', `0x${scte35.tier.toString(16)}`)}
-                </dl>
-            </div>
-
-            <div class="bg-gray-900 p-3 rounded-lg">
-                <h4 class="font-bold text-gray-300 mb-2">
-                    ${scte35.splice_command?.type || 'Splice Command'}
-                </h4>
-                <dl class="grid grid-cols-[auto_1fr] gap-x-4">
-                    ${commandDetailsTemplate(scte35.splice_command)}
-                </dl>
-            </div>
-
-            ${(scte35.descriptors || []).map(
-                (desc) => html`
-                    <div class="bg-gray-900 p-3 rounded-lg">
-                        <h4 class="font-bold text-gray-300 mb-2">
-                            Segmentation Descriptor
-                        </h4>
-                        <dl class="grid grid-cols-[auto_1fr] gap-x-4">
-                            ${descriptorDetailsTemplate(desc)}
-                        </dl>
-                    </div>
-                `
-            )}
-        </div>
-    `;
-};
diff --git a/js/ui/shared/syntax-highlighter.js b/js/ui/shared/syntax-highlighter.js
deleted file mode 100644
index 4037d8d..0000000
--- a/js/ui/shared/syntax-highlighter.js
+++ /dev/null
@@ -1,101 +0,0 @@
-const escapeHtml = (str) =>
-    str
-        .replace(/&/g, '&amp;')
-        .replace(/</g, '&lt;')
-        .replace(/>/g, '&gt;')
-        .replace(/"/g, '&quot;');
-
-/**
- * Applies syntax highlighting to a raw DASH manifest string.
- * @param {string} text - The raw XML string.
- * @returns {string} An HTML string with syntax highlighting.
- */
-export function highlightDash(text) {
-    if (!text) return '';
-    const escaped = escapeHtml(text);
-
-    // This regex uses multiple capture groups to identify different parts of the XML structure.
-    // By processing them in a single pass, we avoid the issue of one replacement
-    // creating a string that is then incorrectly matched by a subsequent replacement.
-    // Group 1: Comments (e.g., <!-- ... -->)
-    // Group 2: Processing Instructions (e.g., <?xml ... ?>)
-    // Group 3: Opening tag part (e.g., '<' or '</')
-    // Group 4: Tag name
-    // Group 5: Attribute name (e.g., 'type=')
-    // Group 6: Opening quote of an attribute value
-    // Group 7: The attribute value itself
-    // Group 8: Closing quote of an attribute value
-    const regex =
-        /(&lt;!--[\s\S]*?--&gt;)|(&lt;\?[\s\S]*?\?&gt;)|(&lt;\/?)([\w:-]+)|([\w:-]+=)|(&quot;)([^&quot;]*)(&quot;)/g;
-
-    return escaped.replace(
-        regex,
-        (match, comment, pi, open, tag, attr, openQuote, value, closeQuote) => {
-            if (comment) {
-                return `<span class="text-gray-500 italic">${comment}</span>`;
-            }
-            if (pi) {
-                // Highlighting for PIs can be the same as comments or different
-                return `<span class="text-gray-500">${pi}</span>`;
-            }
-            if (open) {
-                // A tag was matched
-                return `${open}<span class="text-blue-300">${tag}</span>`;
-            }
-            if (attr) {
-                // An attribute was matched
-                return `<span class="text-emerald-300">${attr.slice(
-                    0,
-                    -1
-                )}</span>=`;
-            }
-            if (openQuote) {
-                // An attribute value was matched
-                return `${openQuote}<span class="text-yellow-300">${value}</span>${closeQuote}`;
-            }
-            return match; // Fallback for anything else (e.g., content text)
-        }
-    );
-}
-
-/**
- * Applies syntax highlighting to a raw HLS manifest string.
- * @param {string} text - The raw M3U8 string.
- * @returns {string} An HTML string with syntax highlighting.
- */
-export function highlightHls(text) {
-    if (!text) return '';
-    return text
-        .split('\n')
-        .map((line) => {
-            const escaped = escapeHtml(line.trim());
-            if (escaped.startsWith('#EXT')) {
-                const separatorIndex = escaped.indexOf(':');
-                if (separatorIndex === -1) {
-                    return `#<span class="text-purple-300">${escaped.substring(
-                        1
-                    )}</span>`;
-                }
-                const tagName = escaped.substring(1, separatorIndex);
-                let tagValue = escaped.substring(separatorIndex + 1);
-
-                // Highlight attributes within the value
-                tagValue = tagValue.replace(
-                    /([A-Z0-9-]+)=/g,
-                    '<span class="text-emerald-300">$1</span>='
-                );
-                // Highlight quoted strings
-                tagValue = tagValue.replace(
-                    /"([^"]*)"/g,
-                    '"<span class="text-yellow-300">$1</span>"'
-                );
-
-                return `#<span class="text-purple-300">${tagName}</span>:${tagValue}`;
-            }
-            if (escaped.startsWith('#')) {
-                return `<span class="text-gray-500">${escaped}</span>`;
-            }
-            return `<span class="text-cyan-400">${escaped}</span>`;
-        })
-        .join('\n');
-}
diff --git a/js/ui/tabs.js b/js/ui/tabs.js
deleted file mode 100644
index 4bea830..0000000
--- a/js/ui/tabs.js
+++ /dev/null
@@ -1,74 +0,0 @@
-import { stopLiveSegmentHighlighter } from './views/segment-explorer/components/hls/index.js';
-import { useStore, storeActions } from '../app/store.js';
-import { showLoader } from './components/loader.js';
-
-let dom;
-let keyboardNavigationListener = null;
-
-export function initializeTabs(domContext) {
-    dom = domContext;
-    dom.tabs.addEventListener('click', handleTabClick);
-
-    // Subscribe to activeTab changes in the store to update button styling
-    useStore.subscribe((state, prevState) => {
-        if (state.activeTab !== prevState.activeTab) {
-            updateTabButtonStyling(state.activeTab);
-        }
-    });
-
-    // Initial styling on load
-    updateTabButtonStyling(useStore.getState().activeTab);
-}
-
-function updateTabButtonStyling(activeTabName) {
-    const activeClasses = ['border-blue-600', 'text-gray-100', 'bg-gray-700'];
-    const inactiveClasses = ['border-transparent'];
-
-    dom.tabs.querySelectorAll('[data-tab]').forEach((t) => {
-        if (t.dataset.tab === activeTabName) {
-            t.classList.add(...activeClasses);
-            t.classList.remove(...inactiveClasses);
-        } else {
-            t.classList.remove(...activeClasses);
-            t.classList.add(...inactiveClasses);
-        }
-    });
-}
-
-async function handleTabClick(e) {
-    const target = /** @type {HTMLElement} */ (e.target);
-    const targetTab = /** @type {HTMLElement} */ (target.closest('[data-tab]'));
-    if (!targetTab) return;
-
-    if (useStore.getState().activeTab === targetTab.dataset.tab) {
-        return; // Do not re-render if the same tab is clicked
-    }
-
-    showLoader('Loading view...');
-
-    // Defer the state change and subsequent render to the next event loop tick.
-    // This gives the browser a chance to paint the loader before the main thread
-    // gets blocked by the potentially heavy rendering work of the new tab.
-    setTimeout(async () => {
-        if (keyboardNavigationListener) {
-            document.removeEventListener('keydown', keyboardNavigationListener);
-            keyboardNavigationListener = null;
-        }
-        stopLiveSegmentHighlighter();
-
-        const activeTabName = targetTab.dataset.tab;
-        storeActions.setActiveTab(activeTabName);
-
-        // Special handling for keyboard navigation in the 'updates' tab
-        if (activeTabName === 'updates') {
-            const { navigateManifestUpdates } = await import(
-                './views/manifest-updates/index.js'
-            );
-            keyboardNavigationListener = (event) => {
-                if (event.key === 'ArrowRight') navigateManifestUpdates(1);
-                if (event.key === 'ArrowLeft') navigateManifestUpdates(-1);
-            };
-            document.addEventListener('keydown', keyboardNavigationListener);
-        }
-    }, 0);
-}
diff --git a/js/ui/ui-controller.js b/js/ui/ui-controller.js
deleted file mode 100644
index 03da72a..0000000
--- a/js/ui/ui-controller.js
+++ /dev/null
@@ -1,114 +0,0 @@
-import { html } from 'lit-html';
-import { eventBus } from '../app/event-bus.js';
-import { useStore, useSegmentCacheStore } from '../app/store.js';
-import { savePreset } from '../shared/utils/stream-storage.js';
-import {
-    reloadStream,
-    toggleAllLiveStreamsPolling,
-} from '../services/streamActionsService.js';
-import { openModalWithContent } from '../services/modalService.js';
-
-const handleSaveCurrentStream = () => {
-    const { streams, activeStreamId } = useStore.getState();
-    const stream = streams.find((s) => s.id === activeStreamId);
-    if (!stream || !stream.originalUrl) {
-        eventBus.dispatch('ui:show-status', {
-            message: 'Cannot save a stream loaded from a local file.',
-            type: 'warn',
-        });
-        return;
-    }
-
-    const name = prompt(
-        'Enter a name for this preset:',
-        stream.name || new URL(stream.originalUrl).hostname
-    );
-
-    if (name) {
-        savePreset({
-            name,
-            url: stream.originalUrl,
-            protocol: stream.protocol,
-            type: stream.manifest.type === 'dynamic' ? 'live' : 'vod',
-        });
-    }
-};
-
-export const globalControlsTemplate = (streams) => {
-    const { activeStreamId } = useStore.getState();
-    const activeStream = streams.find((s) => s.id === activeStreamId);
-
-    const hasLiveStreams = streams.some((s) => s.manifest?.type === 'dynamic');
-    if (!hasLiveStreams) return html``; // Don't show controls if no live streams are loaded
-
-    const isAnyPolling = streams.some(
-        (s) => s.manifest?.type === 'dynamic' && s.isPolling
-    );
-
-    const pollingButton = html`
-        <button
-            @click=${toggleAllLiveStreamsPolling}
-            class="font-bold text-sm py-2 px-4 rounded-md transition-colors text-white ${isAnyPolling
-                ? 'bg-red-600 hover:bg-red-700'
-                : 'bg-blue-600 hover:bg-blue-700'}"
-        >
-            ${isAnyPolling ? 'Stop All Polling' : 'Start All Polling'}
-        </button>
-    `;
-
-    return html`
-        ${pollingButton}
-        <button
-            @click=${() => reloadStream(activeStream)}
-            class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md transition-colors"
-        >
-            Reload Active
-        </button>
-        <button
-            @click=${handleSaveCurrentStream}
-            class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-md transition-colors"
-            title="Save the current stream URL as a preset"
-        >
-            Save Active Stream
-        </button>
-    `;
-};
-
-export function initializeUiController(domContext) {
-    eventBus.subscribe('ui:request-segment-analysis', ({ url }) => {
-        const cachedSegment = useSegmentCacheStore.getState().get(url);
-        openModalWithContent({
-            title: 'Segment Analysis',
-            url: url,
-            content: {
-                type: 'segmentAnalysis',
-                data: { parsedData: cachedSegment?.parsedData },
-            },
-        });
-    });
-
-    eventBus.subscribe('ui:request-segment-comparison', ({ urlA, urlB }) => {
-        const { get: getFromCache } = useSegmentCacheStore.getState();
-        const segmentA = getFromCache(urlA);
-        const segmentB = getFromCache(urlB);
-        openModalWithContent({
-            title: 'Segment Comparison',
-            url: 'Comparing Segment A vs. Segment B',
-            content: {
-                type: 'segmentAnalysis',
-                data: {
-                    parsedData: segmentA?.parsedData,
-                    parsedDataB: segmentB?.parsedData,
-                },
-            },
-        });
-    });
-
-    eventBus.subscribe('ui:show-scte35-details', ({ scte35, startTime }) => {
-        openModalWithContent({
-            title: `SCTE-35 Details @ ${startTime.toFixed(3)}s`,
-            url: 'Decoded Splice Info Section',
-            content: { type: 'scte35', data: { scte35, startTime } },
-        });
-    });
-}
diff --git a/js/ui/view-manager.js b/js/ui/view-manager.js
deleted file mode 100644
index 3aedfcb..0000000
--- a/js/ui/view-manager.js
+++ /dev/null
@@ -1,21 +0,0 @@
-import { eventBus } from '../app/event-bus.js';
-import { storeActions } from '../app/store.js';
-
-export function initializeViewManager() {
-    // This event should only indicate that the process has begun, typically
-    // to show a loader. It should not reset the application state.
-    eventBus.subscribe('analysis:started', () => {
-        // DO NOT reset state here. The loader is handled separately.
-        // The store is now only reset when a new analysis is explicitly requested
-        // by the user via the "Analyze New Streams" button.
-    });
-
-    // If analysis fails after starting, we ensure we're back in the input state.
-    // The `startAnalysis` action resets the store, which includes setting viewState to 'input'.
-    eventBus.subscribe('analysis:failed', () => {
-        storeActions.setViewState('input');
-    });
-
-    // The `completeAnalysis` action, called on 'state:analysis-complete',
-    // handles setting the viewState to 'results'. No listener is needed here.
-}
diff --git a/js/ui/views/comparison/index.js b/js/ui/views/comparison/index.js
deleted file mode 100644
index d039653..0000000
--- a/js/ui/views/comparison/index.js
+++ /dev/null
@@ -1,50 +0,0 @@
-import { html } from 'lit-html';
-import { createComparisonViewModel } from './view-model.js';
-import { comparisonRowTemplate } from './row.js';
-
-const sectionTemplate = (title, points, streams) => html`
-    <h3 class="text-xl font-bold mt-6 mb-2">${title}</h3>
-    <div class="border-b border-gray-700">
-        ${points.map((point) => comparisonRowTemplate(point, streams.length))}
-    </div>
-`;
-
-export function getComparisonTemplate(streams) {
-    if (streams.length < 2) {
-        return html``;
-    }
-
-    const groupedComparisonPoints = createComparisonViewModel(streams);
-
-    return html`
-        <div class="overflow-x-auto">
-            <!-- Main Sticky Header -->
-            <div
-                class="grid bg-gray-900/50 sticky top-0 z-10 min-w-[800px]"
-                style="grid-template-columns: 200px repeat(${streams.length}, minmax(200px, 1fr));"
-            >
-                <div
-                    class="font-semibold text-gray-400 p-2 border-b border-r border-gray-700"
-                >
-                    Property
-                </div>
-                ${streams.map(
-                    (stream) =>
-                        html`<div
-                            class="font-semibold text-gray-300 p-2 border-b border-r border-gray-700 truncate"
-                            title="${stream.name}"
-                        >
-                            ${stream.name}
-                        </div>`
-                )}
-            </div>
-
-            <!-- Data Sections -->
-            <div class="min-w-[800px]">
-                ${groupedComparisonPoints.map((group) =>
-                    sectionTemplate(group.title, group.points, streams)
-                )}
-            </div>
-        </div>
-    `;
-}
diff --git a/js/ui/views/comparison/row.js b/js/ui/views/comparison/row.js
deleted file mode 100644
index 61f2197..0000000
--- a/js/ui/views/comparison/row.js
+++ /dev/null
@@ -1,44 +0,0 @@
-import { html } from 'lit-html';
-import { unsafeHTML } from 'lit-html/directives/unsafe-html.js';
-import { tooltipTriggerClasses } from '../../../shared/constants.js';
-
-/**
- * Renders a single row in the comparison view.
- * @param {object} comparisonPoint - The data for the row.
- * @param {string} comparisonPoint.label - The title of the row.
- * @param {string} comparisonPoint.tooltip - The tooltip description.
- * @param {string} comparisonPoint.isoRef - The specification reference.
- * @param {Array<string|object>} comparisonPoint.values - The values for each stream.
- * @param {number} numStreams - The total number of streams being compared.
- * @returns {import('lit-html').TemplateResult}
- */
-export const comparisonRowTemplate = (comparisonPoint, numStreams) => {
-    const { label, tooltip, isoRef, values } = comparisonPoint;
-
-    // The grid is now inside a scrolling container, so it can have a minimum width.
-    const gridStyle = `grid-template-columns: 200px repeat(${numStreams}, minmax(200px, 1fr));`;
-
-    return html`
-        <div
-            class="grid border-t border-l border-gray-700"
-            style="${gridStyle}"
-        >
-            <div
-                class="font-medium text-gray-400 p-2 border-r border-gray-700 ${tooltipTriggerClasses}"
-                data-tooltip="${tooltip}"
-                data-iso="${isoRef}"
-            >
-                ${label}
-            </div>
-            ${values.map(
-                (value) => html`
-                    <div
-                        class="p-2 font-mono text-xs border-r border-gray-700 break-words"
-                    >
-                        ${unsafeHTML(value ?? '')}
-                    </div>
-                `
-            )}
-        </div>
-    `;
-};
diff --git a/js/ui/views/comparison/view-model.js b/js/ui/views/comparison/view-model.js
deleted file mode 100644
index 18eab06..0000000
--- a/js/ui/views/comparison/view-model.js
+++ /dev/null
@@ -1,278 +0,0 @@
-const valueOrNA = (value) =>
-    value !== null && value !== undefined ? value : 'N/A';
-
-const renderList = (items) =>
-    items && items.length > 0
-        ? items.map((item) => `<div>${item}</div>`).join('')
-        : 'N/A';
-
-/**
- * Defines the points of comparison and contains the logic to extract
- * data for each stream from the new summary model.
- * @param {import('../../../app/types.js').Stream[]} streams
- * @returns {object[]} An array of comparison point objects ready for rendering.
- */
-export function createComparisonViewModel(streams) {
-    const comparisonPoints = [
-        // --- Manifest Properties ---
-        {
-            label: 'Type',
-            tooltip: 'static (VOD) vs dynamic (live)',
-            isoRef: 'DASH: 5.3.1.2 / HLS: 4.3.3.5',
-            values: streams.map((s) =>
-                valueOrNA(
-                    s.manifest?.summary.general.streamType.startsWith('Live')
-                        ? 'dynamic'
-                        : 'static'
-                )
-            ),
-        },
-        {
-            label: 'Profiles / Version',
-            tooltip: 'Declared feature sets or HLS version.',
-            isoRef: 'DASH: 8.1 / HLS: 4.3.1.2',
-            values: streams.map((s) =>
-                valueOrNA(
-                    s.manifest?.summary.dash?.profiles ||
-                        `Version ${s.manifest?.summary.hls?.version}`
-                )
-            ),
-        },
-        {
-            label: 'Min Buffer / Target Duration',
-            tooltip:
-                'Minimum client buffer time (DASH) or max segment duration (HLS).',
-            isoRef: 'DASH: 5.3.1.2 / HLS: 4.3.3.1',
-            values: streams.map((s) => {
-                const val =
-                    s.manifest?.summary.dash?.minBufferTime ??
-                    s.manifest?.summary.hls?.targetDuration;
-                return val ? `${val}s` : 'N/A';
-            }),
-        },
-        {
-            label: 'Live Window',
-            tooltip: 'DVR window for live streams.',
-            isoRef: 'DASH: 5.3.1.2',
-            values: streams.map((s) =>
-                s.manifest?.summary.dash?.timeShiftBufferDepth
-                    ? `${s.manifest.summary.dash.timeShiftBufferDepth}s`
-                    : 'N/A'
-            ),
-        },
-        {
-            label: 'Segment Format',
-            tooltip:
-                'The container format used for media segments (e.g., ISOBMFF or MPEG-2 TS).',
-            isoRef: 'DASH: 5.3.7 / HLS: 4.3.2.5',
-            values: streams.map((s) =>
-                valueOrNA(s.manifest?.summary.general.segmentFormat)
-            ),
-        },
-        // --- Content Overview ---
-        {
-            label: '# of Periods',
-            tooltip: 'Number of content periods (DASH-specific).',
-            isoRef: 'DASH: 5.3.2',
-            values: streams.map((s) =>
-                s.protocol === 'dash'
-                    ? String(s.manifest?.summary.content.totalPeriods || 0)
-                    : 'N/A'
-            ),
-        },
-        {
-            label: 'Content Protection',
-            tooltip: 'Detected DRM systems.',
-            isoRef: 'DASH: 5.8.4.1 / HLS: 4.3.2.4',
-            values: streams.map((s) => {
-                const security = s.manifest?.summary.security;
-                return security?.isEncrypted
-                    ? security.systems.join(', ')
-                    : 'No';
-            }),
-        },
-        // --- Video Details ---
-        {
-            label: '# Video Quality Levels',
-            tooltip: 'Total number of video tracks or variants.',
-            isoRef: 'DASH: 5.3.5 / HLS: 4.3.4.2',
-            values: streams.map((s) =>
-                String(s.manifest?.summary.content.totalVideoTracks || 0)
-            ),
-        },
-        {
-            label: 'Video Bitrate Range',
-            tooltip: 'Min and Max bandwidth values for video.',
-            isoRef: 'DASH: 5.3.5.2 / HLS: 4.3.4.2',
-            values: streams.map((s) => {
-                const tracks = s.manifest?.summary.videoTracks;
-                if (!tracks || tracks.length === 0) return 'N/A';
-                if (tracks.length === 1) return tracks[0].bitrateRange;
-
-                const bitrates = tracks
-                    .map((t) =>
-                        parseInt(t.bitrateRange.replace(/[^0-9]/g, ''), 10)
-                    )
-                    .filter(Boolean);
-                if (bitrates.length === 0) return 'N/A';
-
-                const min = Math.min(...bitrates);
-                const max = Math.max(...bitrates);
-                const unit = tracks[0].bitrateRange.includes('Mbps')
-                    ? 'Mbps'
-                    : 'kbps';
-
-                return `${min} - ${max} ${unit}`;
-            }),
-        },
-        {
-            label: 'Video Resolutions',
-            tooltip: 'List of unique video resolutions.',
-            isoRef: 'DASH: 5.3.7.2 / HLS: 4.3.4.2',
-            values: streams.map((s) =>
-                renderList([
-                    ...new Set(
-                        s.manifest?.summary.videoTracks.flatMap(
-                            (vt) => vt.resolutions
-                        )
-                    ),
-                ])
-            ),
-        },
-        {
-            label: 'Video Codecs',
-            tooltip: 'Unique video codecs found.',
-            isoRef: 'DASH: 5.3.7.2 / HLS: 4.3.4.2',
-            values: streams.map((s) =>
-                renderList([
-                    ...new Set(
-                        s.manifest?.summary.videoTracks.flatMap(
-                            (vt) => vt.codecs
-                        )
-                    ),
-                ])
-            ),
-        },
-        // --- Audio Details ---
-        {
-            label: '# Audio Tracks',
-            tooltip: 'Groups of audio tracks, often by language.',
-            isoRef: 'DASH: 5.3.3 / HLS: 4.3.4.1',
-            values: streams.map((s) =>
-                String(s.manifest?.summary.content.totalAudioTracks || 0)
-            ),
-        },
-        {
-            label: 'Audio Languages',
-            tooltip: 'Declared languages for audio tracks.',
-            isoRef: 'DASH: 5.3.3.2 / HLS: 4.3.4.1',
-            values: streams.map((s) => {
-                const languages = [
-                    ...new Set(
-                        s.manifest?.summary.audioTracks
-                            .map((at) => at.lang)
-                            .filter(Boolean)
-                    ),
-                ];
-                return languages.length > 0
-                    ? languages.join(', ')
-                    : 'Not Specified';
-            }),
-        },
-        {
-            label: 'Audio Codecs',
-            tooltip: 'Unique audio codecs.',
-            isoRef: 'DASH: 5.3.7.2 / HLS: 4.3.4.2',
-            values: streams.map((s) =>
-                renderList([
-                    ...new Set(
-                        s.manifest?.summary.audioTracks.flatMap(
-                            (at) => at.codecs
-                        )
-                    ),
-                ])
-            ),
-        },
-        // --- Accessibility & Metadata ---
-        {
-            label: '# of Text Tracks',
-            tooltip: 'Number of subtitle or caption tracks.',
-            isoRef: 'DASH: 5.3.3 / HLS: 4.3.4.1',
-            values: streams.map((s) =>
-                String(s.manifest?.summary.content.totalTextTracks || 0)
-            ),
-        },
-        {
-            label: 'Text Languages',
-            tooltip: 'Declared languages for subtitle/caption tracks.',
-            isoRef: 'DASH: 5.3.3.2 / HLS: 4.3.4.1',
-            values: streams.map((s) => {
-                const languages = [
-                    ...new Set(
-                        s.manifest?.summary.textTracks
-                            .map((tt) => tt.lang)
-                            .filter(Boolean)
-                    ),
-                ];
-                return languages.length > 0
-                    ? languages.join(', ')
-                    : 'Not Specified';
-            }),
-        },
-        {
-            label: 'Text Formats',
-            tooltip: 'MIME types or codecs for text tracks.',
-            isoRef: 'DASH: 5.3.7.2',
-            values: streams.map((s) =>
-                renderList([
-                    ...new Set(
-                        s.manifest?.summary.textTracks.flatMap(
-                            (tt) => tt.codecsOrMimeTypes
-                        )
-                    ),
-                ])
-            ),
-        },
-        {
-            label: 'Video Range',
-            tooltip: 'Dynamic range of the video content (SDR, PQ, HLG).',
-            isoRef: 'HLS 2nd Ed: 4.4.6.2',
-            values: streams.map((s) =>
-                valueOrNA(
-                    [
-                        ...new Set(
-                            s.manifest?.summary.videoTracks
-                                .map((vt) => vt.videoRange)
-                                .filter(Boolean)
-                        ),
-                    ].join(', ')
-                )
-            ),
-        },
-    ];
-
-    const groupByCategory = (points) => [
-        {
-            title: 'Manifest Properties',
-            points: points.slice(0, 5),
-        },
-        {
-            title: 'Content Overview',
-            points: points.slice(5, 7),
-        },
-        {
-            title: 'Video Details',
-            points: points.slice(7, 11),
-        },
-        {
-            title: 'Audio Details',
-            points: points.slice(11, 14),
-        },
-        {
-            title: 'Accessibility & Metadata',
-            points: points.slice(14, 18),
-        },
-    ];
-
-    return groupByCategory(comparisonPoints);
-}
diff --git a/js/ui/views/compliance/components/navigation.js b/js/ui/views/compliance/components/navigation.js
deleted file mode 100644
index fe5d2a8..0000000
--- a/js/ui/views/compliance/components/navigation.js
+++ /dev/null
@@ -1,48 +0,0 @@
-import { html } from 'lit-html';
-import { storeActions } from '../../../../app/store.js';
-
-export const navigationTemplate = (stream) => {
-    if (stream.manifest.type !== 'dynamic') return html``;
-
-    const { manifestUpdates, activeManifestUpdateIndex } = stream;
-    const updateCount = manifestUpdates.length;
-    const hasNewIssues =
-        manifestUpdates[0]?.hasNewIssues && activeManifestUpdateIndex > 0;
-
-    return html`
-        <div class="flex items-center space-x-2">
-            <button
-                @click=${() =>
-                    storeActions.navigateManifestUpdate(stream.id, 1)}
-                ?disabled=${activeManifestUpdateIndex >= updateCount - 1}
-                class="px-4 py-2 rounded-md font-bold transition duration-300 text-white bg-gray-600 hover:bg-gray-700 disabled:opacity-50"
-                title="Previous Update (Right Arrow)"
-            >
-                &lt;
-            </button>
-            <span class="text-gray-400 font-semibold w-24 text-center"
-                >Update
-                ${updateCount - activeManifestUpdateIndex}/${updateCount}</span
-            >
-            <button
-                @click=${() =>
-                    storeActions.navigateManifestUpdate(stream.id, -1)}
-                ?disabled=${activeManifestUpdateIndex <= 0}
-                class="relative px-4 py-2 rounded-md font-bold transition duration-300 text-white bg-gray-600 hover:bg-gray-700 disabled:opacity-50"
-                title="Next Update (Left Arrow)"
-            >
-                &gt;
-                ${hasNewIssues
-                    ? html`<span class="absolute -top-1 -right-1 flex h-3 w-3">
-                          <span
-                              class="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"
-                          ></span>
-                          <span
-                              class="relative inline-flex rounded-full h-3 w-3 bg-red-500"
-                          ></span>
-                      </span>`
-                    : ''}
-            </button>
-        </div>
-    `;
-};
diff --git a/js/ui/views/compliance/components/renderer.js b/js/ui/views/compliance/components/renderer.js
deleted file mode 100644
index 567bc4f..0000000
--- a/js/ui/views/compliance/components/renderer.js
+++ /dev/null
@@ -1,290 +0,0 @@
-import { html } from 'lit-html';
-import { unsafeHTML } from 'lit-html/directives/unsafe-html.js';
-import {
-    highlightDash,
-    highlightHls,
-} from '../../../shared/syntax-highlighter.js';
-
-const highlightColors = {
-    fail: 'bg-red-900/60',
-    warn: 'bg-yellow-900/60',
-    pass: 'bg-green-900/50',
-};
-
-const formatTooltipContent = (results, filter) => {
-    let filteredResults = results;
-    if (filter !== 'all') {
-        filteredResults = results.filter((r) => r.status === filter);
-    }
-
-    if (filteredResults.length === 0) {
-        return { b64TooltipHtml: '' };
-    }
-
-    const tooltipHtml = filteredResults
-        .map((r, index) => {
-            const statusClass = {
-                fail: 'text-red-300',
-                warn: 'text-yellow-300',
-                pass: 'text-green-300',
-                info: 'text-blue-300',
-            }[r.status];
-            const hr = index > 0 ? '<hr class="border-gray-600 my-2">' : '';
-            return `${hr}<div class="text-left">
-            <p class="font-bold ${statusClass}">[${r.status.toUpperCase()}] ${r.text}</p>
-            <p class="text-xs text-gray-300 mt-1">${r.details}</p>
-            <p class="text-xs text-gray-500 font-mono mt-2">${r.isoRef}</p>
-        </div>`;
-        })
-        .join('');
-
-    try {
-        return { b64TooltipHtml: btoa(tooltipHtml) };
-    } catch (e) {
-        console.error('Failed to encode tooltip', e);
-        return { b64TooltipHtml: '' };
-    }
-};
-
-const renderDashNode = (
-    tagName,
-    node,
-    complianceResults,
-    path,
-    depth,
-    lineCounter,
-    activeFilter
-) => {
-    if (typeof node !== 'object' || node === null) {
-        return [];
-    }
-
-    const indent = '  '.repeat(depth);
-
-    const resultsForPath = complianceResults.filter(
-        (r) => r.location.path === path
-    );
-    let highestSeverityResult = null;
-    let highlightClass = '';
-    const elementId = `loc-path-${path.replace(/[[].]/g, '-')}`;
-
-    if (resultsForPath.length > 0) {
-        const severityOrder = { fail: 0, warn: 1, info: 2, pass: 3 };
-        highestSeverityResult = resultsForPath.reduce((acc, r) => {
-            if (!acc || severityOrder[r.status] < severityOrder[acc.status]) {
-                return r;
-            }
-            return acc;
-        });
-
-        if (
-            activeFilter === 'all' ||
-            activeFilter === highestSeverityResult.status
-        ) {
-            highlightClass = highestSeverityResult
-                ? highlightColors[highestSeverityResult.status]
-                : '';
-        }
-
-        resultsForPath.forEach((r) => {
-            if (!r.location.startLine) {
-                r.location.startLine = lineCounter.count;
-            }
-        });
-    }
-
-    const attributes = node[':@'] || {};
-    const textContent = node['#text'] || null;
-    const childKeys = Object.keys(node).filter(
-        (key) => key !== ':@' && key !== '#text'
-    );
-    const hasChildren = childKeys.length > 0 || textContent;
-
-    const attrsString = Object.entries(attributes)
-        .map(([key, value]) => ` ${key}="${value}"`)
-        .join('');
-    const openingTagString = `<${tagName}${attrsString}${!hasChildren ? ' /' : ''}>`;
-    const highlightedOpeningTag = highlightDash(openingTagString);
-
-    const templates = [];
-
-    const { b64TooltipHtml } = formatTooltipContent(
-        resultsForPath,
-        activeFilter
-    );
-
-    templates.push(
-        html`<div class="flex">
-            <span
-                class="text-right text-gray-500 pr-4 select-none flex-shrink-0 w-12"
-                >${lineCounter.count++}</span
-            >
-            <span
-                id=${elementId}
-                data-status=${highestSeverityResult?.status}
-                data-tooltip-html-b64=${b64TooltipHtml}
-                class="compliance-highlight flex-grow whitespace-pre-wrap break-all ${highlightClass}"
-                >${unsafeHTML(indent)}${unsafeHTML(highlightedOpeningTag)}</span
-            >
-        </div>`
-    );
-
-    if (hasChildren) {
-        if (textContent) {
-            templates.push(
-                html`<div class="flex">
-                    <span class="text-right text-gray-500 pr-4 select-none w-12"
-                        >${lineCounter.count++}</span
-                    >
-                    <span class="flex-grow whitespace-pre-wrap break-all"
-                        >${unsafeHTML(indent + '  ')}<span class="text-gray-200"
-                            >${textContent}</span
-                        ></span
-                    >
-                </div>`
-            );
-        }
-
-        childKeys.forEach((childTagName) => {
-            const childValue = node[childTagName];
-            if (Array.isArray(childValue)) {
-                childValue.forEach((item, index) => {
-                    templates.push(
-                        ...renderDashNode(
-                            childTagName,
-                            item,
-                            complianceResults,
-                            `${path}.${childTagName}[${index}]`,
-                            depth + 1,
-                            lineCounter,
-                            activeFilter
-                        )
-                    );
-                });
-            } else if (typeof childValue === 'object') {
-                templates.push(
-                    ...renderDashNode(
-                        childTagName,
-                        childValue,
-                        complianceResults,
-                        `${path}.${childTagName}[0]`,
-                        depth + 1,
-                        lineCounter,
-                        activeFilter
-                    )
-                );
-            }
-        });
-
-        const closingTagHtml = highlightDash(`</${tagName}>`);
-        templates.push(
-            html`<div class="flex">
-                <span
-                    class="text-right text-gray-500 pr-4 select-none flex-shrink-0 w-12"
-                    >${lineCounter.count++}</span
-                >
-                <span class="flex-grow whitespace-pre-wrap break-all"
-                    >${unsafeHTML(indent)}${unsafeHTML(closingTagHtml)}</span
-                >
-            </div>`
-        );
-    }
-
-    return templates;
-};
-
-export const manifestViewTemplate = (
-    rawManifest,
-    protocol,
-    results,
-    serializedManifest,
-    activeFilter
-) => {
-    if (protocol === 'hls') {
-        const lines = rawManifest.split('\n');
-        const lineResults = new Map();
-        results.forEach((result) => {
-            if (result.location.startLine) {
-                for (
-                    let i = result.location.startLine;
-                    i <= (result.location.endLine || result.location.startLine);
-                    i++
-                ) {
-                    if (!lineResults.has(i)) lineResults.set(i, []);
-                    lineResults.get(i).push(result);
-                }
-            }
-        });
-        return html`${lines.map((line, index) => {
-            const lineNumber = index + 1;
-            const resultsForLine = lineResults.get(lineNumber) || [];
-            const highestSeverityResult = resultsForLine.reduce((acc, r) => {
-                if (!acc) return r;
-                if (r.status === 'fail') return r;
-                if (r.status === 'warn' && acc.status !== 'fail') return r;
-                return acc;
-            }, null);
-
-            const { b64TooltipHtml } = formatTooltipContent(
-                resultsForLine,
-                activeFilter
-            );
-
-            const highlightClass =
-                highestSeverityResult &&
-                (activeFilter === 'all' ||
-                    activeFilter === highestSeverityResult.status)
-                    ? highlightColors[highestSeverityResult.status]
-                    : '';
-
-            const locationId = `loc-line-${lineNumber}`;
-
-            return html`<div class="flex">
-                <span class="text-right text-gray-500 pr-4 select-none w-12"
-                    >${lineNumber}</span
-                >
-                <span
-                    id=${locationId}
-                    data-status=${highestSeverityResult?.status}
-                    data-tooltip-html-b64=${b64TooltipHtml}
-                    class="compliance-highlight flex-grow whitespace-pre-wrap break-all ${highlightClass}"
-                    >${unsafeHTML(highlightHls(line))}</span
-                >
-            </div>`;
-        })}`;
-    }
-
-    // DASH Rendering Logic
-    if (!serializedManifest || typeof serializedManifest !== 'object') {
-        return html`<div class="text-red-400">
-            Error rendering DASH manifest object.
-        </div>`;
-    }
-
-    const lineCounter = { count: 1 };
-    const xmlDeclaration = rawManifest.match(/<\?xml.*?\?>/);
-
-    const templates = renderDashNode(
-        'MPD',
-        serializedManifest,
-        results,
-        'MPD[0]',
-        0,
-        lineCounter,
-        activeFilter
-    );
-
-    return html`
-        ${xmlDeclaration
-            ? html`<div class="flex">
-                  <span class="text-right text-gray-500 pr-4 select-none w-12"
-                      >${lineCounter.count++}</span
-                  >
-                  <span class="flex-grow whitespace-pre-wrap break-all"
-                      >${unsafeHTML(highlightDash(xmlDeclaration[0]))}</span
-                  >
-              </div>`
-            : ''}
-        ${templates}
-    `;
-};
diff --git a/js/ui/views/compliance/components/sidebar.js b/js/ui/views/compliance/components/sidebar.js
deleted file mode 100644
index e4e975b..0000000
--- a/js/ui/views/compliance/components/sidebar.js
+++ /dev/null
@@ -1,135 +0,0 @@
-import { html } from 'lit-html';
-
-export function handleCommentHover(e) {
-    const card = /** @type {HTMLElement} */ (e.currentTarget);
-    const locationId = card.dataset.locationId;
-    document
-        .querySelectorAll('.compliance-highlight')
-        .forEach((el) =>
-            el.classList.remove(
-                'bg-purple-500/30',
-                'outline',
-                'outline-1',
-                'outline-purple-400',
-                '-outline-offset-1'
-            )
-        );
-    const target = document.getElementById(locationId);
-    if (target) {
-        target.classList.add(
-            'bg-purple-500/30',
-            'outline',
-            'outline-1',
-            'outline-purple-400',
-            '-outline-offset-1'
-        );
-    }
-}
-
-export function handleCommentLeave() {
-    document
-        .querySelectorAll('.compliance-highlight')
-        .forEach((el) =>
-            el.classList.remove(
-                'bg-purple-500/30',
-                'outline',
-                'outline-1',
-                'outline-purple-400',
-                '-outline-offset-1'
-            )
-        );
-}
-
-export function handleCommentClick(e) {
-    const card = /** @type {HTMLElement} */ (e.currentTarget);
-    const locationId = card.dataset.locationId;
-    const target = document.getElementById(locationId);
-    if (target) {
-        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
-    }
-}
-
-const commentCard = (result) => {
-    const statusClasses = {
-        fail: 'border-red-500',
-        warn: 'border-yellow-500',
-        pass: 'border-green-500',
-        info: 'border-blue-500',
-    };
-
-    const locationId = result.location.path
-        ? `loc-path-${result.location.path.replace(/[[].]/g, '-')}`
-        : `loc-line-${result.location.startLine}`;
-
-    return html`
-        <div
-            class="compliance-comment-card bg-gray-800 p-3 rounded-lg border-l-4 ${statusClasses[
-                result.status
-            ]} status-${result.status} cursor-pointer hover:bg-gray-700/50"
-            data-location-id="${locationId}"
-            @mouseover=${handleCommentHover}
-            @mouseleave=${handleCommentLeave}
-            @click=${handleCommentClick}
-        >
-            <p class="font-semibold text-sm text-gray-200">
-                ${result.location.startLine
-                    ? html`<span class="text-xs text-gray-500 mr-2"
-                          >L${result.location.startLine}</span
-                      >`
-                    : ''}
-                ${result.text}
-            </p>
-            <p class="text-xs text-gray-400 mt-1">${result.details}</p>
-            <p class="text-xs text-gray-500 font-mono mt-2">${result.isoRef}</p>
-        </div>
-    `;
-};
-
-export const sidebarTemplate = (
-    complianceResults,
-    activeFilter,
-    onFilterClick
-) => {
-    const counts = {
-        pass: 0,
-        warn: 0,
-        fail: 0,
-        info: 0,
-        all: complianceResults.length,
-    };
-    complianceResults.forEach(
-        (r) => (counts[r.status] = (counts[r.status] || 0) + 1)
-    );
-
-    const filteredResults =
-        activeFilter === 'all'
-            ? complianceResults
-            : complianceResults.filter((r) => r.status === activeFilter);
-
-    const filterButton = (filter, label, count) =>
-        html` <button
-            class="px-3 py-1 rounded-full text-xs transition-colors duration-200 ${activeFilter ===
-            filter
-                ? 'bg-blue-600 text-white font-semibold'
-                : 'bg-gray-700 text-gray-300'}"
-            data-filter="${filter}"
-            @click=${() => onFilterClick(filter)}
-        >
-            ${label} (${count})
-        </button>`;
-
-    return html`
-        <!-- FIX: Filter bar is now a non-growing element -->
-        <div
-            class="compliance-filter-bar flex-shrink-0 flex flex-wrap justify-center sm:justify-start items-center gap-2 mb-4 p-2 bg-gray-900/50 rounded-md sticky top-0 z-20 border-b border-gray-700"
-        >
-            ${filterButton('all', 'All', counts.all)}
-            ${filterButton('fail', 'Errors', counts.fail)}
-            ${filterButton('warn', 'Warnings', counts.warn)}
-        </div>
-        <!-- FIX: This list container now grows to fill space and scrolls independently -->
-        <div class="space-y-2 flex-grow min-h-0 overflow-y-auto">
-            ${filteredResults.map(commentCard)}
-        </div>
-    `;
-};
diff --git a/js/ui/views/compliance/components/standard-selector.js b/js/ui/views/compliance/components/standard-selector.js
deleted file mode 100644
index 6458d7b..0000000
--- a/js/ui/views/compliance/components/standard-selector.js
+++ /dev/null
@@ -1,55 +0,0 @@
-import { html } from 'lit-html';
-
-/**
- * Renders a dropdown to select the standard version for HLS compliance/feature analysis.
- * @param {object} options
- * @param {number} options.selectedVersion - The currently selected version number.
- * @param {Function} options.onVersionChange - The callback function to execute on change.
- * @returns {import('lit-html').TemplateResult}
- */
-export const standardSelectorTemplate = ({
-    selectedVersion,
-    onVersionChange,
-}) => {
-    // HLS versions based on IETF RFCs and Apple's specifications
-    const versions = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];
-    const versionLabels = {
-        1: 'v1 (Baseline)',
-        4: 'v4 (Media Groups, Byte Range)',
-        7: 'v7 (RFC 8216)',
-        8: 'v8 (Variable Sub, Bitrate Hint)',
-        9: 'v9 (LL-HLS)',
-        10: 'v10 (Stable IDs)',
-        11: 'v11 (Content Steering)',
-        12: 'v12 (RFC 8216bis)',
-        13: 'v13 (WWDC25 Draft)',
-    };
-
-    const handleChange = (e) => {
-        const newVersion = parseInt(e.target.value, 10);
-        onVersionChange(newVersion);
-    };
-
-    return html`
-        <div class="flex items-center gap-2">
-            <label
-                for="standard-version-selector"
-                class="text-sm font-medium text-gray-400"
-                >HLS Standard:</label
-            >
-            <select
-                id="standard-version-selector"
-                class="bg-gray-700 text-white rounded-md border-gray-600 p-2"
-                @change=${handleChange}
-                .value=${String(selectedVersion)}
-            >
-                ${versions.map(
-                    (v) =>
-                        html`<option value="${v}">
-                            ${versionLabels[v] || `v${v}`}
-                        </option>`
-                )}
-            </select>
-        </div>
-    `;
-};
diff --git a/js/ui/views/compliance/index.js b/js/ui/views/compliance/index.js
deleted file mode 100644
index 01df48d..0000000
--- a/js/ui/views/compliance/index.js
+++ /dev/null
@@ -1,106 +0,0 @@
-import { html } from 'lit-html';
-import { manifestViewTemplate } from './components/renderer.js';
-import { sidebarTemplate } from './components/sidebar.js';
-import { navigationTemplate } from './components/navigation.js';
-import { standardSelectorTemplate } from './components/standard-selector.js';
-import { renderApp } from '../../mainRenderer.js';
-import { runChecks } from '../../../domain/compliance/engine.js';
-
-let activeFilter = 'all';
-let activeStandardVersion = 13; // Default to the latest HLS version
-
-function handleFilterClick(newFilter) {
-    if (newFilter === activeFilter) return;
-    activeFilter = newFilter;
-    renderApp();
-}
-
-function handleVersionChange(newVersion) {
-    if (newVersion === activeStandardVersion) return;
-    activeStandardVersion = newVersion;
-    renderApp(); // Re-render to re-run checks with the new version
-}
-
-export function getComplianceReportTemplate(stream) {
-    if (!stream || !stream.manifest) return html``;
-
-    const { manifestUpdates, activeManifestUpdateIndex, protocol } = stream;
-    const currentUpdate = manifestUpdates[activeManifestUpdateIndex];
-
-    if (!currentUpdate) {
-        return html`<p class="text-gray-400 p-4">
-            Awaiting first manifest update with compliance data...
-        </p>`;
-    }
-
-    // Determine the context for compliance checks
-    let manifestObjectForChecks;
-    let complianceCheckContext = {};
-
-    if (protocol === 'hls') {
-        manifestObjectForChecks = stream.manifest;
-        complianceCheckContext.standardVersion = activeStandardVersion;
-    } else if (protocol === 'dash') {
-        manifestObjectForChecks = currentUpdate.serializedManifest;
-        // The DASH compliance engine will automatically extract profiles from the manifest
-    } else {
-        return html`<p class="text-yellow-400 p-4">
-            Compliance report not available for unknown protocol.
-        </p>`;
-    }
-
-    // Re-run checks on the fly based on the selected version/profiles
-    const complianceResults = runChecks(
-        manifestObjectForChecks,
-        protocol,
-        complianceCheckContext
-    );
-
-    const { rawManifest, serializedManifest } = currentUpdate;
-
-    const selector =
-        protocol === 'hls'
-            ? standardSelectorTemplate({
-                  selectedVersion: activeStandardVersion,
-                  onVersionChange: handleVersionChange,
-              })
-            : ''; // No selector for DASH
-
-    return html`
-        <div
-            class="flex flex-col sm:flex-row justify-between items-center mb-4 flex-shrink-0 gap-4"
-        >
-            <h3 class="text-xl font-bold text-center sm:text-left">
-                Interactive Compliance Report
-            </h3>
-            <div
-                class="flex items-center flex-wrap justify-center sm:justify-end gap-4"
-            >
-                ${selector} ${navigationTemplate(stream)}
-            </div>
-        </div>
-
-        <div class="lg:grid lg:grid-cols-[1fr_450px] lg:gap-6 relative h-full">
-            <div
-                class="compliance-manifest-view bg-slate-800 rounded-lg p-2 sm:p-4 font-mono text-sm leading-relaxed overflow-auto mb-6 lg:mb-0 h-full"
-            >
-                ${manifestViewTemplate(
-                    rawManifest,
-                    stream.protocol,
-                    complianceResults,
-                    serializedManifest,
-                    activeFilter
-                )}
-            </div>
-            <div class="lg:sticky lg:top-4 h-fit">
-                <div class="flex flex-col h-96 lg:max-h-[calc(100vh-12rem)]">
-                    ${sidebarTemplate(
-                        complianceResults,
-                        activeFilter,
-                        handleFilterClick
-                    )}
-                </div>
-            </div>
-        </div>
-    `;
-}
diff --git a/js/ui/views/feature-analysis/index.js b/js/ui/views/feature-analysis/index.js
deleted file mode 100644
index af784cb..0000000
--- a/js/ui/views/feature-analysis/index.js
+++ /dev/null
@@ -1,204 +0,0 @@
-import { html } from 'lit-html';
-import { unsafeHTML } from 'lit-html/directives/unsafe-html.js';
-import { tooltipTriggerClasses } from '../../../shared/constants.js';
-import { createFeatureViewModel } from '../../../domain/feature-analysis/analyzer.js';
-import { standardSelectorTemplate } from '../compliance/components/standard-selector.js';
-import { renderApp } from '../../mainRenderer.js';
-
-let activeStandardVersion = 13;
-
-function handleVersionChange(newVersion) {
-    if (newVersion === activeStandardVersion) return;
-    activeStandardVersion = newVersion;
-    renderApp(); // Re-render to re-filter features
-}
-
-const featureCardTemplate = (feature) => {
-    const badge = feature.used
-        ? html`<span
-              class="text-xs font-semibold px-2 py-1 bg-green-800 text-green-200 rounded-full"
-              >Used</span
-          >`
-        : html`<span
-              class="text-xs font-semibold px-2 py-1 bg-gray-600 text-gray-300 rounded-full"
-              >Not Used</span
-          >`;
-
-    return html`
-        <div
-            class="grid grid-cols-[100px_1fr] items-center bg-gray-800 p-3 rounded-lg border border-gray-700"
-        >
-            <div class="text-center">${badge}</div>
-            <div>
-                <p
-                    class="font-medium ${tooltipTriggerClasses}"
-                    data-tooltip="${feature.desc}"
-                    data-iso="${feature.isoRef}"
-                >
-                    ${feature.name}
-                    <span class="text-xs text-gray-500"
-                        >(v${feature.version}+)</span
-                    >
-                </p>
-                <p class="text-xs text-gray-400 italic mt-1 font-mono">
-                    ${unsafeHTML(feature.details)}
-                </p>
-            </div>
-        </div>
-    `;
-};
-
-const categoryTemplate = (category, categoryFeatures) => html`
-    <div class="mt-8">
-        <h4 class="text-lg font-semibold text-gray-300 mb-3">${category}</h4>
-        <div class="grid gap-4 grid-cols-[repeat(auto-fit,minmax(400px,1fr))]">
-            ${categoryFeatures.map((feature) => featureCardTemplate(feature))}
-        </div>
-    </div>
-`;
-
-export function getFeaturesAnalysisTemplate(stream) {
-    if (!stream) return html`<p class="warn">No stream loaded to display.</p>`;
-
-    const { results, manifestCount } = stream.featureAnalysis;
-    const viewModel = createFeatureViewModel(
-        results,
-        stream.protocol,
-        activeStandardVersion
-    );
-
-    const groupedFeatures = viewModel.reduce((acc, feature) => {
-        if (!acc[feature.category]) {
-            acc[feature.category] = [];
-        }
-        acc[feature.category].push(feature);
-        return acc;
-    }, {});
-
-    const selector =
-        stream.protocol === 'hls'
-            ? standardSelectorTemplate({
-                  selectedVersion: activeStandardVersion,
-                  onVersionChange: handleVersionChange,
-              })
-            : '';
-
-    const getStatusIndicator = () => {
-        if (stream.manifest?.type !== 'dynamic') {
-            return html`
-                <div
-                    class="bg-gray-800 border border-gray-700 rounded-lg p-4 flex items-center gap-4 mb-6"
-                >
-                    <div
-                        class="w-12 h-12 rounded-full bg-gray-700 flex items-center justify-center flex-shrink-0"
-                    >
-                        <svg
-                            xmlns="http://www.w3.org/2000/svg"
-                            class="h-6 w-6 text-gray-400"
-                            fill="none"
-                            viewBox="0 0 24 24"
-                            stroke="currentColor"
-                        >
-                            <path
-                                stroke-linecap="round"
-                                stroke-linejoin="round"
-                                stroke-width="2"
-                                d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
-                            />
-                        </svg>
-                    </div>
-                    <div>
-                        <p class="font-semibold text-gray-200">
-                            Static Manifest (VOD)
-                        </p>
-                        <p class="text-sm text-gray-400">
-                            Feature analysis is based on the single, initial
-                            manifest load.
-                        </p>
-                    </div>
-                </div>
-            `;
-        }
-
-        const isPolling = stream.isPolling;
-        const statusText = isPolling ? 'Polling Active' : 'Polling Paused';
-        const statusColor = isPolling ? 'text-cyan-400' : 'text-yellow-400';
-        const iconColor = isPolling ? 'bg-cyan-500' : 'bg-yellow-500';
-
-        return html`
-            <div
-                class="bg-gray-800 border border-gray-700 rounded-lg p-4 flex items-center gap-4 mb-6"
-            >
-                <div
-                    class="w-12 h-12 rounded-full bg-gray-700 flex items-center justify-center flex-shrink-0 relative"
-                >
-                    ${isPolling
-                        ? html`<div
-                              class="absolute inset-0 rounded-full ${iconColor} opacity-75 animate-ping"
-                          ></div>`
-                        : ''}
-                    <div
-                        class="absolute inset-1 rounded-full ${iconColor} opacity-50"
-                    ></div>
-                    <svg
-                        xmlns="http://www.w3.org/2000/svg"
-                        class="h-6 w-6 text-white relative"
-                        fill="none"
-                        viewBox="0 0 24 24"
-                        stroke="currentColor"
-                    >
-                        <path
-                            stroke-linecap="round"
-                            stroke-linejoin="round"
-                            stroke-width="2"
-                            d="M4 4v5h5M20 20v-5h-5"
-                        />
-                        <path
-                            stroke-linecap="round"
-                            stroke-linejoin="round"
-                            stroke-width="2"
-                            d="M4 9a9 9 0 0114.65-5.65M20 15a9 9 0 01-14.65 5.65"
-                        />
-                    </svg>
-                </div>
-                <div class="flex-grow">
-                    <p class="font-semibold text-gray-200">
-                        Live Analysis:
-                        <span class="font-bold ${statusColor}"
-                            >${statusText}</span
-                        >
-                    </p>
-                    <p class="text-sm text-gray-400">
-                        New features will be detected automatically as the
-                        manifest updates.
-                    </p>
-                </div>
-                <div class="text-right flex-shrink-0">
-                    <div
-                        class="text-xs text-gray-400 uppercase font-semibold tracking-wider"
-                    >
-                        Versions Analyzed
-                    </div>
-                    <div class="text-3xl font-bold text-white">
-                        ${manifestCount}
-                    </div>
-                </div>
-            </div>
-        `;
-    };
-
-    return html`
-        <div class="flex items-center justify-between mb-2">
-            <h3 class="text-xl font-bold">Feature Usage Analysis</h3>
-            ${selector}
-        </div>
-        ${getStatusIndicator()}
-        <p class="text-sm text-gray-500 mb-4">
-            A breakdown of key features detected across all analyzed manifest
-            versions.
-        </p>
-        ${Object.entries(groupedFeatures).map(([category, features]) =>
-            categoryTemplate(category, features)
-        )}
-    `;
-}
diff --git a/js/ui/views/integrators-report/components/dash-report.js b/js/ui/views/integrators-report/components/dash-report.js
deleted file mode 100644
index 9471077..0000000
--- a/js/ui/views/integrators-report/components/dash-report.js
+++ /dev/null
@@ -1,182 +0,0 @@
-import { html } from 'lit-html';
-import {
-    statCardTemplate,
-    listCardTemplate,
-    sectionTemplate,
-} from './shared.js';
-
-export const dashReportTemplate = (viewModel) => {
-    const { network, timing, security, integration } = viewModel;
-
-    const networkContent = html`
-        ${listCardTemplate({
-            label: 'Manifest/Playlist Hostnames',
-            items: network.manifestHostnames,
-            tooltip:
-                'All servers that will be contacted to fetch manifest or playlist files. Required for firewall rules.',
-        })}
-        ${listCardTemplate({
-            label: 'Media Segment Hostnames',
-            items: network.mediaSegmentHostnames,
-            tooltip:
-                'All servers from which media segments will be fetched. This can differ from manifest hostnames.',
-        })}
-        ${statCardTemplate({
-            label: 'Avg. Segment Request Rate',
-            value: network.avgSegmentRequestRate
-                ? `1 every ${network.avgSegmentRequestRate.toFixed(2)}s`
-                : 'N/A',
-            tooltip:
-                'The average frequency of media segment requests from the client.',
-        })}
-        ${statCardTemplate({
-            label: 'Avg. Segment Size',
-            value: network.avgSegmentSize
-                ? `${(network.avgSegmentSize / 1024).toFixed(2)} KB`
-                : 'N/A',
-            tooltip:
-                'The average size of each media segment, useful for estimating network load.',
-        })}
-    `;
-
-    const timingContent = timing
-        ? html`
-              ${statCardTemplate({
-                  label: 'Recommended Polling Interval',
-                  value: timing.pollingInterval
-                      ? `${timing.pollingInterval}s`
-                      : 'N/A',
-                  tooltip:
-                      'The safe interval for a client to reload the manifest for updates without overloading the server.',
-                  isoRef: 'DASH: 5.3.1.2',
-              })}
-              ${statCardTemplate({
-                  label: 'DVR / Time-Shift Window',
-                  value: timing.dvrWindow ? `${timing.dvrWindow}s` : 'N/A',
-                  tooltip:
-                      'The available duration for seeking backward in the live stream.',
-                  isoRef: 'DASH: 5.3.1.2',
-              })}
-              ${statCardTemplate({
-                  label: 'Low-Latency Mode',
-                  value: timing.lowLatency.active
-                      ? `Yes (${timing.lowLatency.mechanism})`
-                      : 'No',
-                  isCode: false,
-                  tooltip:
-                      'Indicates if low-latency streaming features are active, requiring a different player configuration.',
-              })}
-              ${timing.lowLatency.active
-                  ? statCardTemplate({
-                        label: 'Target Latency',
-                        value: timing.targetLatency
-                            ? `${timing.targetLatency / 1000}s`
-                            : 'Not Specified',
-                        tooltip:
-                            'The service provider-advertised target latency, providing a concrete goal for player tuning.',
-                        isoRef: 'DASH: Annex K.3.2',
-                    })
-                  : ''}
-              ${timing.lowLatency.active
-                  ? statCardTemplate({
-                        label: 'Chunk Duration',
-                        value: timing.chunkDuration
-                            ? `${timing.chunkDuration}s`
-                            : 'N/A',
-                        tooltip:
-                            'The maximum duration of a low-latency sub-segment (chunk).',
-                        isoRef: 'DASH: 5.3.1.2',
-                    })
-                  : ''}
-          `
-        : html`<div class="col-span-full text-sm text-gray-400">
-              Timing report is only applicable for Live streams.
-          </div>`;
-
-    const securityContent = html`
-        ${statCardTemplate({
-            label: 'Encryption Status',
-            value: security.isEncrypted ? 'Yes' : 'No',
-            isCode: false,
-            tooltip:
-                'Indicates if the stream is encrypted and requires a decryption pipeline.',
-        })}
-        ${listCardTemplate({
-            label: 'DRM Systems',
-            items: security.drmSystems.map((s) => `${s.name} (${s.uuid})`),
-            tooltip:
-                'Detected DRM systems and their unique schemeIdUris, needed for EME APIs.',
-            isoRef: 'DASH: 5.8.4.1',
-        })}
-        ${listCardTemplate({
-            label: 'Default Key IDs (KIDs)',
-            items: security.defaultKIDs,
-            tooltip:
-                'The default Key IDs found in the manifest, crucial for debugging decryption.',
-            isoRef: 'ISO/IEC 23001-7',
-        })}
-        ${listCardTemplate({
-            label: 'EME Robustness Levels',
-            items: security.emeRobustnessLevels,
-            tooltip:
-                'Required EME robustness levels for playback (e.g., for hardware vs. software DRM).',
-            isoRef: 'DASH: 5.8.4.1.4',
-        })}
-    `;
-
-    const integrationContent = html`
-        ${statCardTemplate({
-            label: 'Required DASH Profiles',
-            value: integration.requiredDashProfiles,
-            tooltip:
-                'The DASH profiles the player must support to be compatible.',
-            isoRef: 'DASH: 8.1',
-        })}
-        ${statCardTemplate({
-            label: 'Segment Container Format',
-            value: integration.segmentContainerFormat,
-            tooltip:
-                'The container format of media segments (e.g., ISOBMFF, MPEG-2 TS).',
-        })}
-        ${statCardTemplate({
-            label: 'Segment Alignment',
-            value: integration.segmentAlignment ? 'Yes' : 'No',
-            isCode: false,
-            tooltip:
-                'Indicates if segments are aligned across Representations, simplifying ABR switching.',
-            isoRef: 'DASH: 5.3.3.2',
-        })}
-        ${statCardTemplate({
-            label: 'Trick Play Support',
-            value: integration.trickPlaySupport ? 'Yes' : 'No',
-            isCode: false,
-            tooltip:
-                'Indicates if dedicated I-Frame tracks are available for fast-forward/rewind.',
-            isoRef: 'DASH: 5.3.6',
-        })}
-        ${listCardTemplate({
-            label: 'Subtitle Formats',
-            items: integration.subtitleFormats,
-            tooltip:
-                'The specific formats used for subtitles or captions (e.g., WebVTT, IMSC1).',
-        })}
-        ${listCardTemplate({
-            label: 'Required Codecs',
-            items: integration.requiredCodecs,
-            tooltip:
-                'A consolidated list of all unique codecs the player must support.',
-        })}
-    `;
-
-    return html`
-        <div class="space-y-8">
-            ${sectionTemplate('Network & Delivery Profile', networkContent)}
-            ${sectionTemplate('Timing & Update Strategy (Live)', timingContent)}
-            ${sectionTemplate('Security & Encryption', securityContent)}
-            ${sectionTemplate(
-                'Player Integration Requirements',
-                integrationContent
-            )}
-        </div>
-    `;
-};
diff --git a/js/ui/views/integrators-report/components/hls-report.js b/js/ui/views/integrators-report/components/hls-report.js
deleted file mode 100644
index f13925d..0000000
--- a/js/ui/views/integrators-report/components/hls-report.js
+++ /dev/null
@@ -1,200 +0,0 @@
-import { html } from 'lit-html';
-import {
-    statCardTemplate,
-    listCardTemplate,
-    sectionTemplate,
-} from './shared.js';
-
-export const hlsReportTemplate = (viewModel) => {
-    const { network, timing, security, integration } = viewModel;
-
-    const networkContent = html`
-        ${listCardTemplate({
-            label: 'Manifest/Playlist Hostnames',
-            items: network.manifestHostnames,
-            tooltip:
-                'All servers that will be contacted to fetch manifest or playlist files. Required for firewall rules.',
-        })}
-        ${listCardTemplate({
-            label: 'Media Segment Hostnames',
-            items: network.mediaSegmentHostnames,
-            tooltip:
-                'All servers from which media segments will be fetched. This can differ from manifest hostnames.',
-        })}
-        ${listCardTemplate({
-            label: 'Key/License Hostnames',
-            items: network.keyLicenseHostnames,
-            tooltip:
-                'All servers contacted for decryption keys. These are high-priority endpoints for network configuration.',
-        })}
-        ${statCardTemplate({
-            label: 'Avg. Segment Request Rate',
-            value: network.avgSegmentRequestRate
-                ? `1 every ${network.avgSegmentRequestRate.toFixed(2)}s`
-                : 'N/A',
-            tooltip:
-                'The average frequency of media segment requests from the client.',
-        })}
-        ${statCardTemplate({
-            label: 'Avg. Segment Size',
-            value: network.avgSegmentSize
-                ? `${(network.avgSegmentSize / 1024).toFixed(2)} KB`
-                : 'N/A',
-            tooltip:
-                'The average size of each media segment, useful for estimating network load.',
-        })}
-        ${network.contentSteering
-            ? statCardTemplate({
-                  label: 'Content Steering Server',
-                  value: network.contentSteering.serverUri,
-                  tooltip:
-                      'The URI of the Content Steering manifest for server-side CDN redundancy and load balancing.',
-                  isoRef: 'HLS: 4.4.6.6',
-              })
-            : ''}
-    `;
-
-    const timingContent = timing
-        ? html`
-              ${statCardTemplate({
-                  label: 'Recommended Polling Interval',
-                  value: timing.pollingInterval
-                      ? `${timing.pollingInterval}s`
-                      : 'N/A',
-                  tooltip:
-                      'The safe interval for a client to reload the manifest for updates without overloading the server.',
-                  isoRef: 'HLS: 6.3.4',
-              })}
-              ${statCardTemplate({
-                  label: 'DVR / Time-Shift Window',
-                  value: timing.dvrWindow
-                      ? `${timing.dvrWindow.toFixed(2)}s`
-                      : 'N/A',
-                  tooltip:
-                      'The available duration for seeking backward in the live stream.',
-              })}
-              ${statCardTemplate({
-                  label: 'Low-Latency Mode',
-                  value: timing.lowLatency.active
-                      ? `Yes (${timing.lowLatency.mechanism})`
-                      : 'No',
-                  isCode: false,
-                  tooltip:
-                      'Indicates if low-latency streaming features are active, requiring a different player configuration.',
-              })}
-              ${timing.lowLatency.active
-                  ? statCardTemplate({
-                        label: 'Target Latency',
-                        value: timing.targetLatency
-                            ? `${timing.targetLatency}s`
-                            : 'Not Specified',
-                        tooltip:
-                            'The server-advertised target latency (PART-HOLD-BACK), providing a concrete goal for player tuning.',
-                        isoRef: 'HLS: 4.4.3.8',
-                    })
-                  : ''}
-              ${timing.lowLatency.active
-                  ? statCardTemplate({
-                        label: 'Part Target Duration',
-                        value: timing.partTargetDuration
-                            ? `${timing.partTargetDuration}s`
-                            : 'N/A',
-                        tooltip:
-                            'The target duration for Low-Latency HLS Partial Segments.',
-                        isoRef: 'HLS: 4.4.3.7',
-                    })
-                  : ''}
-              ${timing.lowLatency.active
-                  ? statCardTemplate({
-                        label: 'Blocking Request Support',
-                        value: timing.blockingRequestSupport ? 'Yes' : 'No',
-                        isCode: false,
-                        tooltip:
-                            'Indicates if the server supports blocking playlist reloads, allowing for more efficient updates.',
-                        isoRef: 'HLS: 4.4.3.8',
-                    })
-                  : ''}
-          `
-        : html`<div class="col-span-full text-sm text-gray-400">
-              Timing report is only applicable for Live streams.
-          </div>`;
-
-    const securityContent = html`
-        ${statCardTemplate({
-            label: 'Encryption Status',
-            value: security.isEncrypted ? 'Yes' : 'No',
-            isCode: false,
-            tooltip:
-                'Indicates if the stream is encrypted and requires a decryption pipeline.',
-        })}
-        ${listCardTemplate({
-            label: 'DRM Systems (KEYFORMAT)',
-            items: security.drmSystems.map((s) => `${s.name} (${s.uuid})`),
-            tooltip:
-                'Detected DRM systems and their unique schemeIdUris, needed for EME APIs.',
-            isoRef: 'HLS: 4.4.4.4',
-        })}
-        ${listCardTemplate({
-            label: 'Key IDs (KEYID)',
-            items: security.defaultKIDs,
-            tooltip:
-                'The Key IDs found in the manifest, crucial for debugging decryption. Note: KEYID is not part of the HLS RFC but is common practice.',
-            isoRef: 'Vendor-Specific',
-        })}
-        ${statCardTemplate({
-            label: 'HLS Encryption Method',
-            value: security.hlsEncryptionMethod,
-            tooltip:
-                'The specific encryption method used (e.g., SAMPLE-AES, AES-128).',
-            isoRef: 'HLS: 4.3.2.4',
-        })}
-    `;
-
-    const integrationContent = html`
-        ${statCardTemplate({
-            label: 'Required HLS Version',
-            value: integration.requiredHlsVersion,
-            tooltip:
-                'The minimum HLS version required to support all features in the manifest.',
-            isoRef: 'HLS: 4.3.1.2',
-        })}
-        ${statCardTemplate({
-            label: 'Segment Container Format',
-            value: integration.segmentContainerFormat,
-            tooltip:
-                'The container format of media segments (e.g., ISOBMFF, MPEG-2 TS).',
-        })}
-        ${statCardTemplate({
-            label: 'Trick Play Support',
-            value: integration.trickPlaySupport ? 'Yes' : 'No',
-            isCode: false,
-            tooltip:
-                'Indicates if dedicated I-Frame playlists are available for fast-forward/rewind.',
-            isoRef: 'HLS: 4.3.4.3',
-        })}
-        ${listCardTemplate({
-            label: 'Subtitle Formats',
-            items: integration.subtitleFormats,
-            tooltip:
-                'The specific formats used for subtitles or captions (e.g., WebVTT, IMSC1).',
-        })}
-        ${listCardTemplate({
-            label: 'Required Codecs',
-            items: integration.requiredCodecs,
-            tooltip:
-                'A consolidated list of all unique codecs the player must support.',
-        })}
-    `;
-
-    return html`
-        <div class="space-y-8">
-            ${sectionTemplate('Network & Delivery Profile', networkContent)}
-            ${sectionTemplate('Timing & Update Strategy (Live)', timingContent)}
-            ${sectionTemplate('Security & Encryption', securityContent)}
-            ${sectionTemplate(
-                'Player Integration Requirements',
-                integrationContent
-            )}
-        </div>
-    `;
-};
diff --git a/js/ui/views/integrators-report/components/shared.js b/js/ui/views/integrators-report/components/shared.js
deleted file mode 100644
index 2fa22ad..0000000
--- a/js/ui/views/integrators-report/components/shared.js
+++ /dev/null
@@ -1,61 +0,0 @@
-import { html } from 'lit-html';
-import { tooltipTriggerClasses } from '../../../../shared/constants.js';
-
-export const statCardTemplate = ({
-    label,
-    value,
-    tooltip,
-    isoRef = null,
-    isCode = true,
-}) => {
-    if (value === null || value === undefined || value === '') return '';
-    const valueClass = isCode ? 'font-mono' : 'font-sans';
-    return html`
-        <div class="bg-gray-800 p-3 rounded-lg border border-gray-700">
-            <dt
-                class="text-xs font-medium text-gray-400 ${tooltipTriggerClasses}"
-                data-tooltip="${tooltip}"
-                data-iso="${isoRef || ''}"
-            >
-                ${label}
-            </dt>
-            <dd
-                class="text-base text-left text-white mt-1 break-words ${valueClass}"
-            >
-                ${value}
-            </dd>
-        </div>
-    `;
-};
-
-export const listCardTemplate = ({ label, items, tooltip, isoRef = null }) => {
-    if (!items || items.length === 0) return '';
-    return html`
-        <div class="bg-gray-800 p-3 rounded-lg border border-gray-700">
-            <dt
-                class="text-xs font-medium text-gray-400 ${tooltipTriggerClasses}"
-                data-tooltip="${tooltip}"
-                data-iso="${isoRef || ''}"
-            >
-                ${label}
-            </dt>
-            <dd class="text-sm text-left font-mono text-white mt-2 space-y-1">
-                ${items.map(
-                    (item) =>
-                        html`<div class="bg-gray-900/50 p-1 rounded">
-                            ${item}
-                        </div>`
-                )}
-            </dd>
-        </div>
-    `;
-};
-
-export const sectionTemplate = (title, content) => html`
-    <div>
-        <h3 class="text-xl font-bold mb-4">${title}</h3>
-        <dl class="grid gap-4 grid-cols-[repeat(auto-fit,minmax(320px,1fr))]">
-            ${content}
-        </dl>
-    </div>
-`;
diff --git a/js/ui/views/integrators-report/index.js b/js/ui/views/integrators-report/index.js
deleted file mode 100644
index d248a77..0000000
--- a/js/ui/views/integrators-report/index.js
+++ /dev/null
@@ -1,32 +0,0 @@
-import { html } from 'lit-html';
-import { createIntegratorsReportViewModel } from './view-model.js';
-import { dashReportTemplate } from './components/dash-report.js';
-import { hlsReportTemplate } from './components/hls-report.js';
-
-/**
- * Main dispatcher for the Integrator's Report view.
- * It selects the appropriate protocol-specific template to render.
- * @param {import('../../../app/types.js').Stream} stream The active stream.
- * @returns {import('lit-html').TemplateResult} The rendered template for the report.
- */
-export function getIntegratorsReportTemplate(stream) {
-    if (!stream || !stream.manifest) {
-        return html`<p class="warn">
-            No stream data available for this report.
-        </p>`;
-    }
-
-    const viewModel = createIntegratorsReportViewModel(stream);
-
-    if (stream.protocol === 'dash') {
-        return dashReportTemplate(viewModel);
-    }
-
-    if (stream.protocol === 'hls') {
-        return hlsReportTemplate(viewModel);
-    }
-
-    return html`<p class="warn">
-        Integrator's Report not available for unknown protocol.
-    </p>`;
-}
diff --git a/js/ui/views/integrators-report/view-model.js b/js/ui/views/integrators-report/view-model.js
deleted file mode 100644
index 6cae24a..0000000
--- a/js/ui/views/integrators-report/view-model.js
+++ /dev/null
@@ -1,277 +0,0 @@
-import { getDrmSystemName } from '../../../shared/utils/drm.js';
-
-/**
- * @typedef {import('../../../app/types.ts').Stream} Stream
- * @typedef {import('../../../app/types.ts').Manifest} Manifest
- */
-
-/**
- * Extracts network-related information from the stream and active manifest.
- * @param {Stream} stream
- * @param {Manifest} activeManifest
- * @returns {object}
- */
-function getNetworkInfo(stream, activeManifest) {
-    const hostnames = { manifest: new Set(), media: new Set(), key: new Set() };
-    let totalSegmentDuration = 0;
-    let segmentCount = 0;
-
-    try {
-        if (stream.originalUrl)
-            hostnames.manifest.add(new URL(stream.originalUrl).hostname);
-        if (stream.baseUrl && stream.baseUrl !== stream.originalUrl)
-            hostnames.manifest.add(new URL(stream.baseUrl).hostname);
-
-        if (stream.protocol === 'dash') {
-            activeManifest.locations?.forEach((loc) =>
-                hostnames.manifest.add(new URL(loc, stream.baseUrl).hostname)
-            );
-            stream.dashRepresentationState.forEach((repState) => {
-                const sampleSegments = repState.segments
-                    .filter((s) => /** @type {any} */ (s).type === 'Media')
-                    .slice(0, 10);
-                sampleSegments.forEach((seg) => {
-                    hostnames.media.add(
-                        new URL(/** @type {any} */ (seg).resolvedUrl).hostname
-                    );
-                    totalSegmentDuration +=
-                        /** @type {any} */ (seg).duration /
-                        /** @type {any} */ (seg).timescale;
-                    segmentCount++;
-                });
-            });
-        } else if (stream.protocol === 'hls') {
-            activeManifest.variants?.forEach((v) =>
-                hostnames.manifest.add(new URL(v.resolvedUri).hostname)
-            );
-            // NEW: Also check EXT-X-MEDIA tags for additional playlist hostnames
-            const hlsManifest = activeManifest.serializedManifest;
-            if (
-                hlsManifest &&
-                'media' in hlsManifest &&
-                Array.isArray(hlsManifest.media)
-            ) {
-                hlsManifest.media.forEach((media) => {
-                    if (media.URI) {
-                        hostnames.manifest.add(
-                            new URL(media.URI, stream.baseUrl).hostname
-                        );
-                    }
-                });
-            }
-
-            const segments = activeManifest.segments || [];
-            segments.forEach((seg) => {
-                hostnames.media.add(new URL(seg.resolvedUrl).hostname);
-                totalSegmentDuration += seg.duration;
-            });
-            segmentCount = segments.length;
-            activeManifest.tags
-                .filter(
-                    (t) =>
-                        t.name === 'EXT-X-KEY' &&
-                        t.value.URI &&
-                        !t.value.URI.startsWith('data:')
-                )
-                .forEach((t) =>
-                    hostnames.key.add(
-                        new URL(t.value.URI, stream.baseUrl).hostname
-                    )
-                );
-        }
-    } catch (e) {
-        console.error('Error extracting network info:', e);
-    }
-
-    const avgReqRate =
-        segmentCount > 0 ? totalSegmentDuration / segmentCount : null;
-
-    return {
-        manifestHostnames: Array.from(hostnames.manifest),
-        mediaSegmentHostnames: Array.from(hostnames.media),
-        keyLicenseHostnames: Array.from(hostnames.key),
-        avgSegmentRequestRate: avgReqRate,
-        avgSegmentSize: null, // Size requires fetching, deferring this feature.
-        contentSteering: stream.steeringInfo
-            ? {
-                  serverUri: /** @type {any} */ (stream.steeringInfo).value[
-                      'SERVER-URI'
-                  ],
-                  defaultPathway: /** @type {any} */ (stream.steeringInfo)
-                      .value['PATHWAY-ID'],
-                  allPathways: [
-                      ...new Set(
-                          stream.manifest.variants
-                              .map((v) => v.attributes['PATHWAY-ID'])
-                              .filter(Boolean)
-                      ),
-                  ],
-              }
-            : null,
-    };
-}
-
-/**
- * Gathers timing and update strategy information for live streams.
- * @param {Stream} stream The overall stream object
- * @param {Manifest} activeManifest The currently viewed manifest (master or media)
- * @returns {object | null}
- */
-function getTimingInfo(stream, activeManifest) {
-    if (stream.manifest.type !== 'dynamic') return null;
-
-    const summary = activeManifest.summary;
-    let lowLatency = { active: false, mechanism: 'Standard Polling' };
-    if (summary.lowLatency?.isLowLatency) {
-        lowLatency.active = true;
-        lowLatency.mechanism =
-            summary.general.protocol === 'DASH'
-                ? 'DASH Low-Latency (Chunked Transfer)'
-                : 'HLS Low-Latency (Partial Segments)';
-    }
-
-    return {
-        pollingInterval:
-            stream.manifest.minimumUpdatePeriod ?? summary.hls?.targetDuration,
-        dvrWindow:
-            stream.manifest.timeShiftBufferDepth ?? activeManifest.duration,
-        lowLatency: lowLatency,
-        blockingRequestSupport: summary.lowLatency?.canBlockReload ?? false,
-        targetLatency: summary.lowLatency?.targetLatency,
-        chunkDuration: stream.manifest.maxSubsegmentDuration,
-        partTargetDuration: summary.lowLatency?.partTargetDuration,
-    };
-}
-
-/**
- * Gathers all security and encryption details from the active manifest.
- * @param {Manifest} activeManifest
- * @returns {object}
- */
-function getSecurityInfo(activeManifest) {
-    const keyTags =
-        activeManifest.tags?.filter(
-            (t) => t.name === 'EXT-X-KEY' && t.value.METHOD !== 'NONE'
-        ) || [];
-    const contentProtection =
-        activeManifest.periods
-            ?.flatMap((p) => p.adaptationSets)
-            .flatMap((as) => as.contentProtection) || [];
-
-    if (keyTags.length > 0) {
-        const uniqueKeyFormats = [
-            ...new Set(keyTags.map((k) => k.value.KEYFORMAT).filter(Boolean)),
-        ];
-        const uniqueKeyIDs = [
-            ...new Set(keyTags.map((k) => k.value.KEYID).filter(Boolean)),
-        ];
-
-        return {
-            isEncrypted: true,
-            drmSystems: uniqueKeyFormats.map((s) => ({
-                name: getDrmSystemName(s),
-                uuid: s,
-            })),
-            defaultKIDs: uniqueKeyIDs,
-            hlsEncryptionMethod: keyTags[0].value.METHOD,
-            emeRobustnessLevels: [],
-        };
-    }
-
-    if (contentProtection.length > 0) {
-        const uniqueRobustness = [
-            ...new Set(
-                contentProtection.map((cp) => cp.robustness).filter(Boolean)
-            ),
-        ];
-        return {
-            isEncrypted: true,
-            drmSystems: [
-                ...new Set(contentProtection.map((cp) => cp.schemeIdUri)),
-            ].map((s) => ({ name: getDrmSystemName(s), uuid: s })),
-            defaultKIDs: [
-                ...new Set(
-                    contentProtection.map((cp) => cp.defaultKid).filter(Boolean)
-                ),
-            ],
-            hlsEncryptionMethod: null,
-            emeRobustnessLevels: uniqueRobustness,
-        };
-    }
-
-    return {
-        isEncrypted: false,
-        drmSystems: [],
-        defaultKIDs: [],
-        hlsEncryptionMethod: null,
-        emeRobustnessLevels: [],
-    };
-}
-
-/**
- * Gathers core player integration requirements from the active manifest.
- * @param {Manifest} activeManifest
- * @returns {object}
- */
-function getIntegrationRequirements(activeManifest) {
-    const summary = activeManifest.summary;
-    const allCodecs = new Set([
-        ...summary.videoTracks.flatMap((t) => t.codecs),
-        ...summary.audioTracks.flatMap((t) => t.codecs),
-    ]);
-
-    const subtitleFormats = new Set();
-    summary.textTracks.forEach((tt) => {
-        const format = tt.codecsOrMimeTypes.join(', ');
-        if (format.includes('stpp') || format.includes('im1t')) {
-            subtitleFormats.add('IMSC1 (TTML)');
-        } else if (format.includes('vtt')) {
-            subtitleFormats.add('WebVTT');
-        } else if (format) {
-            subtitleFormats.add(format);
-        }
-    });
-
-    const isDashSegmentAlignment = activeManifest.periods
-        ?.flatMap((p) => p.adaptationSets)
-        .some((as) => as.segmentAlignment === true);
-
-    return {
-        requiredDashProfiles: summary.dash?.profiles || null,
-        requiredHlsVersion: summary.hls?.version || null,
-        segmentContainerFormat: summary.general.segmentFormat,
-        trickPlaySupport:
-            summary.hls?.iFramePlaylists > 0 ||
-            activeManifest.periods
-                .flatMap((p) => p.adaptationSets)
-                .some((as) => as.roles.some((r) => r.value === 'trick')),
-        requiredCodecs: Array.from(allCodecs),
-        subtitleFormats: Array.from(subtitleFormats),
-        segmentAlignment: isDashSegmentAlignment ?? null,
-    };
-}
-
-/**
- * Creates the complete view model for the Integrator's Report.
- * @param {Stream} stream The active stream.
- * @returns {object}
- */
-export function createIntegratorsReportViewModel(stream) {
-    const activeManifest =
-        stream.protocol === 'hls' && stream.activeMediaPlaylistUrl
-            ? stream.mediaPlaylists.get(stream.activeMediaPlaylistUrl)?.manifest
-            : stream.manifest;
-
-    if (!activeManifest) {
-        return { network: {}, timing: null, security: {}, integration: {} };
-    }
-
-    const viewModel = {
-        network: getNetworkInfo(stream, activeManifest),
-        timing: getTimingInfo(stream, activeManifest),
-        security: getSecurityInfo(activeManifest),
-        integration: getIntegrationRequirements(activeManifest),
-    };
-
-    return viewModel;
-}
diff --git a/js/ui/views/interactive-manifest/components/dash/renderer.js b/js/ui/views/interactive-manifest/components/dash/renderer.js
deleted file mode 100644
index af102b6..0000000
--- a/js/ui/views/interactive-manifest/components/dash/renderer.js
+++ /dev/null
@@ -1,250 +0,0 @@
-import { html } from 'lit-html';
-import { unsafeHTML } from 'lit-html/directives/unsafe-html.js';
-import { dashTooltipData } from './tooltip-data.js';
-import { tooltipTriggerClasses } from '../../../../../shared/constants.js';
-import { useStore, storeActions } from '../../../../../app/store.js';
-import { debugLog } from '../../../../../shared/utils/debug.js';
-
-const linesPerPage = 500;
-
-const onPageChange = (offset, totalPages) => {
-    const { interactiveManifestCurrentPage } = useStore.getState();
-    const newPage = interactiveManifestCurrentPage + offset;
-    if (newPage >= 1 && newPage <= totalPages) {
-        storeActions.setInteractiveManifestPage(newPage);
-    }
-};
-
-const escapeHtml = (str) => {
-    if (!str) return '';
-    return str
-        .replace(/&/g, '&amp;')
-        .replace(/</g, '&lt;')
-        .replace(/>/g, '&gt;')
-        .replace(/"/g, '&quot;');
-};
-
-const getTagHTML = (tagName) => {
-    const isClosing = tagName.startsWith('/');
-    const cleanTagName = isClosing ? tagName.substring(1) : tagName;
-    const tagInfo = dashTooltipData[cleanTagName];
-    const [prefix, localName] = cleanTagName.includes(':')
-        ? cleanTagName.split(':')
-        : [null, cleanTagName];
-    const displayPrefix = prefix
-        ? `<span class="text-gray-400">${prefix}:</span>`
-        : '';
-    const tagClass =
-        'text-blue-300 rounded-sm px-1 -mx-1 transition-colors hover:bg-slate-700';
-
-    let dynamicClasses = '';
-    let tooltipAttrs = '';
-
-    if (tagInfo) {
-        dynamicClasses = tooltipTriggerClasses;
-        tooltipAttrs = `data-tooltip="${escapeHtml(
-            tagInfo.text
-        )}" data-iso="${escapeHtml(tagInfo.isoRef)}"`;
-    } else {
-        dynamicClasses = 'cursor-help bg-red-900/50 missing-tooltip-trigger';
-        tooltipAttrs = `data-tooltip="No definition for &lt;${cleanTagName}&gt;"`;
-    }
-
-    return `&lt;${
-        isClosing ? '/' : ''
-    }<span class="${dynamicClasses}" ${tooltipAttrs}>${displayPrefix}<span class="${tagClass}">${localName}</span></span>`;
-};
-
-const getAttributeHTML = (tagName, attr) => {
-    const attrKey = `${tagName}@${attr.name}`;
-    const attrInfo = dashTooltipData[attrKey];
-    const nameClass =
-        'text-emerald-300 rounded-sm px-1 -mx-1 transition-colors hover:bg-slate-700';
-    const valueClass = 'text-yellow-300';
-    const isIgnoredAttr = ['xmlns', 'xmlns:xsi', 'xsi:schemaLocation'].includes(
-        attr.name
-    );
-
-    let dynamicClasses = '';
-    let tooltipAttrs = '';
-
-    if (attrInfo) {
-        dynamicClasses = tooltipTriggerClasses;
-        tooltipAttrs = `data-tooltip="${escapeHtml(
-            attrInfo.text
-        )}" data-iso="${escapeHtml(attrInfo.isoRef)}"`;
-    } else if (!isIgnoredAttr) {
-        dynamicClasses = 'cursor-help bg-red-900/50 missing-tooltip-trigger';
-        tooltipAttrs = `data-tooltip="Tooltip definition missing for '${attr.name}' on &lt;${tagName}&gt;"`;
-    }
-
-    return `<span class="${nameClass} ${dynamicClasses}" ${tooltipAttrs}>${
-        attr.name
-    }</span>="<span class="${valueClass}">${escapeHtml(attr.value)}</span>"`;
-};
-
-const preformattedDash = (node, depth = 0) => {
-    if (!node || typeof node.nodeType === 'undefined') {
-        return [];
-    }
-    const indent = '  '.repeat(depth);
-    switch (node.nodeType) {
-        case Node.ELEMENT_NODE: {
-            const el = /** @type {Element} */ (node);
-            const childNodes = Array.from(el.childNodes).filter(
-                (n) =>
-                    n.nodeType === Node.ELEMENT_NODE ||
-                    n.nodeType === Node.COMMENT_NODE ||
-                    (n.nodeType === Node.TEXT_NODE && n.textContent.trim())
-            );
-
-            const attrs = Array.from(el.attributes)
-                .map((a) => ` ${getAttributeHTML(el.tagName, a)}`)
-                .join('');
-
-            if (childNodes.length > 0) {
-                const openingTag = `${indent}${getTagHTML(
-                    el.tagName
-                )}${attrs}&gt;`;
-                const childLines = childNodes.flatMap((c) =>
-                    preformattedDash(c, depth + 1)
-                );
-                const closingTag = `${indent}${getTagHTML(
-                    `/${el.tagName}`
-                )}&gt;`;
-                return [openingTag, ...childLines, closingTag];
-            } else {
-                return [`${indent}${getTagHTML(el.tagName)}${attrs} /&gt;`];
-            }
-        }
-        case Node.TEXT_NODE: {
-            return [
-                `${indent}<span class="text-gray-200">${escapeHtml(
-                    node.textContent.trim()
-                )}</span>`,
-            ];
-        }
-        case Node.COMMENT_NODE: {
-            return [
-                `${indent}<span class="text-gray-500 italic">&lt;!--${escapeHtml(
-                    node.textContent
-                )}--&gt;</span>`,
-            ];
-        }
-        default:
-            return [];
-    }
-};
-
-export const dashManifestTemplate = (stream, currentPage) => {
-    // Determine which manifest string to display
-    const hasUpdates =
-        stream.manifestUpdates && stream.manifestUpdates.length > 0;
-    const manifestStringToDisplay = hasUpdates
-        ? stream.manifestUpdates[stream.activeManifestUpdateIndex].rawManifest
-        : stream.rawManifest;
-
-    debugLog(
-        'DashRenderer',
-        'dashManifestTemplate called.',
-        'Stream has updates:',
-        hasUpdates,
-        'Active update index:',
-        stream.activeManifestUpdateIndex,
-        'Manifest string length:',
-        manifestStringToDisplay.length
-    );
-
-    // On-demand parsing for the view. This is NOT cached on the stream object
-    // to ensure updates are reflected.
-    let manifestElement;
-    const parser = new DOMParser();
-    const xmlDoc = parser.parseFromString(
-        manifestStringToDisplay,
-        'application/xml'
-    );
-    const parserError = xmlDoc.querySelector('parsererror');
-
-    if (parserError) {
-        debugLog(
-            'DashRenderer',
-            'XML parsing failed.',
-            parserError.textContent
-        );
-        console.error('XML Parsing Error:', parserError.textContent);
-        return html`<div class="text-red-400 p-4 font-mono">
-            <p class="font-bold">Failed to parse manifest XML.</p>
-            <pre class="mt-2 bg-gray-900 p-2 rounded">
-${parserError.textContent}</pre
-            >
-        </div>`;
-    }
-
-    manifestElement = xmlDoc.querySelector('MPD');
-
-    if (!manifestElement) {
-        debugLog('DashRenderer', '<MPD> element not found.');
-        return html`<div class="text-red-400 p-4">
-            Error: &lt;MPD&gt; root element not found in the manifest.
-        </div>`;
-    }
-
-    const allLines = preformattedDash(manifestElement);
-    debugLog(
-        'DashRenderer',
-        `Generated ${allLines.length} lines of HTML for manifest view.`
-    );
-    const totalPages = Math.ceil(allLines.length / linesPerPage);
-
-    const startLine = (currentPage - 1) * linesPerPage;
-    const endLine = startLine + linesPerPage;
-    const visibleLines = allLines.slice(startLine, endLine);
-
-    const paginationControls =
-        totalPages > 1
-            ? html` <div class="text-center text-sm text-gray-400 mt-4">
-                  <button
-                      @click=${() => onPageChange(-1, totalPages)}
-                      ?disabled=${currentPage === 1}
-                      class="px-3 py-1 rounded bg-gray-600 hover:bg-gray-500 disabled:opacity-50 mx-2"
-                  >
-                      &larr; Previous
-                  </button>
-                  <span
-                      >Page ${currentPage} of ${totalPages} (Lines
-                      ${startLine + 1}-${Math.min(
-                          endLine,
-                          allLines.length
-                      )})</span
-                  >
-                  <button
-                      @click=${() => onPageChange(1, totalPages)}
-                      ?disabled=${currentPage === totalPages}
-                      class="px-3 py-1 rounded bg-gray-600 hover:bg-gray-500 disabled:opacity-50 mx-2"
-                  >
-                      Next &rarr;
-                  </button>
-              </div>`
-            : '';
-
-    return html`
-        <div
-            class="bg-slate-800 rounded-lg p-4 font-mono text-sm leading-relaxed overflow-x-auto"
-        >
-            ${visibleLines.map(
-                (line, i) => html`
-                    <div class="flex">
-                        <span
-                            class="text-right text-gray-500 pr-4 select-none flex-shrink-0 w-12"
-                            >${startLine + i + 1}</span
-                        >
-                        <span class="flex-grow whitespace-pre-wrap break-all"
-                            >${unsafeHTML(line)}</span
-                        >
-                    </div>
-                `
-            )}
-        </div>
-        ${paginationControls}
-    `;
-};
diff --git a/js/ui/views/interactive-manifest/components/dash/tooltip-data.js b/js/ui/views/interactive-manifest/components/dash/tooltip-data.js
deleted file mode 100644
index d906e3f..0000000
--- a/js/ui/views/interactive-manifest/components/dash/tooltip-data.js
+++ /dev/null
@@ -1,642 +0,0 @@
-/**
- * A comprehensive mapping of DASH MPD element and attribute names to their descriptions and ISO/IEC 23009-1:2022 standard references.
- * This structure is designed to provide rich, context-aware tooltips for developers and engineers working with DASH manifests.
- * Format: 'ElementName' for elements, 'ElementName@attributeName' for attributes.
- */
-export const dashTooltipData = {
-    // MPD Level
-    MPD: {
-        text: 'The root element of the Media Presentation Description (MPD). It contains all metadata required for a client to stream the content.',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-    },
-    'MPD@id': {
-        text: 'A unique identifier for the Media Presentation. Recommended to be unique within the publishing scope.',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-    },
-    'MPD@profiles': {
-        text: 'A comma-separated list of profile identifiers. This signals the specific DASH features and constraints the MPD and its segments conform to, ensuring client compatibility.',
-        isoRef: 'Clause 8.1 & 5.3.1.2, Table 3',
-    },
-    'MPD@type': {
-        text: 'Specifies the presentation type. "static" is for on-demand content (VOD), while "dynamic" is for live streaming services.',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-    },
-    'MPD@availabilityStartTime': {
-        text: 'For "dynamic" presentations, this is the anchor time (in UTC) from which all media times are calculated. For "static" presentations, it specifies when segments become available.',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-    },
-    'MPD@availabilityEndTime': {
-        text: 'The latest point in wall-clock time at which any segment in the presentation is available.',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-    },
-    'MPD@publishTime': {
-        text: 'For "dynamic" presentations, this specifies the wall-clock time when this version of the MPD was generated. A later publishTime indicates an updated MPD.',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-    },
-    'MPD@mediaPresentationDuration': {
-        text: 'The total duration of the media presentation for "static" content. If not present for dynamic content, the duration is unknown.',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-    },
-    'MPD@minimumUpdatePeriod': {
-        text: 'For "dynamic" MPDs, specifies the minimum time a client should wait before requesting an updated MPD. If not present, the MPD is not expected to change.',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-    },
-    'MPD@minBufferTime': {
-        text: 'Specifies a minimum buffer duration that a client should maintain to ensure smooth playback across all Representations.',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-    },
-    'MPD@timeShiftBufferDepth': {
-        text: 'For "dynamic" presentations, this specifies the duration of the time-shifting buffer (DVR window) that is guaranteed to be available.',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-    },
-    'MPD@suggestedPresentationDelay': {
-        text: 'For "dynamic" presentations, a suggested delay from the live edge at which players should start presentation. This helps synchronize clients and maintain a stable buffer.',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-    },
-    'MPD@maxSegmentDuration': {
-        text: 'The maximum duration of any Segment in the Media Presentation. Provides an upper bound for client buffer and request planning.',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-    },
-    'MPD@maxSubsegmentDuration': {
-        text: 'The maximum duration of any Media Subsegment (e.g., CMAF Chunk) in the Media Presentation. Important for low-latency streaming calculations.',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-    },
-
-    // XML Schema / Namespace Attributes
-    'MPD@xmlns': {
-        text: 'XML Namespace. Declares the default namespace for elements in the document, which must be "urn:mpeg:dash:schema:mpd:2011".',
-        isoRef: 'W3C XML Namespaces & Clause 5.2.2',
-    },
-    'MPD@xmlns:xsi': {
-        text: 'XML Namespace for XML Schema Instance. Enables the use of schema-related attributes like xsi:schemaLocation.',
-        isoRef: 'W3C XML Schema Part 1',
-    },
-    'MPD@xsi:schemaLocation': {
-        text: 'XML Schema Location. Associates the DASH namespace URI with the physical location of its schema definition file (XSD) for validation.',
-        isoRef: 'W3C XML Schema Part 1 & Clause 5.2.2',
-    },
-    'MPD@xmlns:cenc': {
-        text: 'XML Namespace for MPEG Common Encryption (CENC). Declares the "cenc" prefix, typically used for the <cenc:pssh> element inside a ContentProtection descriptor.',
-        isoRef: 'ISO/IEC 23001-7 & Clause 5.8.5.2.2',
-    },
-
-    // BaseURL & Locations
-    BaseURL: {
-        text: 'Specifies a base URL used for resolving relative URLs of segments, initialization files, or other resources. Can be specified at multiple levels (MPD, Period, etc.).',
-        isoRef: 'Clause 5.6',
-    },
-    Location: {
-        text: 'Specifies an alternative URL where the complete MPD can be retrieved. This is used for redundancy and load balancing.',
-        isoRef: 'Clause 5.3.1.2, Table 3',
-    },
-    PatchLocation: {
-        text: 'Specifies a URL for fetching an MPD patch document. This allows for efficient updates in live services by sending only the changes to the manifest.',
-        isoRef: 'Clause 5.15.2',
-    },
-
-    // Program Information
-    ProgramInformation: {
-        text: 'Provides descriptive metadata about the Media Presentation, such as title and source.',
-        isoRef: 'Clause 5.7',
-    },
-    'ProgramInformation@lang': {
-        text: 'Specifies the language of the descriptive information in this element.',
-        isoRef: 'Clause 5.7.2, Table 31',
-    },
-    'ProgramInformation@moreInformationURL': {
-        text: 'A URL pointing to a web page or resource with more detailed information about the program.',
-        isoRef: 'Clause 5.7.2, Table 31',
-    },
-    Title: {
-        text: 'A human-readable title for the Media Presentation.',
-        isoRef: 'Clause 5.7.2, Table 31',
-    },
-    Source: {
-        text: 'Information about the original source of the content, such as a broadcaster or production company.',
-        isoRef: 'Clause 5.7.2, Table 31',
-    },
-    Copyright: {
-        text: 'A copyright statement for the Media Presentation.',
-        isoRef: 'Clause 5.7.2, Table 31',
-    },
-
-    // Period Level
-    Period: {
-        text: 'A Period represents a continuous segment of content time. Multiple Periods can be concatenated to form the full presentation, often used for ad insertion.',
-        isoRef: 'Clause 5.3.2',
-    },
-    'Period@id': {
-        text: 'A unique identifier for the Period. It is mandatory for dynamic MPDs to allow clients to track periods across manifest updates.',
-        isoRef: 'Clause 5.3.2.2, Table 4',
-    },
-    'Period@start': {
-        text: 'The start time of the Period on the Media Presentation Timeline. For the first period, this is typically "PT0S".',
-        isoRef: 'Clause 5.3.2.2, Table 4',
-    },
-    'Period@duration': {
-        text: 'The duration of the Period in ISO 8601 format. If not present for the last period, the presentation continues until ended by other means.',
-        isoRef: 'Clause 5.3.2.2, Table 4',
-    },
-    'Period@bitstreamSwitching': {
-        text: 'When "true", indicates that bitstream switching is possible between Representations within this Period, implying Segments can be concatenated without re-initialization.',
-        isoRef: 'Clause 5.3.2.2, Table 4',
-    },
-    AssetIdentifier: {
-        text: 'Specifies an asset identifier for the Period. Periods with the same AssetIdentifier belong to the same logical asset, which helps clients maintain context across ad breaks.',
-        isoRef: 'Clause 5.8.4.10',
-    },
-
-    // AdaptationSet Level
-    AdaptationSet: {
-        text: 'A set of interchangeable, encoded versions of one or more media components. For example, all video bitrates, or all audio language tracks.',
-        isoRef: 'Clause 5.3.3',
-    },
-    'AdaptationSet@id': {
-        text: 'A unique identifier for the AdaptationSet within the Period.',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    'AdaptationSet@group': {
-        text: 'Assigns the AdaptationSet to a group. A client should present at most one Representation from each non-zero group simultaneously.',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    'AdaptationSet@contentType': {
-        text: 'Specifies the high-level media type for this set, such as "video", "audio", or "text".',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    'AdaptationSet@lang': {
-        text: 'Specifies the language of the content in this set, using RFC 5646 codes (e.g., "en", "es-419").',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    'AdaptationSet@mimeType': {
-        text: 'The MIME type for all Representations in this set. This is a common attribute that can also be specified per-Representation.',
-        isoRef: 'Clause 5.3.7.2, Table 14',
-    },
-    'AdaptationSet@codecs': {
-        text: 'A string identifying the codec(s) common to all Representations in this set, as per RFC 6381. This is a common attribute.',
-        isoRef: 'Clause 5.3.7.2, Table 14',
-    },
-    'AdaptationSet@minBandwidth': {
-        text: 'The minimum bandwidth of any Representation in this set, in bits per second.',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    'AdaptationSet@maxBandwidth': {
-        text: 'The maximum bandwidth of any Representation in this set, in bits per second.',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    'AdaptationSet@minWidth': {
-        text: 'The minimum width in pixels of any video Representation in this set.',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    'AdaptationSet@maxWidth': {
-        text: 'The maximum width in pixels of any video Representation in this set.',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    'AdaptationSet@minHeight': {
-        text: 'The minimum height in pixels of any video Representation in this set.',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    'AdaptationSet@maxHeight': {
-        text: 'The maximum height in pixels of any video Representation in this set.',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    'AdaptationSet@minFrameRate': {
-        text: 'The minimum frame rate of any video Representation in this set.',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    'AdaptationSet@maxFrameRate': {
-        text: 'The maximum frame rate of any video Representation in this set.',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    'AdaptationSet@frameRate': {
-        text: "The frame rate of the video content, common to all Representations in this set. It is typically expressed as a fraction (e.g., '25/1', '30000/1001').",
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    'AdaptationSet@par': {
-        text: 'The picture aspect ratio for the video content (e.g., "16:9"), common to all Representations in the set.',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    'AdaptationSet@selectionPriority': {
-        text: 'A priority for this AdaptationSet. Higher numbers are preferred. Can guide client selection logic when multiple suitable sets are available.',
-        isoRef: 'Clause 5.3.7.2, Table 14',
-    },
-    'AdaptationSet@segmentAlignment': {
-        text: 'If true, indicates that segment boundaries are aligned across all Representations in this set, simplifying seamless ABR switching.',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    'AdaptationSet@subsegmentAlignment': {
-        text: 'If true, indicates that subsegment boundaries (e.g., CMAF chunks) are aligned across Representations, enabling low-latency switching.',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    'AdaptationSet@startWithSAP': {
-        text: 'Specifies that media segments start with a Stream Access Point (SAP) of a certain type. A value of 1 or 2 is typical, enabling easier stream switching and seeking.',
-        isoRef: 'Clause 5.3.7.2, Table 14',
-    },
-    'AdaptationSet@subsegmentStartsWithSAP': {
-        text: 'Specifies that subsegments start with a Stream Access Point (SAP), essential for efficient seeking and low-latency streaming.',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    'AdaptationSet@bitstreamSwitching': {
-        text: 'If true, indicates that segments from different Representations in this set can be concatenated to form a single, conforming bitstream, enabling switching without re-initializing the decoder.',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    'AdaptationSet@initializationPrincipal': {
-        text: 'A URL to a CMAF Principal Header that is sufficient to initialize any Representation in this Adaptation Set. This promotes efficiency by allowing a single initialization segment to cover all quality levels.',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    ContentComponent: {
-        text: 'Describes a single media component (e.g. a specific audio track) within an AdaptationSet that contains multiplexed content.',
-        isoRef: 'Clause 5.3.4',
-    },
-
-    // Representation Level
-    Representation: {
-        text: 'A specific, deliverable, and encoded version of one or more media streams (e.g., video at a particular bitrate and resolution).',
-        isoRef: 'Clause 5.3.5',
-    },
-    'Representation@id': {
-        text: 'A unique identifier for the Representation within the Period.',
-        isoRef: 'Clause 5.3.5.2, Table 9',
-    },
-    'Representation@bandwidth': {
-        text: 'The required bandwidth in bits per second. A client with this bandwidth can stream the Representation without buffering, assuming it maintains a buffer of at least @minBufferTime.',
-        isoRef: 'Clause 5.3.5.2, Table 9 & Clause 5.3.5.4',
-    },
-    'Representation@qualityRanking': {
-        text: 'Specifies a quality ranking relative to other Representations in the same AdaptationSet. Lower integer values represent higher quality.',
-        isoRef: 'Clause 5.3.5.2, Table 9',
-    },
-    'Representation@dependencyId': {
-        text: 'A space-separated list of other Representation IDs that this Representation depends on for decoding or presentation (e.g., for Scalable Video Coding).',
-        isoRef: 'Clause 5.3.5.2, Table 9',
-    },
-    'Representation@associationId': {
-        text: 'A space-separated list of Representation IDs that this Representation is associated with (e.g., a metadata track associated with a video track).',
-        isoRef: 'Clause 5.3.5.2, Table 9',
-    },
-    'Representation@associationType': {
-        text: 'Specifies the type of association for each ID in @associationId. Uses 4CC codes like "cdsc" for content description.',
-        isoRef: 'Clause 5.3.5.2, Table 9',
-    },
-    'Representation@mimeType': {
-        text: 'Defines the MIME type for this specific Representation, as per RFC 6838. If present, it overrides any mimeType inherited from the parent AdaptationSet.',
-        isoRef: 'Clause 5.3.7.2, Table 14',
-    },
-    'Representation@mediaStreamStructureId': {
-        text: 'Identifies a group of Representations that share a common stream structure (e.g. SAP timing), enabling more complex switching scenarios like Open GOP.',
-        isoRef: 'Clause 5.3.5.2, Table 9',
-    },
-    'Representation@codecs': {
-        text: 'A string identifying the codec(s) and profile/level used in this Representation, as per RFC 6381.',
-        isoRef: 'Clause 5.3.7.2, Table 14',
-    },
-    'Representation@containerProfiles': {
-        text: "Specifies container profiles essential for processing the Representation, often used with CMAF to indicate 'cmfc' or 'cmf2' conformance.",
-        isoRef: 'Clause 5.3.7.2, Table 14',
-    },
-    'Representation@width': {
-        text: 'The width of the video in this Representation, in pixels.',
-        isoRef: 'Clause 5.3.7.2, Table 14',
-    },
-    'Representation@height': {
-        text: 'The height of the video in this Representation, in pixels.',
-        isoRef: 'Clause 5.3.7.2, Table 14',
-    },
-    'Representation@frameRate': {
-        text: 'The frame rate of the video, expressed as a fraction (e.g., "30000/1001").',
-        isoRef: 'Clause 5.3.7.2, Table 14',
-    },
-    'Representation@sar': {
-        text: 'The Sample Aspect Ratio of the video (e.g., "1:1" for square pixels).',
-        isoRef: 'Clause 5.3.7.2, Table 14',
-    },
-    'Representation@audioSamplingRate': {
-        text: 'The sampling rate of the audio in samples per second (Hz).',
-        isoRef: 'Clause 5.3.7.2, Table 14',
-    },
-    'Representation@scanType': {
-        text: 'The scan type of the source video, either "progressive" or "interlaced".',
-        isoRef: 'Clause 5.3.7.2, Table 14',
-    },
-    SubRepresentation: {
-        text: 'Describes a subset of a Representation that can be extracted, such as a lower frame-rate track for trick modes or a specific audio channel.',
-        isoRef: 'Clause 5.3.6',
-    },
-
-    // Segment Info Level
-    SegmentBase: {
-        text: 'Provides default segment information, typically used for single-segment Representations where the URL is given by a BaseURL element.',
-        isoRef: 'Clause 5.3.9.2',
-    },
-    'SegmentBase@indexRange': {
-        text: "Specifies the byte range within the media segment that contains the Segment Index ('sidx') box.",
-        isoRef: 'Clause 5.3.9.2.2, Table 16',
-    },
-    'SegmentBase@indexRangeExact': {
-        text: 'If true, specifies that the byte range in @indexRange is exact. If false, the client may need to parse the media to find the end of the index.',
-        isoRef: 'Clause 5.3.9.2.2, Table 16',
-    },
-    'SegmentBase@availabilityTimeOffset': {
-        text: 'An offset in seconds applied to the segment availability time. For low-latency, this allows segments to be advertised before they are fully available.',
-        isoRef: 'Clause 5.3.9.2.2, Table 16',
-    },
-    'SegmentBase@availabilityTimeComplete': {
-        text: 'If false, indicates that a segment might not be fully available at its announced availability time, used in low-latency chunked transfer.',
-        isoRef: 'Clause 5.3.9.2.2, Table 16',
-    },
-    SegmentList: {
-        text: 'Provides an explicit list of Segment URLs, typically used for VOD when segment locations are not predictable.',
-        isoRef: 'Clause 5.3.9.3',
-    },
-    SegmentURL: {
-        text: 'Specifies the URL and optional byte range for a single Media Segment within a SegmentList.',
-        isoRef: 'Clause 5.3.9.3.2, Table 19',
-    },
-    'SegmentURL@mediaRange': {
-        text: 'The byte range of the media segment within the resource specified by the @media attribute.',
-        isoRef: 'Clause 5.3.9.3.2, Table 19',
-    },
-    SegmentTemplate: {
-        text: 'Defines a template for generating Segment URLs dynamically, using identifiers like $Number$ or $Time$.',
-        isoRef: 'Clause 5.3.9.4',
-    },
-    'SegmentTemplate@timescale': {
-        text: 'The number of time units that pass in one second. This timescale is used for calculating segment durations and start times specified in this template.',
-        isoRef: 'Clause 5.3.9.2.2, Table 16',
-    },
-    'SegmentTemplate@presentationTimeOffset': {
-        text: "An offset in timescale units applied to the media presentation time. This aligns the segment's internal timeline with the Period's timeline.",
-        isoRef: 'Clause 5.3.9.2.2, Table 16',
-    },
-    'SegmentTemplate@initialization': {
-        text: 'A template for the URL of the Initialization Segment. May contain identifiers like $RepresentationID$.',
-        isoRef: 'Clause 5.3.9.4.2, Table 20',
-    },
-    'SegmentTemplate@media': {
-        text: 'A template for the URLs of the Media Segments. Typically contains $Time$ or $Number$ for dynamic URL generation.',
-        isoRef: 'Clause 5.3.9.4.2, Table 20',
-    },
-    'SegmentTemplate@duration': {
-        text: 'Specifies the constant duration of each segment in timescale units. This is used when the media template uses the $Number$ identifier.',
-        isoRef: 'Clause 5.3.9.2.2, Table 17',
-    },
-    'SegmentTemplate@startNumber': {
-        text: 'The number of the first Media Segment in this Representation. Used with the $Number$ identifier.',
-        isoRef: 'Clause 5.3.9.2.2, Table 17',
-    },
-    'SegmentTemplate@endNumber': {
-        text: 'The number of the last Media Segment in this Representation for the Period.',
-        isoRef: 'Clause 5.3.9.2.2, Table 17',
-    },
-    SegmentTimeline: {
-        text: 'Provides an explicit, ordered list of segments with potentially variable durations. It is an alternative to using the @duration attribute on SegmentTemplate.',
-        isoRef: 'Clause 5.3.9.6',
-    },
-    S: {
-        text: 'A Segment Timeline entry. Defines a series of one or more contiguous segments with the same duration.',
-        isoRef: 'Clause 5.3.9.6.2, Table 22',
-    },
-    'S@t': {
-        text: 'The presentation start time of the first segment in this series, in units of the @timescale.',
-        isoRef: 'Clause 5.3.9.6.2, Table 22',
-    },
-    'S@d': {
-        text: 'The duration of each segment in this series, in units of the @timescale.',
-        isoRef: 'Clause 5.3.9.6.2, Table 22',
-    },
-    'S@r': {
-        text: 'The repeat count. A value of "N" means there are N+1 segments in this contiguous series. A value of -1 means the segment repeats until the next S element or the end of the Period.',
-        isoRef: 'Clause 5.3.9.6.2, Table 22',
-    },
-    'S@n': {
-        text: 'The segment number of the first segment in this series. Can be used to signal discontinuities in segment numbering.',
-        isoRef: 'Clause 5.3.9.6.2, Table 22',
-    },
-    'S@k': {
-        text: 'The number of segments included in a Segment Sequence, used for hierarchical templating.',
-        isoRef: 'Clause 5.3.9.6.2, Table 22',
-    },
-
-    // Events & Timing
-    EventStream: {
-        text: 'An element within a Period that contains a sequence of timed events signaled directly in the MPD.',
-        isoRef: 'Clause 5.10.2',
-    },
-    InbandEventStream: {
-        text: 'Signals the presence of an event stream multiplexed within the media segments of a Representation.',
-        isoRef: 'Clause 5.10.3.2',
-    },
-    Event: {
-        text: 'A single timed event within an EventStream.',
-        isoRef: 'Clause 5.10.2.2, Table 39',
-    },
-    'Event@presentationTime': {
-        text: 'The presentation time of the event relative to the start of the Period.',
-        isoRef: 'Clause 5.10.2.2, Table 39',
-    },
-    'Event@duration': {
-        text: 'The duration of the event.',
-        isoRef: 'Clause 5.10.2.2, Table 39',
-    },
-
-    // Descriptors
-    Accessibility: {
-        text: 'Provides information about accessibility features, such as audio descriptions or subtitles for the hard-of-hearing.',
-        isoRef: 'Clause 5.8.4.3',
-    },
-    AudioChannelConfiguration: {
-        text: 'Specifies the audio channel layout (e.g., stereo, 5.1 surround sound).',
-        isoRef: 'Clause 5.8.4.7',
-    },
-    'AudioChannelConfiguration@schemeIdUri': {
-        text: 'A URI identifying the scheme used to define the audio channel configuration (e.g., "urn:mpeg:dash:23003:3:audio_channel_configuration:2011").',
-        isoRef: 'Clause 5.8.2, Table 32',
-    },
-    'AudioChannelConfiguration@value': {
-        text: 'A code representing the channel configuration according to the specified scheme (e.g., "2" for stereo).',
-        isoRef: 'Clause 5.8.2, Table 32',
-    },
-    ContentProtection: {
-        text: 'Contains information about a DRM system or encryption scheme used to protect the content, enabling a client to perform license acquisition.',
-        isoRef: 'Clause 5.8.4.1',
-    },
-    'ContentProtection@schemeIdUri': {
-        text: 'A URI that uniquely identifies the content protection scheme (e.g., the UUID for Widevine, PlayReady, or FairPlay).',
-        isoRef: 'Clause 5.8.4.1.4, Table 33',
-    },
-    'ContentProtection@value': {
-        text: 'An optional string providing additional scheme-specific information. For Common Encryption, this may be "cenc".',
-        isoRef: 'Clause 5.8.4.1.4, Table 33',
-    },
-    'ContentProtection@cenc:default_KID': {
-        text: 'The default Key ID for the content, as a UUID. This is the primary identifier for the decryption key.',
-        isoRef: 'ISO/IEC 23001-7 & Clause 5.8.5.2.2',
-    },
-    'ContentProtection@robustness': {
-        text: 'Specifies the minimum required security level for the client decryptor (e.g., software vs. hardware DRM).',
-        isoRef: 'Clause 5.8.4.1.4, Table 33',
-    },
-    'cenc:pssh': {
-        text: 'Base64-encoded Protection System Specific Header. This opaque blob contains initialization data required by a specific DRM system to generate a license request.',
-        isoRef: 'ISO/IEC 23001-7 & Clause 5.8.5.2.2',
-    },
-    EssentialProperty: {
-        text: 'Specifies a property that is essential for processing the parent element. If a client does not understand an EssentialProperty, it MUST ignore the parent element.',
-        isoRef: 'Clause 5.8.4.8',
-    },
-    FramePacking: {
-        text: 'Describes the arrangement of frames for stereoscopic 3D video content.',
-        isoRef: 'Clause 5.8.4.6',
-    },
-    ProducerReferenceTime: {
-        text: 'Provides a mapping between media presentation time and a wall-clock time at the point of production (capture or encoding), useful for live latency calculations.',
-        isoRef: 'Clause 5.12',
-    },
-    SupplementalProperty: {
-        text: 'Specifies supplemental information that is not essential for playback but may be used by the client for optimization or enhanced functionality.',
-        isoRef: 'Clause 5.8.4.9',
-    },
-    Label: {
-        text: 'Provides a human-readable text string for its parent element, which can be used for UI display (e.g., "1080p", "English AAC").',
-        isoRef: 'Clause 5.3.10',
-    },
-    Rating: {
-        text: 'Specifies a content rating (e.g., for parental control) using a defined rating scheme.',
-        isoRef: 'Clause 5.8.4.4',
-    },
-    Role: {
-        text: 'Describes the role or purpose of an AdaptationSet, helping the client select the appropriate track (e.g., "main", "alternate", "commentary", "subtitle").',
-        isoRef: 'Clause 5.8.4.2',
-    },
-    'Role@schemeIdUri': {
-        text: 'A URI identifying the role scheme, typically "urn:mpeg:dash:role:2011".',
-        isoRef: 'Clause 5.8.2, Table 32',
-    },
-    'Role@value': {
-        text: 'The specific role value within the defined scheme (e.g., "main", "dub").',
-        isoRef: 'Clause 5.8.5.5, Table 34',
-    },
-    UTCTiming: {
-        text: 'Provides a timing source for clients to synchronize their wall-clocks, which is crucial for consistent live stream startup and timeline management.',
-        isoRef: 'Clause 5.8.4.11',
-    },
-    'UTCTiming@schemeIdUri': {
-        text: 'Identifies the clock synchronization method (e.g., "urn:mpeg:dash:utc:http-xsdate:2014" for an HTTP endpoint returning an ISO 8601 date).',
-        isoRef: 'Clause 5.8.5.7, Table 35',
-    },
-    'UTCTiming@value': {
-        text: 'The value associated with the synchronization scheme, often a URL to a time server.',
-        isoRef: 'Clause 5.8.5.7, Table 35',
-    },
-    Viewpoint: {
-        text: 'Describes the viewpoint of the media content, used for multi-view or immersive experiences.',
-        isoRef: 'Clause 5.8.4.5',
-    },
-
-    // Service Description Level (Annex K)
-    ServiceDescription: {
-        text: 'Provides guidance to the client on how the service provider expects the service to be consumed, particularly regarding latency and playback rate.',
-        isoRef: 'Annex K.4',
-    },
-    Scope: {
-        text: 'Defines the scope to which a ServiceDescription applies, allowing different rules for different clients or environments.',
-        isoRef: 'Annex K.4.2.1, Table K.5',
-    },
-    Latency: {
-        text: 'Specifies latency targets for the service, including minimum, maximum, and target latency values.',
-        isoRef: 'Annex K.4.2.2, Table K.6',
-    },
-    'Latency@target': {
-        text: 'The service provider’s preferred presentation latency in milliseconds, measured against a ProducerReferenceTime.',
-        isoRef: 'Annex K.4.2.2, Table K.6',
-    },
-    'Latency@min': {
-        text: 'The minimum allowed presentation latency in milliseconds.',
-        isoRef: 'Annex K.4.2.2, Table K.6',
-    },
-    'Latency@max': {
-        text: 'The maximum allowed presentation latency in milliseconds.',
-        isoRef: 'Annex K.4.2.2, Table K.6',
-    },
-    PlaybackRate: {
-        text: 'Specifies the acceptable range for playback rate adjustment, allowing the client to slightly speed up or slow down playback to manage latency.',
-        isoRef: 'Annex K.4.2.3, Table K.7',
-    },
-    'PlaybackRate@min': {
-        text: 'The minimum playback rate relative to normal speed (1.0).',
-        isoRef: 'Annex K.4.2.3, Table K.7',
-    },
-    'PlaybackRate@max': {
-        text: 'The maximum playback rate relative to normal speed (1.0).',
-        isoRef: 'Annex K.4.2.3, Table K.7',
-    },
-
-    // 2022 Spec Additions & Refinements
-    InitializationSet: {
-        text: 'Specifies a suitable initialization for a specific media type. This allows clients to determine playback capabilities for the entire presentation upfront.',
-        isoRef: 'Clause 5.3.12',
-    },
-    'AdaptationSet@initializationSetRef': {
-        text: 'A space-separated list of InitializationSet IDs that this AdaptationSet conforms to.',
-        isoRef: 'Clause 5.3.3.2, Table 5',
-    },
-    Preselection: {
-        text: 'Specifies a combination of Adaptation Sets that form a specific, complete user experience (e.g., a main audio track plus a commentary track).',
-        isoRef: 'Clause 5.3.11',
-    },
-    'Preselection@preselectionComponents': {
-        text: 'A space-separated list of AdaptationSet and/or ContentComponent IDs that constitute this preselection.',
-        isoRef: 'Clause 5.3.11.3, Table 26',
-    },
-    Resync: {
-        text: 'Provides information on resynchronization points within Segments, enabling low-latency streaming and more efficient seeking by allowing clients to process a segment from the middle.',
-        isoRef: 'Clause 5.3.13',
-    },
-    'Resync@type': {
-        text: 'Specifies the type of the Resync Point. A value > 0 indicates properties of a Stream Access Point (SAP) of that type or lower.',
-        isoRef: 'Clause 5.3.13.2, Table 28',
-    },
-    'Resync@marker': {
-        text: 'If true, indicates that each resynchronization point includes a specific binary marker that can be found by scanning the segment bytes.',
-        isoRef: 'Clause 5.3.13.2, Table 28',
-    },
-    ExtendedBandwidth: {
-        text: 'Provides a more detailed and accurate bandwidth model, especially for Variable Bitrate (VBR) content, by specifying bandwidth requirements over different buffer times.',
-        isoRef: 'Clause 5.3.5.6',
-    },
-    'ExtendedBandwidth@vbr': {
-        text: 'If true, indicates that the content has Variable Bitrate characteristics and that the ModelPair elements provide a more accurate bandwidth model than the main @bandwidth attribute.',
-        isoRef: 'Clause 5.3.5.6, Table 12',
-    },
-    ModelPair: {
-        text: 'A pair of bufferTime and bandwidth values that further define the characteristics of a VBR Representation.',
-        isoRef: 'Clause 5.3.5.6',
-    },
-    'ModelPair@bufferTime': {
-        text: 'The buffer duration for which the associated bandwidth is specified.',
-        isoRef: 'Clause 5.3.5.6, Table 12',
-    },
-    'ModelPair@bandwidth': {
-        text: 'The bandwidth required to sustain playback for the associated bufferTime.',
-        isoRef: 'Clause 5.3.5.6, Table 12',
-    },
-    FailoverContent: {
-        text: 'Signals time ranges within the content that have been replaced by failover content (e.g., a slate or color bars) due to an upstream error.',
-        isoRef: 'Clause 5.3.9.7',
-    },
-    FCS: {
-        text: 'Failover Content Section. Specifies the start time (@t) and duration (@d) of a section containing failover content.',
-        isoRef: 'Clause 5.3.9.7.2, Table 23',
-    },
-    OutputProtection: {
-        text: 'Specifies the required output protection scheme and level (e.g., HDCP 2.2) necessary to render the content on an external display.',
-        isoRef: 'Clause 5.8.4.12',
-    },
-    'OutputProtection@schemeIdUri': {
-        text: 'A URI identifying the output protection scheme (e.g., "urn:mpeg:dash:output-protection:hdcp:2020").',
-        isoRef: 'Clause 5.8.5.14',
-    },
-    'OutputProtection@value': {
-        text: 'A value specifying the minimum required version or level of the protection scheme (e.g., "2.2" for HDCP 2.2).',
-        isoRef: 'Clause 5.8.5.14.2, Table 36',
-    },
-};
diff --git a/js/ui/views/interactive-manifest/components/hls/renderer.js b/js/ui/views/interactive-manifest/components/hls/renderer.js
deleted file mode 100644
index 6695fcb..0000000
--- a/js/ui/views/interactive-manifest/components/hls/renderer.js
+++ /dev/null
@@ -1,428 +0,0 @@
-import { html } from 'lit-html';
-import { unsafeHTML } from 'lit-html/directives/unsafe-html.js';
-import { hlsTooltipData } from './tooltip-data.js';
-import { tooltipTriggerClasses } from '../../../../../shared/constants.js';
-import { eventBus } from '../../../../../app/event-bus.js';
-import { useStore, storeActions } from '../../../../../app/store.js';
-import { debugLog } from '../../../../../shared/utils/debug.js';
-import { renderApp } from '../../../../mainRenderer.js';
-
-const linesPerPage = 500;
-let showSubstituted = true; // Local state for this view
-
-const onPageChange = (offset, totalPages) => {
-    const { interactiveManifestCurrentPage } = useStore.getState();
-    const newPage = interactiveManifestCurrentPage + offset;
-    if (newPage >= 1 && newPage <= totalPages) {
-        storeActions.setInteractiveManifestPage(newPage);
-    }
-};
-
-const escapeHtml = (str) => {
-    if (!str) return '';
-    return str
-        .replace(/&/g, '&amp;')
-        .replace(/</g, '&lt;')
-        .replace(/>/g, '&gt;')
-        .replace(/"/g, '&quot;');
-};
-
-const variableTableTemplate = (definedVariables) => {
-    if (!definedVariables || definedVariables.size === 0) {
-        return '';
-    }
-    const variables = Array.from(definedVariables.entries());
-
-    return html`
-        <div class="mb-4">
-            <h4 class="text-md font-bold mb-2">Defined Variables</h4>
-            <div
-                class="bg-gray-900/50 rounded-lg border border-gray-700 overflow-hidden"
-            >
-                <table class="w-full text-left text-xs">
-                    <thead class="bg-gray-900">
-                        <tr>
-                            <th class="p-2 font-semibold text-gray-300">
-                                Variable Name
-                            </th>
-                            <th class="p-2 font-semibold text-gray-300">
-                                Source
-                            </th>
-                            <th class="p-2 font-semibold text-gray-300">
-                                Resolved Value
-                            </th>
-                        </tr>
-                    </thead>
-                    <tbody class="divide-y divide-gray-700">
-                        ${variables.map(
-                            ([name, { value, source }]) => html`
-                                <tr>
-                                    <td class="p-2 font-mono text-cyan-400">
-                                        ${name}
-                                    </td>
-                                    <td class="p-2 font-mono text-gray-400">
-                                        ${source}
-                                    </td>
-                                    <td class="p-2 font-mono text-yellow-300">
-                                        ${value}
-                                    </td>
-                                </tr>
-                            `
-                        )}
-                    </tbody>
-                </table>
-            </div>
-        </div>
-    `;
-};
-
-const hlsSubNavTemplate = (stream) => {
-    if (!stream.manifest?.isMaster) return html``;
-
-    const handleNavClick = (e) => {
-        const button = /** @type {HTMLElement} */ (e.target).closest('button');
-        if (!button) return;
-        const url = button.dataset.url;
-        eventBus.dispatch('hls:media-playlist-activate', {
-            streamId: stream.id,
-            url,
-        });
-    };
-
-    const navItem = (label, url, isActive) => html`
-        <button
-            class="px-3 py-1.5 text-sm rounded-md transition-colors ${isActive
-                ? 'bg-blue-600 text-white font-semibold'
-                : 'bg-gray-900 hover:bg-gray-700'}"
-            data-url="${url}"
-        >
-            ${label}
-        </button>
-    `;
-
-    // Group all available playlists from the state by their type
-    const groupedPlaylists = {
-        MASTER: [
-            {
-                label: 'View',
-                url: 'master',
-                isActive: !stream.activeMediaPlaylistUrl,
-            },
-        ],
-        VIDEO: [],
-        AUDIO: [],
-        SUBTITLES: [],
-    };
-
-    for (const uri of stream.hlsVariantState.keys()) {
-        const variant = (stream.manifest.variants || []).find(
-            (v) => v.resolvedUri === uri
-        );
-        const media = /** @type {any} */ (
-            stream.manifest.serializedManifest.media || []
-        ).find((m) => m.URI && new URL(m.URI, stream.baseUrl).href === uri);
-
-        if (variant) {
-            groupedPlaylists.VIDEO.push({
-                label: `Variant (BW: ${(
-                    variant.attributes.BANDWIDTH / 1000
-                ).toFixed(0)}k)`,
-                url: uri,
-                isActive: stream.activeMediaPlaylistUrl === uri,
-            });
-        } else if (media) {
-            const type = media.TYPE || 'UNKNOWN';
-            if (!groupedPlaylists[type]) groupedPlaylists[type] = [];
-            groupedPlaylists[type].push({
-                label: `${media.NAME || media.LANGUAGE || 'Rendition'}`,
-                url: uri,
-                isActive: stream.activeMediaPlaylistUrl === uri,
-            });
-        }
-    }
-
-    const navGroupTemplate = (title, items) => {
-        if (!items || items.length === 0) return '';
-        return html`
-            <div class="flex flex-wrap items-center gap-2">
-                <strong class="text-xs text-gray-400 uppercase mr-2"
-                    >${title}:</strong
-                >
-                ${items.map((item) =>
-                    navItem(item.label, item.url, item.isActive)
-                )}
-            </div>
-        `;
-    };
-
-    return html`
-        <div
-            class="mb-4 p-2 bg-gray-900/50 rounded-lg flex flex-col gap-2"
-            @click=${handleNavClick}
-        >
-            ${navGroupTemplate('Master Playlist', groupedPlaylists.MASTER)}
-            ${navGroupTemplate('Variant Streams', groupedPlaylists.VIDEO)}
-            ${navGroupTemplate('Audio Renditions', groupedPlaylists.AUDIO)}
-            ${navGroupTemplate(
-                'Subtitle Renditions',
-                groupedPlaylists.SUBTITLES
-            )}
-        </div>
-    `;
-};
-
-const getHlsLineHTML = (line) => {
-    line = line.trim();
-    if (!line.startsWith('#EXT')) {
-        const isComment = line.startsWith('#');
-        return `<span class="${
-            isComment ? 'text-gray-500 italic' : 'text-cyan-400'
-        }">${escapeHtml(line)}</span>`;
-    }
-
-    const tagClass = 'text-purple-300';
-    const attributeClass = 'text-emerald-300';
-    const valueClass = 'text-yellow-300';
-    const tooltipClass = `rounded-sm px-1 -mx-1 transition-colors hover:bg-slate-700 ${tooltipTriggerClasses}`;
-
-    const separatorIndex = line.indexOf(':');
-    if (separatorIndex === -1) {
-        const tagName = line.substring(1);
-        const tagInfo = hlsTooltipData[tagName];
-        const tooltipAttrs = tagInfo
-            ? `data-tooltip="${escapeHtml(
-                  tagInfo.text
-              )}" data-iso="${escapeHtml(tagInfo.isoRef)}"`
-            : '';
-        return `#<span class="${tagClass} ${
-            tagInfo ? tooltipClass : ''
-        }" ${tooltipAttrs}>${tagName}</span>`;
-    }
-
-    const tagName = line.substring(1, separatorIndex);
-    const tagValue = line.substring(separatorIndex + 1);
-    const tagInfo = hlsTooltipData[tagName];
-    const tagTooltipAttrs = tagInfo
-        ? `data-tooltip="${escapeHtml(tagInfo.text)}" data-iso="${escapeHtml(
-              tagInfo.isoRef
-          )}"`
-        : '';
-
-    let valueHtml = '';
-    if (tagValue.includes('=')) {
-        const regex = /([A-Z0-9-]+)=("[^"]*"|[^,]+)/g;
-        let match;
-        const parts = [];
-
-        while ((match = regex.exec(tagValue)) !== null) {
-            const attr = match[1];
-            let val = match[2];
-            const isQuoted = val.startsWith('"') && val.endsWith('"');
-            if (isQuoted) {
-                val = val.substring(1, val.length - 1);
-            }
-
-            const attrKey = `${tagName}@${attr}`;
-            const attrInfo = hlsTooltipData[attrKey];
-            let dynamicClasses = '';
-            let attrTooltipAttrs = '';
-
-            if (attrInfo) {
-                dynamicClasses = tooltipClass;
-                attrTooltipAttrs = `data-tooltip="${escapeHtml(
-                    attrInfo.text
-                )}" data-iso="${escapeHtml(attrInfo.ref)}"`;
-            } else {
-                dynamicClasses =
-                    'cursor-help bg-red-900/50 missing-tooltip-trigger';
-                attrTooltipAttrs = `data-tooltip="Tooltip definition missing for '${attr}' on tag #${tagName}"`;
-            }
-
-            parts.push(
-                `<span class="${attributeClass} ${dynamicClasses}" ${attrTooltipAttrs}>${escapeHtml(
-                    attr
-                )}</span>=<span class="${valueClass}">${
-                    isQuoted ? '&quot;' : ''
-                }${escapeHtml(val)}${isQuoted ? '&quot;' : ''}</span>`
-            );
-        }
-        valueHtml = parts.join('<span class="text-gray-400">,</span>');
-    } else {
-        valueHtml = `<span class="${valueClass}">${escapeHtml(tagValue)}</span>`;
-    }
-
-    return `#<span class="${tagClass} ${
-        tagInfo ? tooltipClass : ''
-    }" ${tagTooltipAttrs}>${tagName}</span>:<span class="font-normal">${valueHtml}</span>`;
-};
-
-const structuredTagTemplate = (tag) => {
-    const tagInfo = hlsTooltipData[tag.name] || {};
-    return html` <div
-        class="flex-grow whitespace-pre-wrap break-all bg-gray-900/50 p-2 rounded border-l-2 border-cyan-500"
-    >
-        <div
-            class="font-semibold text-cyan-300 mb-1 ${tooltipTriggerClasses}"
-            data-tooltip="${tagInfo.text}"
-            data-iso="${tagInfo.isoRef}"
-        >
-            ${tag.name}
-        </div>
-        <dl class="grid grid-cols-[auto_1fr] gap-x-4 text-xs">
-            ${Object.entries(tag.value).map(([key, value]) => {
-                const attrInfo = hlsTooltipData[`${tag.name}@${key}`] || {};
-                return html`
-                    <dt
-                        class="text-gray-400 ${tooltipTriggerClasses}"
-                        data-tooltip="${attrInfo.text}"
-                        data-iso="${attrInfo.ref}"
-                    >
-                        ${key}
-                    </dt>
-                    <dd class="text-gray-200 font-mono">${value}</dd>
-                `;
-            })}
-        </dl>
-    </div>`;
-};
-
-export const hlsManifestTemplate = (stream, currentPage) => {
-    debugLog('HlsRenderer', 'hlsManifestTemplate called.', 'Stream:', stream);
-
-    const { activeMediaPlaylistUrl } = stream;
-    let manifestObjectForView;
-    let rawManifestString; // Keep the original raw string for the toggle
-
-    if (activeMediaPlaylistUrl) {
-        const mediaPlaylist = stream.mediaPlaylists.get(activeMediaPlaylistUrl);
-        // *** FIX START ***
-        if (!mediaPlaylist) {
-            return html`<div class="text-yellow-400 p-4">
-                Loading rendition playlist...
-            </div>`;
-        }
-        // *** FIX END ***
-        rawManifestString = mediaPlaylist.rawManifest;
-        manifestObjectForView = mediaPlaylist.manifest;
-    } else {
-        rawManifestString = stream.rawManifest;
-        manifestObjectForView = stream.manifest;
-    }
-
-    // This is the string WITH variables substituted, which we get from serializing the IR.
-    const manifestStringToDisplay = showSubstituted
-        ? manifestObjectForView.serializedManifest.raw
-        : rawManifestString;
-
-    if (!manifestStringToDisplay || !manifestObjectForView) {
-        return html`<div class="text-yellow-400 p-4">
-            Awaiting manifest content...
-        </div>`;
-    }
-
-    const { renditionReports, preloadHints } = manifestObjectForView;
-    const lines = manifestStringToDisplay.split(/\r?\n/);
-
-    let reportIndex = 0;
-    let hintIndex = 0;
-
-    const allLineTemplates = lines.map((line) => {
-        const trimmedLine = line.trim();
-        if (
-            renditionReports &&
-            trimmedLine.startsWith('#EXT-X-RENDITION-REPORT')
-        ) {
-            const reportData = renditionReports[reportIndex++];
-            return reportData
-                ? structuredTagTemplate({
-                      name: 'EXT-X-RENDITION-REPORT',
-                      value: reportData,
-                  })
-                : html`${unsafeHTML(getHlsLineHTML(line))}`;
-        }
-        if (preloadHints && trimmedLine.startsWith('#EXT-X-PRELOAD-HINT')) {
-            const hintData = preloadHints[hintIndex++];
-            return hintData
-                ? structuredTagTemplate({
-                      name: 'EXT-X-PRELOAD-HINT',
-                      value: hintData,
-                  })
-                : html`${unsafeHTML(getHlsLineHTML(line))}`;
-        }
-        return html`${unsafeHTML(getHlsLineHTML(line))}`;
-    });
-
-    const totalPages = Math.ceil(allLineTemplates.length / linesPerPage);
-    const startLine = (currentPage - 1) * linesPerPage;
-    const endLine = startLine + linesPerPage;
-    const visibleLineTemplates = allLineTemplates.slice(startLine, endLine);
-
-    const paginationControls =
-        totalPages > 1
-            ? html` <div class="text-center text-sm text-gray-400 mt-4">
-                  <button
-                      @click=${() => onPageChange(-1, totalPages)}
-                      ?disabled=${currentPage === 1}
-                      class="px-3 py-1 rounded bg-gray-600 hover:bg-gray-500 disabled:opacity-50 mx-2"
-                  >
-                      &larr; Previous
-                  </button>
-                  <span
-                      >Page ${currentPage} of ${totalPages} (Lines
-                      ${startLine + 1}-${Math.min(
-                          endLine,
-                          allLineTemplates.length
-                      )})</span
-                  >
-                  <button
-                      @click=${() => onPageChange(1, totalPages)}
-                      ?disabled=${currentPage === totalPages}
-                      class="px-3 py-1 rounded bg-gray-600 hover:bg-gray-500 disabled:opacity-50 mx-2"
-                  >
-                      Next &rarr;
-                  </button>
-              </div>`
-            : '';
-
-    const handleToggle = () => {
-        showSubstituted = !showSubstituted;
-        renderApp(); // Trigger a re-render of the entire app to update this view
-    };
-
-    const variableControls =
-        stream.hlsDefinedVariables && stream.hlsDefinedVariables.size > 0
-            ? html`<div class="mb-2">
-                  <button
-                      @click=${handleToggle}
-                      class="text-xs px-3 py-1 rounded ${showSubstituted
-                          ? 'bg-blue-800 text-blue-200'
-                          : 'bg-gray-700 text-gray-300'}"
-                  >
-                      ${showSubstituted ? 'Show Raw' : 'Show Substituted'}
-                  </button>
-              </div>`
-            : '';
-
-    return html`
-        ${hlsSubNavTemplate(stream)}
-        ${variableTableTemplate(stream.hlsDefinedVariables)} ${variableControls}
-        <div
-            class="bg-slate-800 rounded-lg p-4 font-mono text-sm leading-relaxed overflow-x-auto"
-        >
-            ${visibleLineTemplates.map(
-                (template, i) => html`
-                    <div class="flex">
-                        <span
-                            class="text-right text-gray-500 pr-4 select-none flex-shrink-0 w-10"
-                            >${startLine + i + 1}</span
-                        >
-                        <span class="flex-grow whitespace-pre-wrap break-all"
-                            >${template}</span
-                        >
-                    </div>
-                `
-            )}
-        </div>
-        ${paginationControls}
-    `;
-};
diff --git a/js/ui/views/interactive-manifest/components/hls/tooltip-data.js b/js/ui/views/interactive-manifest/components/hls/tooltip-data.js
deleted file mode 100644
index 25add78..0000000
--- a/js/ui/views/interactive-manifest/components/hls/tooltip-data.js
+++ /dev/null
@@ -1,454 +0,0 @@
-/**
- * A comprehensive mapping of HLS playlist tags to their descriptions and RFC 8216bis (HLS 2nd Edition) references.
- * This structure is designed to provide rich, context-aware tooltips for developers and systems engineers architecting HLS-based streaming solutions.
- * Each entry includes a `category` for logical grouping and a `ref` to the specific clause in the specification.
- * Format: 'TagName' for tags, 'TagName@AttributeName' for attributes.
- */
-export const hlsTooltipData = {
-    // --- Basic Tags (Media or Multivariant) ---
-    EXTM3U: {
-        text: 'The mandatory header for all HLS playlists. It indicates that the file is an Extended M3U playlist and MUST be the first line of the file.',
-        category: 'Basic',
-        ref: 'HLS 2nd Ed: 4.4.1.1',
-    },
-    'EXT-X-VERSION': {
-        text: 'Indicates the compatibility version of the playlist. The version number dictates which features and tags are valid, ensuring interoperability with clients of varying capabilities.',
-        category: 'Basic',
-        ref: 'HLS 2nd Ed: 4.4.1.2',
-    },
-
-    // --- Media or Multivariant Playlist Tags ---
-    'EXT-X-DEFINE': {
-        text: 'Defines a playlist variable. Its value can be substituted into other playlist elements, enabling the creation of dynamic, reusable, and less verbose playlist templates.',
-        category: 'Variable Substitution',
-        ref: 'HLS 2nd Ed: 4.4.2.3',
-    },
-    'EXT-X-DEFINE@NAME': {
-        text: 'The name of the variable being explicitly defined for substitution within the current playlist.',
-        category: 'Variable Substitution',
-        ref: 'HLS 2nd Ed: 4.4.2.3',
-    },
-    'EXT-X-DEFINE@VALUE': {
-        text: 'The string value that will replace references to the variable.',
-        category: 'Variable Substitution',
-        ref: 'HLS 2nd Ed: 4.4.2.3',
-    },
-    'EXT-X-DEFINE@IMPORT': {
-        text: 'The name of a variable to import from the parent Multivariant Playlist. This allows media playlists to inherit values, centralizing configuration.',
-        category: 'Variable Substitution',
-        ref: 'HLS 2nd Ed: 4.4.2.3',
-    },
-    'EXT-X-DEFINE@QUERYPARAM': {
-        text: 'The name of a URI query parameter whose value will be used to define this variable. This enables client-specific parameterization of playlists.',
-        category: 'Variable Substitution',
-        ref: 'HLS 2nd Ed: 4.4.2.3',
-    },
-    'EXT-X-INDEPENDENT-SEGMENTS': {
-        text: 'Indicates that all media samples in every segment can be decoded without information from other segments. This is a prerequisite for features like I-frame playlists.',
-        category: 'Playlist Control',
-        ref: 'HLS 2nd Ed: 4.4.2.1',
-    },
-    'EXT-X-START': {
-        text: 'Indicates a preferred starting point for playback. Useful for highlighting a specific point in a VOD asset or for setting a default live offset.',
-        category: 'Playlist Control',
-        ref: 'HLS 2nd Ed: 4.4.2.2',
-    },
-    'EXT-X-START@TIME-OFFSET': {
-        text: 'A required floating-point number of seconds from the beginning of the playlist (positive) or from the end (negative), specifying the preferred start point.',
-        category: 'Playlist Control',
-        ref: 'HLS 2nd Ed: 4.4.2.2',
-    },
-    'EXT-X-START@PRECISE': {
-        text: 'If YES, clients SHOULD not render media prior to the TIME-OFFSET, enabling frame-accurate starts. Default is NO.',
-        category: 'Playlist Control',
-        ref: 'HLS 2nd Ed: 4.4.2.2',
-    },
-
-    // --- Media Playlist Tags ---
-    'EXT-X-TARGETDURATION': {
-        text: "A required tag specifying the maximum media segment duration in seconds. It provides the fundamental time base for a client's reload logic in live streams.",
-        category: 'Media Playlist',
-        ref: 'HLS 2nd Ed: 4.4.3.1',
-    },
-    'EXT-X-MEDIA-SEQUENCE': {
-        text: 'Indicates the sequence number of the first media segment in the playlist. This number increments with each segment removed from a sliding-window live playlist.',
-        category: 'Media Playlist',
-        ref: 'HLS 2nd Ed: 4.4.3.2',
-    },
-    'EXT-X-DISCONTINUITY-SEQUENCE': {
-        text: 'Allows synchronization between different renditions of the same variant stream across discontinuities. Each discontinuity increments a shared counter.',
-        category: 'Media Playlist',
-        ref: 'HLS 2nd Ed: 4.4.3.3',
-    },
-    'EXT-X-ENDLIST': {
-        text: 'Indicates that no more media segments will be added to the playlist. This effectively converts a live playlist to a VOD playlist.',
-        category: 'Media Playlist',
-        ref: 'HLS 2nd Ed: 4.4.3.4',
-    },
-    'EXT-X-PLAYLIST-TYPE': {
-        text: 'Provides mutability information about the Media Playlist. VOD means the playlist is static. EVENT means segments can only be appended.',
-        category: 'Media Playlist',
-        ref: 'HLS 2nd Ed: 4.4.3.5',
-    },
-    'EXT-X-I-FRAMES-ONLY': {
-        text: 'Indicates that each media segment in the playlist describes a single I-frame. This is a key enabler for trick-play modes (fast-forward, rewind).',
-        category: 'Media Playlist',
-        ref: 'HLS 2nd Ed: 4.4.3.6',
-    },
-    'EXT-X-PART-INF': {
-        text: 'Provides information about Partial Segments in the playlist. It is a required declaration for using the Low-Latency HLS extension.',
-        category: 'Low-Latency HLS',
-        ref: 'HLS 2nd Ed: 4.4.3.7',
-    },
-    'EXT-X-PART-INF@PART-TARGET': {
-        text: 'A required attribute specifying the target duration of Partial Segments in seconds. This is the time base for low-latency playback.',
-        category: 'Low-Latency HLS',
-        ref: 'HLS 2nd Ed: 4.4.3.7',
-    },
-    'EXT-X-SERVER-CONTROL': {
-        text: 'Allows the server to advertise support for low-latency HLS features, fundamentally changing the client-server interaction model from simple polling.',
-        category: 'Low-Latency HLS',
-        ref: 'HLS 2nd Ed: 4.4.3.8',
-    },
-    'EXT-X-SERVER-CONTROL@CAN-BLOCK-RELOAD': {
-        text: 'If YES, the server supports Blocking Playlist Reload, where a client can request an update and the server will hold the request until the update is available. This reduces polling traffic.',
-        category: 'Low-Latency HLS',
-        ref: 'HLS 2nd Ed: 4.4.3.8',
-    },
-    'EXT-X-SERVER-CONTROL@HOLD-BACK': {
-        text: 'The server-recommended minimum distance from the live edge (in seconds) for standard HLS playback. Must be at least 3x TARGETDURATION.',
-        category: 'Low-Latency HLS',
-        ref: 'HLS 2nd Ed: 4.4.3.8',
-    },
-    'EXT-X-SERVER-CONTROL@PART-HOLD-BACK': {
-        text: 'The server-recommended minimum distance from the live edge (in seconds) for Low-Latency HLS playback. Must be at least 2x PART-TARGET.',
-        category: 'Low-Latency HLS',
-        ref: 'HLS 2nd Ed: 4.4.3.8',
-    },
-    'EXT-X-SERVER-CONTROL@CAN-SKIP-UNTIL': {
-        text: 'The "Skip Boundary" in seconds. If present, the server can generate Playlist Delta Updates, skipping segments older than this boundary from the live edge.',
-        category: 'Low-Latency HLS',
-        ref: 'HLS 2nd Ed: 4.4.3.8',
-    },
-
-    // --- Media Segment Tags ---
-    EXTINF: {
-        text: 'Specifies the duration (in seconds) of the media segment that immediately follows this tag. A required tag for every media segment.',
-        category: 'Media Segment',
-        ref: 'HLS 2nd Ed: 4.4.4.1',
-    },
-    'EXT-X-BYTERANGE': {
-        text: 'Indicates that a media segment is a sub-range of the resource identified by its URI. Format is <length>[@<offset>]. This allows multiple segments to be stored in a single file.',
-        category: 'Media Segment',
-        ref: 'HLS 2nd Ed: 4.4.4.2',
-    },
-    'EXT-X-DISCONTINUITY': {
-        text: 'Indicates a discontinuity between media segments, signaling a change in encoding parameters, timestamps, or format. Crucial for ad insertion and stream stitching.',
-        category: 'Media Segment',
-        ref: 'HLS 2nd Ed: 4.4.4.3',
-    },
-    'EXT-X-KEY': {
-        text: 'Specifies the decryption key for media segments. It applies to all subsequent segments until overridden by another EXT-X-KEY tag.',
-        category: 'Encryption',
-        ref: 'HLS 2nd Ed: 4.4.4.4',
-    },
-    'EXT-X-KEY@METHOD': {
-        text: 'The encryption method. Valid values: NONE, AES-128, SAMPLE-AES. SAMPLE-AES-CTR is also used. Defines how segments are encrypted.',
-        category: 'Encryption',
-        ref: 'HLS 2nd Ed: 4.4.4.4',
-    },
-    'EXT-X-KEY@URI': {
-        text: 'The URI from which the encryption key can be fetched. Required unless METHOD is NONE.',
-        category: 'Encryption',
-        ref: 'HLS 2nd Ed: 4.4.4.4',
-    },
-    'EXT-X-KEY@IV': {
-        text: 'A 128-bit hexadecimal Initialization Vector. If absent, the Media Sequence Number is used as the IV.',
-        category: 'Encryption',
-        ref: 'HLS 2nd Ed: 5.2',
-    },
-    'EXT-X-KEY@KEYFORMAT': {
-        text: 'Specifies how the key is represented in the resource identified by the URI (e.g., "identity", "skd", "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed" for Widevine). Defaults to "identity".',
-        category: 'Encryption',
-        ref: 'HLS 2nd Ed: 4.4.4.4',
-    },
-    'EXT-X-KEY@KEYFORMATVERSIONS': {
-        text: 'A slash-separated list of integers indicating which version(s) of a KEYFORMAT this instance complies with.',
-        category: 'Encryption',
-        ref: 'HLS 2nd Ed: 4.4.4.4',
-    },
-    'EXT-X-KEY@KEYID': {
-        text: 'A hexadecimal identifier for the key, specific to certain DRM systems (e.g., Widevine, FairPlay). This is not part of the HLS RFC but is common practice.',
-        category: 'Encryption',
-        ref: 'Vendor Specific',
-    },
-    'EXT-X-MAP': {
-        text: 'Specifies the Media Initialization Section (e.g., fMP4 "moov" box) required to parse the segments that follow. Essential for fMP4-based HLS.',
-        category: 'Media Segment',
-        ref: 'HLS 2nd Ed: 4.4.4.5',
-    },
-    'EXT-X-MAP@URI': {
-        text: 'A required quoted-string containing a URI that identifies a resource that contains the Media Initialization Section.',
-        category: 'Media Segment',
-        ref: 'HLS 2nd Ed: 4.4.4.5',
-    },
-    'EXT-X-PROGRAM-DATE-TIME': {
-        text: 'Associates the first sample of the next media segment with an absolute wall-clock time (ISO 8601). This provides the anchor for timeline synchronization.',
-        category: 'Media Segment',
-        ref: 'HLS 2nd Ed: 4.4.4.6',
-    },
-    'EXT-X-GAP': {
-        text: 'Indicates the segment URI it applies to is not available and SHOULD NOT be loaded. It represents a gap in the media timeline.',
-        category: 'Media Segment',
-        ref: 'HLS 2nd Ed: 4.4.4.7',
-    },
-    'EXT-X-PART': {
-        text: 'Identifies a Partial Segment, a smaller portion of a Media Segment. This is the core mechanism for delivering media chunks in Low-Latency HLS.',
-        category: 'Low-Latency HLS',
-        ref: 'HLS 2nd Ed: 4.4.4.9',
-    },
-    'EXT-X-PART@DURATION': {
-        text: 'The required duration of the Partial Segment in seconds.',
-        category: 'Low-Latency HLS',
-        ref: 'HLS 2nd Ed: 4.4.4.9',
-    },
-    'EXT-X-PART@INDEPENDENT': {
-        text: 'If YES, indicates the Partial Segment contains an I-frame, making it a valid entry point for playback.',
-        category: 'Low-Latency HLS',
-        ref: 'HLS 2nd Ed: 4.4.4.9',
-    },
-
-    // --- Media Metadata Tags ---
-    'EXT-X-DATERANGE': {
-        text: 'Associates a range of time with a set of custom attributes. Its primary use is for in-band ad signaling (SCTE-35) and other timed metadata events.',
-        category: 'Ad Insertion / Metadata',
-        ref: 'HLS 2nd Ed: 4.4.5.1',
-    },
-    'EXT-X-DATERANGE@ID': {
-        text: 'A required, unique identifier for this date range instance.',
-        category: 'Ad Insertion / Metadata',
-        ref: 'HLS 2nd Ed: 4.4.5.1',
-    },
-    'EXT-X-DATERANGE@CLASS': {
-        text: 'A client-defined string that specifies a set of attributes and their value semantics, e.g., "com.apple.hls.interstitial" for ads.',
-        category: 'Ad Insertion / Metadata',
-        ref: 'HLS 2nd Ed: 4.4.5.1',
-    },
-    'EXT-X-DATERANGE@START-DATE': {
-        text: 'A required ISO 8601 date specifying the beginning of the date range.',
-        category: 'Ad Insertion / Metadata',
-        ref: 'HLS 2nd Ed: 4.4.5.1',
-    },
-    'EXT-X-DATERANGE@X-ASSET-URI': {
-        text: '(Interstitial) An absolute URI for a single interstitial asset (e.g., an ad creative playlist).',
-        category: 'Ad Insertion / Metadata',
-        ref: 'HLS 2nd Ed: Appendix D.2',
-    },
-    'EXT-X-DATERANGE@X-RESUME-OFFSET': {
-        text: "(Interstitial) A time offset from the interstitial's start point at which primary content playback should resume.",
-        category: 'Ad Insertion / Metadata',
-        ref: 'HLS 2nd Ed: Appendix D.2',
-    },
-    'EXT-X-DATERANGE@X-RESTRICT': {
-        text: '(Interstitial) Navigation restrictions during interstitial playback. Valid values include SKIP and JUMP.',
-        category: 'Ad Insertion / Metadata',
-        ref: 'HLS 2nd Ed: Appendix D.2',
-    },
-    'EXT-X-SKIP': {
-        text: 'Used in a Playlist Delta Update to replace older Media Segments that have been skipped, making the playlist diff smaller.',
-        category: 'Low-Latency HLS',
-        ref: 'HLS 2nd Ed: 4.4.5.2',
-    },
-    'EXT-X-PRELOAD-HINT': {
-        text: 'Suggests that a client preload a resource before it appears in the main playlist, reducing latency on fetch. Core to Low-Latency HLS.',
-        category: 'Low-Latency HLS',
-        ref: 'HLS 2nd Ed: 4.4.5.3',
-    },
-    'EXT-X-RENDITION-REPORT': {
-        text: "Provides an up-to-date report on the last media sequence/part number of another rendition, allowing a client to make informed ABR switches in low-latency mode without fetching that rendition's playlist.",
-        category: 'Low-Latency HLS',
-        ref: 'HLS 2nd Ed: 4.4.5.4',
-    },
-
-    // --- Multivariant (Master) Playlist Tags ---
-    'EXT-X-MEDIA': {
-        text: 'Defines an alternative rendition for a specific content component (AUDIO, VIDEO, SUBTITLES, CLOSED-CAPTIONS) and groups them via a GROUP-ID.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.1',
-    },
-    'EXT-X-MEDIA@TYPE': {
-        text: 'A required enumerated-string specifying the media type: AUDIO, VIDEO, SUBTITLES, or CLOSED-CAPTIONS.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.1',
-    },
-    'EXT-X-MEDIA@URI': {
-        text: 'A quoted-string containing a URI that identifies the Media Playlist file for this rendition. Optional for AUDIO/VIDEO if multiplexed.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.1',
-    },
-    'EXT-X-MEDIA@GROUP-ID': {
-        text: 'A required string that logically groups a set of alternative renditions. An EXT-X-STREAM-INF tag refers to this ID to associate itself with the group.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.1',
-    },
-    'EXT-X-MEDIA@LANGUAGE': {
-        text: 'A quoted-string containing one of the standard Tags for Identifying Languages [RFC5646], which identifies the primary language used in the Rendition. This attribute is OPTIONAL.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.1',
-    },
-    'EXT-X-MEDIA@ASSOC-LANGUAGE': {
-        text: 'A quoted-string containing a language tag [RFC5646] that identifies a language that is associated with the Rendition. An associated language is often used in a different role than the language specified by the LANGUAGE attribute (e.g., written versus spoken, or a fallback dialect). This attribute is OPTIONAL.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.1',
-    },
-    'EXT-X-MEDIA@NAME': {
-        text: 'A required quoted-string containing a human-readable description of the Rendition. If the LANGUAGE attribute is present, then this description SHOULD be in that language.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.1',
-    },
-    'EXT-X-MEDIA@STABLE-RENDITION-ID': {
-        text: "A quoted-string which is a stable identifier for the URI within the Multivariant Playlist. All characters in the quoted-string MUST be from the following set: [a-z], [A-Z], [0-9], '+', '/', '=', '.', '-', and '_'. This attribute is OPTIONAL.",
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.1',
-    },
-    'EXT-X-MEDIA@DEFAULT': {
-        text: 'If YES, the client SHOULD play this Rendition in the absence of other user preferences. Valid values are YES and NO. Its absence indicates an implicit value of NO.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.1',
-    },
-    'EXT-X-MEDIA@AUTOSELECT': {
-        text: 'If YES, the client MAY choose to play this Rendition if it matches the current playback environment (e.g. system language) and no explicit user preference is set. Its absence indicates an implicit value of NO.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.1',
-    },
-    'EXT-X-MEDIA@FORCED': {
-        text: 'If YES, indicates the Rendition contains content considered essential to play (e.g. subtitles for foreign dialogue). Must only be present for SUBTITLES. Valid values are YES and NO.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.1',
-    },
-    'EXT-X-MEDIA@INSTREAM-ID': {
-        text: 'Specifies a Rendition within the segments in the Media Playlist, such as "CC1" for CEA-608 closed captions or "SERVICE1" for CEA-708.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.1',
-    },
-    'EXT-X-MEDIA@BIT-DEPTH': {
-        text: 'A non-negative decimal-integer specifying the audio bit depth of the Rendition. Allows players to select Renditions appropriate for available hardware.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.1',
-    },
-    'EXT-X-MEDIA@SAMPLE-RATE': {
-        text: 'A non-negative decimal-integer specifying the audio sample rate of the Rendition. Useful for identifying Renditions that can be played without sample rate conversion.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.1',
-    },
-    'EXT-X-MEDIA@CHARACTERISTICS': {
-        text: 'A comma-separated list of Uniform Type Identifiers (UTIs) indicating individual characteristics of the Rendition (e.g., "public.accessibility.describes-video").',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.1',
-    },
-    'EXT-X-MEDIA@CHANNELS': {
-        text: 'A quoted-string specifying an ordered, slash-separated list of parameters describing the audio channel configuration, starting with the channel count.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.1',
-    },
-    'EXT-X-STREAM-INF': {
-        text: 'Defines a Variant Stream, a specific combination of renditions at a given bandwidth. The URI of its primary Media Playlist follows on the next line.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.2',
-    },
-    'EXT-X-STREAM-INF@BANDWIDTH': {
-        text: 'A required integer specifying the peak bit rate of the Variant Stream in bits per second. This is the primary input for ABR algorithms.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.2',
-    },
-    'EXT-X-STREAM-INF@AVERAGE-BANDWIDTH': {
-        text: 'An optional integer specifying the average bit rate of the Variant Stream. Can provide a more stable metric for ABR logic than peak bandwidth.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.2',
-    },
-    'EXT-X-STREAM-INF@SCORE': {
-        text: "An optional floating-point value indicating the author's preference for this variant. Higher scores are better. Used to guide ABR decisions beyond just bandwidth.",
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.2',
-    },
-    'EXT-X-STREAM-INF@CODECS': {
-        text: 'A required, comma-separated list of RFC 6381 strings specifying all media sample types present in the Variant Stream.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.2',
-    },
-    'EXT-X-STREAM-INF@SUPPLEMENTAL-CODECS': {
-        text: 'Describes media with a base layer (in CODECS) and an enhancement layer (e.g., for HDR formats like Dolby Vision).',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.2',
-    },
-    'EXT-X-STREAM-INF@RESOLUTION': {
-        text: 'The optimal display resolution (width x height) for the video in this Variant Stream.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.2',
-    },
-    'EXT-X-STREAM-INF@FRAME-RATE': {
-        text: 'The maximum frame rate for all video in the Variant Stream, rounded to three decimal places.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.2',
-    },
-    'EXT-X-STREAM-INF@HDCP-LEVEL': {
-        text: 'Indicates that the stream may require a specific level of High-bandwidth Digital Content Protection (HDCP) to play.',
-        category: 'Encryption',
-        ref: 'HLS 2nd Ed: 4.4.6.2',
-    },
-    'EXT-X-STREAM-INF@VIDEO-RANGE': {
-        text: 'Specifies the video dynamic range. Valid values are SDR (Standard), HLG, and PQ (for HDR).',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.2',
-    },
-    'EXT-X-STREAM-INF@STABLE-VARIANT-ID': {
-        text: 'A stable identifier for this variant stream that persists across manifest reloads, crucial for content steering and offline scenarios.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.2',
-    },
-    'EXT-X-STREAM-INF@PATHWAY-ID': {
-        text: 'Associates the Variant Stream with a Content Steering Pathway, enabling server-side redundancy and load balancing.',
-        category: 'Client Control',
-        ref: 'HLS 2nd Ed: 4.4.6.2',
-    },
-    'EXT-X-STREAM-INF@AUDIO': {
-        text: 'A quoted-string matching a GROUP-ID of an EXT-X-MEDIA tag with TYPE=AUDIO, indicating the set of audio renditions for this variant.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.2.1',
-    },
-    'EXT-X-STREAM-INF@VIDEO': {
-        text: 'A quoted-string matching a GROUP-ID of an EXT-X-MEDIA tag with TYPE=VIDEO, indicating the set of video renditions for this variant.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.2.1',
-    },
-    'EXT-X-STREAM-INF@SUBTITLES': {
-        text: 'A quoted-string matching a GROUP-ID of an EXT-X-MEDIA tag with TYPE=SUBTITLES, indicating the set of subtitle renditions for this variant.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.2.1',
-    },
-    'EXT-X-STREAM-INF@CLOSED-CAPTIONS': {
-        text: 'A quoted-string matching a GROUP-ID of an EXT-X-MEDIA tag with TYPE=CLOSED-CAPTIONS, or NONE if no captions are available for this variant.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.2.1',
-    },
-    'EXT-X-I-FRAME-STREAM-INF': {
-        text: 'Identifies a standalone, I-frame-only Media Playlist for a particular Variant Stream. It is used to support client-side trick-play modes.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.3',
-    },
-    'EXT-X-SESSION-DATA': {
-        text: 'Allows arbitrary session data (e.g., a JSON object) to be carried in a Multivariant Playlist. Used for features like Localization Dictionaries or Custom Media Selection.',
-        category: 'Multivariant Playlist',
-        ref: 'HLS 2nd Ed: 4.4.6.4',
-    },
-    'EXT-X-SESSION-KEY': {
-        text: 'Specifies an encryption key that applies to the entire session. This allows clients to preload keys from the Multivariant Playlist before fetching media playlists.',
-        category: 'Encryption',
-        ref: 'HLS 2nd Ed: 4.4.6.5',
-    },
-    'EXT-X-CONTENT-STEERING': {
-        text: 'Provides a URI to a Content Steering Manifest, enabling dynamic, server-driven redirection of clients to alternate delivery pathways for improved reliability.',
-        category: 'Client Control',
-        ref: 'HLS 2nd Ed: 4.4.6.6',
-    },
-};
diff --git a/js/ui/views/interactive-manifest/index.js b/js/ui/views/interactive-manifest/index.js
deleted file mode 100644
index c0ba8fd..0000000
--- a/js/ui/views/interactive-manifest/index.js
+++ /dev/null
@@ -1,225 +0,0 @@
-import { html } from 'lit-html';
-import { useStore } from '../../../app/store.js';
-import { dashManifestTemplate } from './components/dash/renderer.js';
-import { hlsManifestTemplate } from './components/hls/renderer.js';
-import { debugLog } from '../../../shared/utils/debug.js';
-import { copyTextToClipboard } from '../../../shared/utils/clipboard.js';
-import { dashTooltipData } from './components/dash/tooltip-data.js';
-import { hlsTooltipData } from './components/hls/tooltip-data.js';
-
-// --- New Functions for Debug Report ---
-
-/**
- * Recursively walks a parsed DASH manifest object to find missing tooltip definitions.
- * @param {object} serializedManifest The root MPD element from fast-xml-parser.
- * @returns {{type: string, name: string}[]}
- */
-function findDashMissingTooltips(serializedManifest) {
-    const missing = [];
-    const seen = new Set(); // To avoid duplicate reports for the same key
-
-    const walk = (node, tagName) => {
-        if (!node || typeof node !== 'object') return;
-
-        // Check element tooltip
-        if (!dashTooltipData[tagName] && !seen.has(tagName)) {
-            missing.push({ type: 'Element', name: tagName });
-            seen.add(tagName);
-        }
-
-        // Check attributes
-        const attrs = node[':@'] || {};
-        for (const attrName in attrs) {
-            const attrKey = `${tagName}@${attrName}`;
-            const isIgnored = [
-                'xmlns',
-                'xmlns:xsi',
-                'xsi:schemaLocation',
-            ].includes(attrName);
-            if (!dashTooltipData[attrKey] && !isIgnored && !seen.has(attrKey)) {
-                missing.push({ type: 'Attribute', name: attrKey });
-                seen.add(attrKey);
-            }
-        }
-
-        // Recurse into children
-        for (const childName in node) {
-            if (childName === ':@' || childName === '#text') continue;
-
-            const children = Array.isArray(node[childName])
-                ? node[childName]
-                : [node[childName]];
-            children.forEach((childNode) => {
-                walk(childNode, childName);
-            });
-        }
-    };
-
-    walk(serializedManifest, 'MPD');
-    return missing;
-}
-
-/**
- * Walks a parsed HLS manifest object to find missing tooltip definitions.
- * @param {object} serializedManifest The parsed HLS object from the hls-parser.
- * @returns {{type: string, name: string}[]}
- */
-function findHlsMissingTooltips(serializedManifest) {
-    const missing = [];
-    const seen = new Set();
-
-    const checkAttributes = (tagName, attributesObject) => {
-        if (attributesObject && typeof attributesObject === 'object') {
-            for (const attrName in attributesObject) {
-                const attrKey = `${tagName}@${attrName}`;
-                if (!hlsTooltipData[attrKey] && !seen.has(attrKey)) {
-                    missing.push({ type: 'Attribute', name: attrKey });
-                    seen.add(attrKey);
-                }
-            }
-        }
-    };
-
-    // Check generic tags from the `tags` array
-    (serializedManifest.tags || []).forEach((tag) => {
-        const tagName = tag.name;
-        if (!hlsTooltipData[tagName] && !seen.has(tagName)) {
-            missing.push({ type: 'Tag', name: tagName });
-            seen.add(tagName);
-        }
-        checkAttributes(tagName, tag.value);
-    });
-
-    // Check EXT-X-MEDIA tags from the `media` array
-    (serializedManifest.media || []).forEach((mediaTag) => {
-        // The tag name is constant here.
-        checkAttributes('EXT-X-MEDIA', mediaTag);
-    });
-
-    // check EXT-X-STREAM-INF attributes which are stored under variants
-    (serializedManifest.variants || []).forEach((variant) => {
-        checkAttributes('EXT-X-STREAM-INF', variant.attributes);
-    });
-
-    return missing;
-}
-
-/**
- * Gathers manifest and missing tooltip data and copies it to the clipboard.
- * @param {import('../../../app/types.js').Stream} stream
- */
-const handleDebugCopy = (stream) => {
-    let manifestToCopy = stream.rawManifest;
-    let manifestObjectForAnalysis = stream.manifest.serializedManifest;
-
-    if (stream.protocol === 'hls' && stream.activeMediaPlaylistUrl) {
-        const mediaPlaylist = stream.mediaPlaylists.get(
-            stream.activeMediaPlaylistUrl
-        );
-        if (mediaPlaylist) {
-            manifestToCopy = mediaPlaylist.rawManifest;
-            manifestObjectForAnalysis =
-                mediaPlaylist.manifest.serializedManifest;
-        }
-    }
-
-    let missing = [];
-    if (stream.protocol === 'dash') {
-        missing = findDashMissingTooltips(manifestObjectForAnalysis);
-    } else if (stream.protocol === 'hls') {
-        missing = findHlsMissingTooltips(manifestObjectForAnalysis);
-    }
-
-    const report =
-        missing.length > 0
-            ? missing.map((m) => `[${m.type}] ${m.name}`).join('\n')
-            : 'No missing tooltips found.';
-
-    const debugString = `--- MANIFEST ---\n${manifestToCopy}\n\n--- MISSING TOOLTIPS (${missing.length}) ---\n${report}`;
-
-    copyTextToClipboard(debugString, 'Debug report copied to clipboard!');
-};
-
-/**
- * Dispatches to the correct manifest renderer based on stream protocol.
- * @param {import('../../../app/types.js').Stream} stream
- * @returns {import('lit-html').TemplateResult}
- */
-export function getInteractiveManifestTemplate(stream) {
-    debugLog(
-        'InteractiveManifest',
-        'getInteractiveManifestTemplate called.',
-        'Stream valid:',
-        !!stream,
-        'Manifest valid:',
-        !!stream?.manifest
-    );
-
-    if (!stream || !stream.manifest) {
-        debugLog(
-            'InteractiveManifest',
-            'Render condition failed: No stream or manifest.'
-        );
-        return html`<p class="warn">No Manifest loaded to display.</p>`;
-    }
-
-    const { interactiveManifestCurrentPage } = useStore.getState();
-
-    const handleCopyClick = () => {
-        let manifestToCopy = stream.rawManifest;
-        if (stream.protocol === 'hls' && stream.activeMediaPlaylistUrl) {
-            const mediaPlaylist = stream.mediaPlaylists.get(
-                stream.activeMediaPlaylistUrl
-            );
-            if (mediaPlaylist) {
-                manifestToCopy = mediaPlaylist.rawManifest;
-            }
-        }
-        copyTextToClipboard(manifestToCopy, 'Manifest copied to clipboard!');
-    };
-
-    const handleDebugCopyClick = () => {
-        handleDebugCopy(stream);
-    };
-
-    const headerTemplate = html`
-        <div class="flex justify-between items-center mb-2">
-            <h3 class="text-xl font-bold">Interactive Manifest</h3>
-            <div class="flex items-center gap-2">
-                <button
-                    @click=${handleCopyClick}
-                    class="bg-gray-600 hover:bg-gray-700 text-white font-bold text-xs py-1 px-3 rounded-md transition-colors"
-                >
-                    Copy Manifest
-                </button>
-                <button
-                    @click=${handleDebugCopyClick}
-                    class="bg-yellow-600 hover:bg-yellow-700 text-black font-bold text-xs py-1 px-3 rounded-md transition-colors"
-                >
-                    Copy Debug Report
-                </button>
-            </div>
-        </div>
-    `;
-
-    debugLog(
-        'InteractiveManifest',
-        `Dispatching to ${stream.protocol.toUpperCase()} renderer.`
-    );
-
-    let contentTemplate;
-    if (stream.protocol === 'hls') {
-        contentTemplate = hlsManifestTemplate(
-            stream,
-            interactiveManifestCurrentPage
-        );
-    } else {
-        // Default to DASH
-        contentTemplate = dashManifestTemplate(
-            stream,
-            interactiveManifestCurrentPage
-        );
-    }
-
-    return html`${headerTemplate} ${contentTemplate}`;
-}
diff --git a/js/ui/views/interactive-segment/components/interaction-logic.js b/js/ui/views/interactive-segment/components/interaction-logic.js
deleted file mode 100644
index 3a07cb3..0000000
--- a/js/ui/views/interactive-segment/components/interaction-logic.js
+++ /dev/null
@@ -1,177 +0,0 @@
-import { renderApp } from '../../../mainRenderer.js';
-
-let keydownListener = null;
-let containerListeners = new Map();
-
-// --- LOCAL MODULE STATE for the inspector panel ---
-let selectedItem = null;
-let highlightedItem = null;
-let highlightedField = null;
-
-export function getInspectorState() {
-    return {
-        // Return the selected item for stable display, but fall back to hovered item if nothing is selected
-        itemForDisplay: selectedItem || highlightedItem,
-        fieldForDisplay: highlightedField,
-    };
-}
-// --------------------------------------------------
-
-function cleanupEventListeners(container) {
-    if (keydownListener) {
-        document.removeEventListener('keydown', keydownListener);
-        keydownListener = null;
-    }
-    const listeners = containerListeners.get(container);
-    if (listeners) {
-        container.removeEventListener(
-            'mouseover',
-            listeners.delegatedMouseOver
-        );
-        container.removeEventListener('mouseout', listeners.delegatedMouseOut);
-        container.removeEventListener('click', listeners.handleClick);
-        containerListeners.delete(container);
-    }
-}
-
-export function cleanupSegmentViewInteractivity(dom) {
-    const container = dom.tabContents['interactive-segment'];
-    if (container) {
-        cleanupEventListeners(container);
-    }
-    // Reset local state when view is cleaned up
-    selectedItem = null;
-    highlightedItem = null;
-    highlightedField = null;
-}
-
-export function initializeSegmentViewInteractivity(
-    dom,
-    parsedSegmentData,
-    byteMap,
-    findDataByOffset
-) {
-    const container = dom.tabContents['interactive-segment'];
-    if (!container || !parsedSegmentData) return;
-
-    cleanupEventListeners(container);
-
-    const handleHover = (item, field) => {
-        highlightedItem = item;
-        highlightedField = field;
-        renderApp();
-    };
-
-    const handleSelection = (targetOffset) => {
-        if (selectedItem && selectedItem.offset === targetOffset) {
-            selectedItem = null; // Deselect
-        } else {
-            selectedItem = findDataByOffset(parsedSegmentData, targetOffset);
-        }
-        // Sync highlight with selection
-        highlightedItem = selectedItem;
-        highlightedField = null; // Clear field highlight on selection change
-        renderApp();
-    };
-
-    const handleHexHover = (e) => {
-        const target = /** @type {HTMLElement | null} */ (
-            e.target.closest('[data-byte-offset]')
-        );
-        if (!target) return;
-        const byteOffset = parseInt(target.dataset.byteOffset, 10);
-        const mapEntry = byteMap.get(byteOffset);
-        if (mapEntry) {
-            handleHover(mapEntry.box || mapEntry.packet, mapEntry.fieldName);
-        }
-    };
-
-    const handleInspectorHover = (e) => {
-        const fieldRow = /** @type {HTMLElement | null} */ (
-            e.target.closest('[data-field-name]')
-        );
-        if (!fieldRow) return;
-        const fieldName = fieldRow.dataset.fieldName;
-        const dataOffset = parseInt(
-            fieldRow.dataset.boxOffset || fieldRow.dataset.packetOffset,
-            10
-        );
-        if (isNaN(dataOffset)) return;
-        const item = findDataByOffset(parsedSegmentData, dataOffset);
-        if (item) handleHover(item, fieldName);
-    };
-
-    const handleStructureHover = (e) => {
-        const node = /** @type {HTMLElement | null} */ (
-            e.target.closest('[data-box-offset], [data-group-start-offset]')
-        );
-        if (!node) return;
-        const dataOffset = parseInt(
-            node.dataset.boxOffset || node.dataset.groupStartOffset,
-            10
-        );
-        if (isNaN(dataOffset)) return;
-        const item = findDataByOffset(parsedSegmentData, dataOffset);
-        const fieldName =
-            item?.type === 'CMAF Chunk'
-                ? 'Chunk'
-                : item?.type
-                  ? 'Box Header'
-                  : 'TS Header';
-        if (item) handleHover(item, fieldName);
-    };
-
-    const delegatedMouseOver = (e) => {
-        if (e.target.closest('.segment-inspector-panel'))
-            handleInspectorHover(e);
-        else if (e.target.closest('.box-tree-area, .packet-list-area'))
-            handleStructureHover(e);
-        else if (e.target.closest('#hex-grid-content')) handleHexHover(e);
-    };
-
-    const delegatedMouseOut = (e) => {
-        const relatedTarget = /** @type {Node | null} */ (e.relatedTarget);
-        const currentTarget = /** @type {Node} */ (e.currentTarget);
-        if (relatedTarget && currentTarget.contains(relatedTarget)) {
-            return; // Don't fire on mouseout to a child element
-        }
-        highlightedItem = null;
-        highlightedField = null;
-        renderApp();
-    };
-
-    const handleClick = (e) => {
-        const target = /** @type {HTMLElement} */ (e.target);
-        if (target.closest('summary')) e.preventDefault();
-        const targetNode = /** @type {HTMLElement | null} */ (
-            target.closest(
-                '[data-box-offset], [data-packet-offset], [data-group-start-offset]'
-            )
-        );
-        if (targetNode) {
-            const offset =
-                parseInt(targetNode.dataset.boxOffset, 10) ??
-                parseInt(targetNode.dataset.packetOffset, 10) ??
-                parseInt(targetNode.dataset.groupStartOffset, 10);
-            if (!isNaN(offset)) {
-                handleSelection(offset);
-            }
-        }
-    };
-
-    container.addEventListener('mouseover', delegatedMouseOver);
-    container.addEventListener('mouseout', delegatedMouseOut);
-    container.addEventListener('click', handleClick);
-    containerListeners.set(container, {
-        delegatedMouseOver,
-        delegatedMouseOut,
-        handleClick,
-    });
-
-    keydownListener = (e) => {
-        if (e.key === 'Escape' && selectedItem !== null) {
-            handleSelection(selectedItem.offset); // Deselect
-        }
-    };
-    document.addEventListener('keydown', keydownListener);
-}
diff --git a/js/ui/views/interactive-segment/components/isobmff/index.js b/js/ui/views/interactive-segment/components/isobmff/index.js
deleted file mode 100644
index cf6befb..0000000
--- a/js/ui/views/interactive-segment/components/isobmff/index.js
+++ /dev/null
@@ -1,320 +0,0 @@
-import { html } from 'lit-html';
-import { useStore, useSegmentCacheStore } from '../../../../../app/store.js';
-import { getTooltipData as getAllIsoTooltipData } from '../../../../../infrastructure/segment/isobmff/index.js';
-import { hexViewTemplate } from '../../../../components/hex-view.js';
-import { buildByteMap } from './view-model.js';
-import { getInspectorState } from '../interaction-logic.js';
-
-const allIsoTooltipData = getAllIsoTooltipData();
-const boxColors = [
-    { bg: 'bg-red-800', border: 'border-red-700' },
-    { bg: 'bg-yellow-800', border: 'border-yellow-700' },
-    { bg: 'bg-green-800', border: 'border-green-700' },
-    { bg: 'bg-blue-800', border: 'border-blue-700' },
-    { bg: 'bg-indigo-800', border: 'border-indigo-700' },
-    { bg: 'bg-purple-800', border: 'border-purple-700' },
-    { bg: 'bg-pink-800', border: 'border-pink-700' },
-    { bg: 'bg-teal-800', border: 'border-teal-700' },
-];
-const chunkColor = { bg: 'bg-slate-700', border: 'border-slate-600' };
-
-function findBox(boxes, predicate) {
-    for (const box of boxes) {
-        if (predicate(box)) return box;
-        if (box.children?.length > 0) {
-            const found = findBox(box.children, predicate);
-            if (found) return found;
-        }
-    }
-    return null;
-}
-
-export function findBoxByOffset(parsedData, offset) {
-    if (!parsedData || !parsedData.boxes) return null;
-    const findInGrouped = (grouped, off) => {
-        for (const item of grouped) {
-            if (item.offset === off) return item;
-            if (item.children?.length > 0) {
-                const found = findInGrouped(item.children, off);
-                if (found) return found;
-            }
-        }
-        return null;
-    };
-    const grouped = groupboxesIntoChunks(parsedData.boxes);
-    return findInGrouped(grouped, offset);
-}
-
-function assignBoxColors(boxes) {
-    const colorState = { index: 0 };
-    const traverse = (boxList, state) => {
-        for (const box of boxList) {
-            if (box.isChunk) {
-                box.color = chunkColor;
-                if (box.children?.length > 0) {
-                    traverse(box.children, state);
-                }
-            } else {
-                box.color = boxColors[state.index % boxColors.length];
-                state.index++;
-                if (box.children?.length > 0) {
-                    traverse(box.children, state);
-                }
-            }
-        }
-    };
-    if (boxes) {
-        traverse(boxes, colorState);
-    }
-}
-
-const getTimescaleForBox = (box, rootData) => {
-    if (!rootData || !rootData.boxes) return null;
-    const mdhd = findBox(rootData.boxes, (b) => b.type === 'mdhd');
-    if (mdhd) return mdhd.details?.timescale?.value;
-    return null;
-};
-
-function groupboxesIntoChunks(boxes) {
-    const grouped = [];
-    let i = 0;
-    while (i < boxes.length) {
-        const box = boxes[i];
-        if (box.type === 'moof' && boxes[i + 1]?.type === 'mdat') {
-            const mdat = boxes[i + 1];
-            grouped.push({
-                isChunk: true,
-                type: 'CMAF Chunk',
-                offset: box.offset,
-                size: box.size + mdat.size,
-                children: [box, mdat],
-                details: {
-                    info: {
-                        value: 'A logical grouping of a moof and mdat box, representing a single CMAF chunk.',
-                        offset: box.offset,
-                        length: 0,
-                    },
-                    size: {
-                        value: `${box.size + mdat.size} bytes`,
-                        offset: box.offset,
-                        length: 0,
-                    },
-                },
-                issues: [],
-            });
-            i += 2;
-        } else {
-            grouped.push(box);
-            i += 1;
-        }
-    }
-    return grouped;
-}
-
-const placeholderTemplate = () => html`
-    <div class="p-3 text-sm text-gray-500">
-        Hover over an item in the tree view or hex view to see details.
-    </div>
-`;
-
-const issuesTemplate = (issues) => {
-    if (!issues || issues.length === 0) return '';
-    return html`
-        <div class="p-3 border-b border-gray-700 bg-yellow-900/50">
-            <h4 class="font-bold text-yellow-300 text-sm mb-1">
-                Parsing Issues
-            </h4>
-            <ul class="list-disc pl-5 text-xs text-yellow-200">
-                ${issues.map(
-                    (issue) =>
-                        html`<li>
-                            <span class="font-semibold"
-                                >[${issue.type.toUpperCase()}]</span
-                            >
-                            ${issue.message}
-                        </li>`
-                )}
-            </ul>
-        </div>
-    `;
-};
-
-const renderBoxNode = (box) => {
-    const { itemForDisplay } = getInspectorState();
-    const isSelected = itemForDisplay?.offset === box.offset;
-    const isChunk = box.isChunk;
-    const selectionClass = isSelected
-        ? 'bg-blue-900/50 ring-1 ring-blue-500'
-        : 'hover:bg-gray-800/50';
-    const colorClass = box.color?.border || 'border-transparent';
-
-    return html`
-        <details class="box-node" ?open=${isChunk || box.children.length > 0}>
-            <summary
-                class="p-1 rounded cursor-pointer ${selectionClass} border-l-4 ${colorClass}"
-                data-box-offset=${box.offset}
-            >
-                <span class="font-mono text-sm text-white ml-2"
-                    >${box.type}</span
-                >
-                <span class="text-xs text-gray-500 ml-2"
-                    >(${box.size} bytes)</span
-                >
-            </summary>
-            ${box.children.length > 0
-                ? html`<ul class="pl-4 border-l border-gray-700 list-none ml-2">
-                      ${box.children.map(
-                          (child) => html`<li>${renderBoxNode(child)}</li>`
-                      )}
-                  </ul>`
-                : ''}
-        </details>
-    `;
-};
-
-const treeViewTemplate = (boxes) => {
-    if (!boxes || boxes.length === 0) return '';
-    return html`
-        <div
-            class="box-tree-area rounded-md bg-gray-900/90 border border-gray-700"
-        >
-            <h3 class="font-bold text-base p-2 border-b border-gray-700">
-                Box Structure
-            </h3>
-            <div class="p-2 overflow-y-auto max-h-96">
-                <ul class="list-none p-0">
-                    ${boxes.map((box) => html`<li>${renderBoxNode(box)}</li>`)}
-                </ul>
-            </div>
-        </div>
-    `;
-};
-
-const inspectorPanelTemplate = (rootData) => {
-    const { itemForDisplay, fieldForDisplay } = getInspectorState();
-    const box = itemForDisplay;
-
-    if (!box) return placeholderTemplate();
-    const boxInfo = allIsoTooltipData[box.type] || {};
-
-    const fields = Object.entries(box.details).map(([key, field]) => {
-        const highlightClass =
-            key === fieldForDisplay ? 'bg-purple-900/50' : '';
-        const fieldInfo = allIsoTooltipData[`${box.type}@${key}`];
-        let interpretedValue = html``;
-
-        if (key === 'baseMediaDecodeTime' && box.type === 'tfdt') {
-            const timescale = getTimescaleForBox(box, rootData);
-            if (timescale) {
-                interpretedValue = html`<span
-                    class="text-xs text-cyan-400 block mt-1"
-                    >(${(field.value / timescale).toFixed(3)} seconds)</span
-                >`;
-            }
-        }
-
-        return html`
-            <tr
-                class="${highlightClass}"
-                data-field-name="${key}"
-                data-box-offset="${box.offset}"
-            >
-                <td
-                    class="p-1 pr-2 text-xs text-gray-400 align-top"
-                    title="${fieldInfo?.text || ''}"
-                >
-                    ${key}
-                </td>
-                <td class="p-1 text-xs font-mono text-white break-all">
-                    ${field.value !== undefined ? String(field.value) : 'N/A'}
-                    ${interpretedValue}
-                </td>
-            </tr>
-        `;
-    });
-
-    return html`
-        <div class="p-3 border-b border-gray-700">
-            <div class="font-bold text-base mb-1">
-                ${box.type}
-                <span class="text-sm text-gray-400">(${box.size} bytes)</span>
-            </div>
-            <div class="text-xs text-emerald-400 mb-2 font-mono">
-                ${boxInfo.ref || ''}
-            </div>
-            <p class="text-xs text-gray-300">
-                ${boxInfo.text || 'No description available.'}
-            </p>
-        </div>
-        ${issuesTemplate(box.issues)}
-        <div class="overflow-y-auto">
-            <table class="w-full table-fixed">
-                <colgroup>
-                    <col class="w-2/5" />
-                    <col class="w-3/5" />
-                </colgroup>
-                <tbody>
-                    ${fields}
-                </tbody>
-            </table>
-        </div>
-    `;
-};
-
-export function getInteractiveIsobmffTemplate(
-    currentPage,
-    bytesPerPage,
-    onPageChange,
-    allTooltips,
-    inspectorState
-) {
-    const { activeSegmentUrl } = useStore.getState();
-    const { get: getFromCache } = useSegmentCacheStore.getState();
-    const cachedSegment = getFromCache(activeSegmentUrl);
-    const parsedSegmentData =
-        cachedSegment?.parsedData &&
-        cachedSegment.parsedData.format === 'isobmff'
-            ? cachedSegment.parsedData
-            : null;
-
-    if (!parsedSegmentData) {
-        return html`<div class="text-yellow-400 p-4">
-            Could not parse ISOBMFF data for this segment.
-        </div>`;
-    }
-
-    const groupedBoxes = groupboxesIntoChunks(
-        parsedSegmentData.data.boxes || []
-    );
-    assignBoxColors(groupedBoxes);
-    parsedSegmentData.byteMap = buildByteMap(groupedBoxes);
-
-    return html`
-        <div
-            class="grid grid-cols-1 lg:grid-cols-[minmax(300px,25%)_1fr] gap-4"
-        >
-            <div class="sticky top-4 h-max">
-                <div class="flex flex-col gap-4">
-                    <div
-                        class="segment-inspector-panel rounded-md bg-gray-900/90 border border-gray-700 transition-opacity duration-200 h-96 lg:h-[24rem] overflow-hidden flex flex-col"
-                    >
-                        ${inspectorPanelTemplate(parsedSegmentData.data)}
-                    </div>
-                    ${issuesTemplate(parsedSegmentData.data.issues)}
-                    ${treeViewTemplate(groupedBoxes)}
-                </div>
-            </div>
-            <div>
-                ${hexViewTemplate(
-                    cachedSegment.data,
-                    parsedSegmentData.byteMap,
-                    currentPage,
-                    bytesPerPage,
-                    onPageChange,
-                    allTooltips,
-                    inspectorState
-                )}
-            </div>
-        </div>
-    `;
-}
diff --git a/js/ui/views/interactive-segment/components/isobmff/view-model.js b/js/ui/views/interactive-segment/components/isobmff/view-model.js
deleted file mode 100644
index 11e4355..0000000
--- a/js/ui/views/interactive-segment/components/isobmff/view-model.js
+++ /dev/null
@@ -1,108 +0,0 @@
-/**
- * Generates a slightly different background color shade based on a field name by varying opacity.
- * @param {object} baseColor - The base color object with a 'bg' property (e.g., 'bg-red-500/20').
- * @param {string} fieldName - The name of the field to generate a shade for.
- * @param {number} fieldIndex - An index to ensure variation.
- * @returns {{bg: string, style: string}} A new color object with a base class and a style attribute for opacity.
- */
-function getFieldShade(baseColor, fieldName, fieldIndex) {
-    if (!baseColor || !baseColor.bg) {
-        return { bg: 'bg-gray-700', style: '--tw-bg-opacity: 0.5' }; // A safe default
-    }
-
-    const opacities = [0.1, 0.2, 0.3, 0.4];
-    const opacity = opacities[fieldIndex % opacities.length];
-    const baseClass = baseColor.bg.replace(/\/\d+/, '');
-
-    return { bg: baseClass, style: `--tw-bg-opacity: ${opacity}` };
-}
-
-/**
- * A utility to build a detailed map of every byte in an ISOBMFF segment,
- * associating it with its parent box, specific field, and assigned color.
- * This is crucial for interactive highlighting.
- * @param {Array<import('../../../../../infrastructure/segment/isobmff/parser.js').Box | object>} boxesOrChunks
- * @returns {Map<number, {box: import('../../../../../infrastructure/segment/isobmff/parser.js').Box, fieldName: string, color: {bg: string, style: string}}>}
- */
-export function buildByteMap(boxesOrChunks) {
-    const byteMap = new Map();
-
-    /**
-     * @param {import('../../../../../infrastructure/segment/isobmff/parser.js').Box} box
-     */
-    const traverse = (box) => {
-        // Post-order traversal: children paint first, then parent fills the gaps.
-
-        // 1. Recurse into children. They get first dibs on the byte map.
-        if (box.children?.length > 0) {
-            for (const child of box.children) {
-                traverse(child);
-            }
-        }
-
-        // 2. After children have painted, fill in this box's content area
-        // where no children have painted.
-        const contentColor = getFieldShade(box.color, 'Box Content', 0);
-        for (
-            let i = box.offset + box.headerSize;
-            i < box.offset + box.size;
-            i++
-        ) {
-            if (!byteMap.has(i)) {
-                byteMap.set(i, {
-                    box,
-                    fieldName: 'Box Content',
-                    color: contentColor,
-                });
-            }
-        }
-
-        // 3. Finally, paint this box's own fields and header. This will
-        // overwrite the generic content fill for this box, but not for children.
-        const headerColor = getFieldShade(box.color, 'Box Header', 1);
-        for (let i = box.offset; i < box.offset + box.headerSize; i++) {
-            byteMap.set(i, {
-                box,
-                fieldName: 'Box Header',
-                color: headerColor,
-            });
-        }
-
-        if (box.details) {
-            let fieldIndex = 2; // Start after content and header
-            for (const [fieldName, fieldMeta] of Object.entries(box.details)) {
-                if (
-                    fieldMeta.offset !== undefined &&
-                    fieldMeta.length !== undefined &&
-                    fieldMeta.length > 0
-                ) {
-                    const fieldColor = getFieldShade(
-                        box.color,
-                        fieldName,
-                        fieldIndex++
-                    );
-
-                    const lengthInBytes = Math.ceil(fieldMeta.length);
-                    for (
-                        let i = fieldMeta.offset;
-                        i < fieldMeta.offset + lengthInBytes;
-                        i++
-                    ) {
-                        byteMap.set(i, {
-                            box,
-                            fieldName: fieldName,
-                            color: fieldColor,
-                        });
-                    }
-                }
-            }
-        }
-    };
-
-    if (boxesOrChunks) {
-        for (const item of boxesOrChunks) {
-            traverse(item);
-        }
-    }
-    return byteMap;
-}
diff --git a/js/ui/views/interactive-segment/components/ts/index.js b/js/ui/views/interactive-segment/components/ts/index.js
deleted file mode 100644
index dd2ea28..0000000
--- a/js/ui/views/interactive-segment/components/ts/index.js
+++ /dev/null
@@ -1,303 +0,0 @@
-import { html, render } from 'lit-html';
-import { useStore, useSegmentCacheStore } from '../../../../../app/store.js';
-import { hexViewTemplate } from '../../../../components/hex-view.js';
-import { buildByteMapTs } from './view-model.js';
-import { getInspectorState } from '../interaction-logic.js';
-
-let packetCurrentPage = 1;
-const PACKETS_PER_PAGE = 50;
-
-export function findPacketByOffset(parsedData, offset) {
-    if (!parsedData?.data?.packets) return null;
-    let packet = parsedData.data.packets.find((p) => p.offset === offset);
-    if (packet) return packet;
-    // Fallback for clicking inside a packet
-    return (
-        parsedData.data.packets.find(
-            (p) => offset > p.offset && offset < p.offset + 188
-        ) || null
-    );
-}
-
-const groupPackets = (packets) => {
-    return packets.reduce((acc, packet) => {
-        const type = packet.payloadType || 'Unknown';
-        if (!acc[type]) {
-            acc[type] = [];
-        }
-        acc[type].push(packet);
-        return acc;
-    }, {});
-};
-
-const inspectorDetailRow = (packet, key, value) => {
-    return html`
-        <tr
-            class="hover:bg-purple-900/50"
-            data-field-name="${key}"
-            data-packet-offset="${packet.offset}"
-        >
-            <td class="p-1 pr-2 text-xs text-gray-400 align-top">${key}</td>
-            <td class="p-1 text-xs font-mono text-white break-all">
-                ${String(value)}
-            </td>
-        </tr>
-    `;
-};
-
-const placeholderTemplate = () => {
-    return html`
-        <div class="p-3 text-sm text-gray-500">
-            Hover over an item in the packet list or hex view to see details.
-        </div>
-    `;
-};
-
-export const inspectorPanelTemplate = () => {
-    const { itemForDisplay } = getInspectorState();
-    const packet = itemForDisplay;
-
-    if (!packet) return placeholderTemplate();
-
-    return html`
-        <div class="p-3 border-b border-gray-700">
-            <div class="font-bold text-base mb-1">
-                Packet @${packet.offset} (PID: ${packet.pid})
-            </div>
-            <p class="text-xs text-gray-300">${packet.payloadType}</p>
-        </div>
-        <div class="overflow-y-auto">
-            <table class="w-full table-fixed">
-                <colgroup>
-                    <col class="w-2/5" />
-                    <col class="w-3/5" />
-                </colgroup>
-                <tbody>
-                    ${Object.entries(packet.header).map(([key, value]) =>
-                        inspectorDetailRow(
-                            packet,
-                            `Header: ${key}`,
-                            value.value
-                        )
-                    )}
-                    ${packet.adaptationField
-                        ? Object.entries(packet.adaptationField)
-                              .map(([key, value]) => {
-                                  if (
-                                      typeof value.value === 'object' &&
-                                      value.value !== null
-                                  ) {
-                                      return Object.entries(value.value).map(
-                                          ([subKey, subValue]) =>
-                                              inspectorDetailRow(
-                                                  packet,
-                                                  `AF.${key}.${subKey}`,
-                                                  subValue.value
-                                              )
-                                      );
-                                  }
-                                  return inspectorDetailRow(
-                                      packet,
-                                      `AF: ${key}`,
-                                      value.value
-                                  );
-                              })
-                              .flat()
-                        : ''}
-                    ${packet.pes
-                        ? Object.entries(packet.pes).map(([key, value]) =>
-                              inspectorDetailRow(
-                                  packet,
-                                  `PES: ${key}`,
-                                  value.value
-                              )
-                          )
-                        : ''}
-                </tbody>
-            </table>
-        </div>
-    `;
-};
-
-const summaryTemplate = (summary) => {
-    const pmtPid = [...summary.pmtPids][0];
-    const program = pmtPid ? summary.programMap[pmtPid] : null;
-    const pidTypes = {};
-    if (program) {
-        Object.assign(pidTypes, program.streams);
-        if (summary.pcrPid) {
-            pidTypes[summary.pcrPid] = `${
-                pidTypes[summary.pcrPid] || 'Unknown'
-            } (PCR)`;
-        }
-    }
-    pidTypes[0] = 'PAT';
-    summary.pmtPids.forEach((pid) => (pidTypes[pid] = 'PMT'));
-
-    return html`
-        <div
-            class="rounded-md bg-gray-900/90 border border-gray-700"
-            data-testid="ts-summary-panel"
-        >
-            <h3 class="font-bold text-base p-2 border-b border-gray-700">
-                Transport Stream Summary
-            </h3>
-            <div class="p-2 text-xs space-y-2">
-                <div>Total Packets: ${summary.totalPackets}</div>
-                <div>PCR PID: ${summary.pcrPid || 'N/A'}</div>
-                <div>Program #: ${program?.programNumber || 'N/A'}</div>
-                ${summary.errors.length > 0
-                    ? html`<div class="text-red-400">
-                          Errors: ${summary.errors.join(', ')}
-                      </div>`
-                    : ''}
-            </div>
-        </div>
-    `;
-};
-
-const packetListTemplate = (packets, onPageChange) => {
-    const totalPages = Math.ceil(packets.length / PACKETS_PER_PAGE);
-    const startIndex = (packetCurrentPage - 1) * PACKETS_PER_PAGE;
-    const endIndex = startIndex + PACKETS_PER_PAGE;
-    const visiblePackets = packets.slice(startIndex, endIndex);
-
-    return html`
-        <div
-            class="packet-list-area rounded-md bg-gray-900/90 border border-gray-700 flex flex-col"
-        >
-            <h3 class="font-bold text-base p-2 border-b border-gray-700">
-                Packet List
-            </h3>
-            <div class="overflow-y-auto max-h-96 text-xs flex-grow">
-                ${Object.entries(groupPackets(visiblePackets)).map(
-                    ([type, pkts]) => html`
-                        <details open>
-                            <summary
-                                class="p-2 font-semibold bg-gray-800/50 sticky top-0 cursor-pointer"
-                            >
-                                ${type} (${pkts.length})
-                            </summary>
-                            <ul class="list-none p-0">
-                                ${pkts.map(
-                                    (p) => html`
-                                        <li
-                                            class="flex justify-between p-2 border-b border-gray-800 hover:bg-slate-700"
-                                            data-packet-offset=${p.offset}
-                                        >
-                                            <span class="font-mono"
-                                                >@${p.offset}</span
-                                            >
-                                            <span class="font-mono"
-                                                >PID: ${p.pid}</span
-                                            >
-                                        </li>
-                                    `
-                                )}
-                            </ul>
-                        </details>
-                    `
-                )}
-            </div>
-            ${totalPages > 1
-                ? html`<div
-                      class="text-center p-1 border-t border-gray-700 flex-shrink-0"
-                  >
-                      <button
-                          @click=${() => onPageChange(-1)}
-                          ?disabled=${packetCurrentPage === 1}
-                      >
-                          &lt;
-                      </button>
-                      Page ${packetCurrentPage} of ${totalPages}
-                      <button
-                          @click=${() => onPageChange(1)}
-                          ?disabled=${packetCurrentPage === totalPages}
-                      >
-                          &gt;
-                      </button>
-                  </div>`
-                : ''}
-        </div>
-    `;
-};
-
-export function getInteractiveTsTemplate(
-    currentPage,
-    bytesPerPage,
-    onHexPageChange,
-    allTooltips,
-    inspectorState
-) {
-    const { activeSegmentUrl } = useStore.getState();
-    const { get: getFromCache } = useSegmentCacheStore.getState();
-    const cachedSegment = getFromCache(activeSegmentUrl);
-    const tsAnalysisData =
-        cachedSegment?.parsedData && cachedSegment.parsedData.format === 'ts'
-            ? cachedSegment.parsedData
-            : null;
-
-    if (!tsAnalysisData || !tsAnalysisData.data) {
-        return html`<div class="text-yellow-400 p-4">
-            Could not parse Transport Stream data for this segment.
-        </div>`;
-    }
-
-    tsAnalysisData.byteMap = buildByteMapTs(tsAnalysisData);
-
-    const onPacketPageChange = (offset) => {
-        const totalPages = Math.ceil(
-            tsAnalysisData.data.packets.length / PACKETS_PER_PAGE
-        );
-        const newPage = packetCurrentPage + offset;
-        if (newPage >= 1 && newPage <= totalPages) {
-            packetCurrentPage = newPage;
-            // Re-render the container
-            const container = document.getElementById(
-                'tab-interactive-segment'
-            );
-            if (container) {
-                render(
-                    getInteractiveTsTemplate(
-                        currentPage,
-                        bytesPerPage,
-                        onHexPageChange,
-                        allTooltips,
-                        inspectorState
-                    ),
-                    container
-                );
-            }
-        }
-    };
-
-    return html`
-        <div
-            class="grid grid-cols-1 lg:grid-cols-[minmax(400px,35%)_1fr] gap-6"
-        >
-            <div class="sticky top-4 h-max flex flex-col gap-4">
-                <div
-                    class="segment-inspector-panel rounded-md bg-gray-900/90 border border-gray-700 transition-opacity duration-200 h-96 lg:h-[24rem] overflow-hidden flex flex-col"
-                >
-                    ${inspectorPanelTemplate()}
-                </div>
-                ${summaryTemplate(tsAnalysisData.data.summary)}
-                ${packetListTemplate(
-                    tsAnalysisData.data.packets,
-                    onPacketPageChange
-                )}
-            </div>
-            <div>
-                ${hexViewTemplate(
-                    cachedSegment.data,
-                    tsAnalysisData.byteMap,
-                    currentPage,
-                    bytesPerPage,
-                    onHexPageChange,
-                    allTooltips,
-                    inspectorState
-                )}
-            </div>
-        </div>
-    `;
-}
diff --git a/js/ui/views/interactive-segment/components/ts/view-model.js b/js/ui/views/interactive-segment/components/ts/view-model.js
deleted file mode 100644
index 5461be3..0000000
--- a/js/ui/views/interactive-segment/components/ts/view-model.js
+++ /dev/null
@@ -1,141 +0,0 @@
-/**
- * A utility to build a detailed map of every byte in a Transport Stream segment,
- * associating it with its parent packet, specific field, and a color code for highlighting.
- * @param {object} parsedData - The parsed TS data object from the worker.
- * @returns {Map<number, {packet: object, fieldName: string, color: object}>}
- */
-export function buildByteMapTs(parsedData) {
-    const byteMap = new Map();
-    const colors = {
-        header: { bg: 'bg-blue-900/30' },
-        af: { bg: 'bg-yellow-900/30' },
-        pcr: { bg: 'bg-yellow-700/30' },
-        pes: { bg: 'bg-purple-900/30' },
-        pts: { bg: 'bg-purple-700/30' },
-        dts: { bg: 'bg-purple-600/30' },
-        psi: { bg: 'bg-green-900/30' },
-        payload: { bg: 'bg-gray-800/20' },
-        stuffing: { bg: 'bg-gray-700/20' },
-        pointer: { bg: 'bg-cyan-900/30' },
-        null: { bg: 'bg-gray-900/40' },
-    };
-
-    if (!parsedData || !parsedData.data || !parsedData.data.packets) {
-        return byteMap;
-    }
-
-    parsedData.data.packets.forEach((packet) => {
-        // Map header bytes
-        for (let i = 0; i < 4; i++) {
-            byteMap.set(packet.offset + i, {
-                packet,
-                fieldName: 'TS Header',
-                color: colors.header,
-            });
-        }
-
-        let payloadStart = packet.offset + 4;
-
-        // Map adaptation field if it exists
-        if (packet.adaptationField) {
-            const af = packet.adaptationField;
-            const afOffset = packet.fieldOffsets.adaptationField.offset;
-            const afLength = af.length.value + 1;
-            payloadStart = afOffset + afLength;
-
-            for (let i = 0; i < afLength; i++) {
-                byteMap.set(afOffset + i, {
-                    packet,
-                    fieldName: 'Adaptation Field',
-                    color: colors.af,
-                });
-            }
-
-            // Override with more specific fields within the AF
-            if (af.pcr) {
-                for (let i = 0; i < af.pcr.length; i++) {
-                    byteMap.set(af.pcr.offset + i, {
-                        packet,
-                        fieldName: 'PCR',
-                        color: colors.pcr,
-                    });
-                }
-            }
-            if (af.stuffing_bytes) {
-                for (let i = 0; i < af.stuffing_bytes.length; i++) {
-                    byteMap.set(af.stuffing_bytes.offset + i, {
-                        packet,
-                        fieldName: 'Stuffing',
-                        color: colors.stuffing,
-                    });
-                }
-            }
-        }
-
-        // Map pointer field if payload unit start indicator is set
-        if (packet.fieldOffsets.pointerField) {
-            const { offset, length } = packet.fieldOffsets.pointerField;
-            for (let i = 0; i < length; i++) {
-                byteMap.set(offset + i, {
-                    packet,
-                    fieldName: 'Pointer Field & Stuffing',
-                    color: colors.pointer,
-                });
-            }
-            payloadStart = offset + length;
-        }
-
-        // Map payload
-        for (let i = payloadStart; i < packet.offset + 188; i++) {
-            if (byteMap.has(i)) continue; // Don't overwrite more specific fields
-
-            let fieldName = 'Payload';
-            let color = colors.payload;
-
-            if (packet.pid === 0x1fff) {
-                fieldName = 'Null Packet Payload';
-                color = colors.null;
-            } else if (packet.psi) {
-                fieldName = `PSI (${packet.psi.type})`;
-                color = colors.psi;
-            } else if (packet.pes) {
-                fieldName = 'PES Payload';
-                color = colors.payload;
-            }
-
-            byteMap.set(i, { packet, fieldName, color });
-        }
-
-        // Override payload with PES header if present
-        if (packet.pes && packet.fieldOffsets.pesHeader) {
-            const { offset, length } = packet.fieldOffsets.pesHeader;
-            for (let i = 0; i < length; i++) {
-                byteMap.set(offset + i, {
-                    packet,
-                    fieldName: 'PES Header',
-                    color: colors.pes,
-                });
-            }
-            if (packet.pes.pts) {
-                for (let i = 0; i < packet.pes.pts.length; i++) {
-                    byteMap.set(packet.pes.pts.offset + i, {
-                        packet,
-                        fieldName: 'PTS',
-                        color: colors.pts,
-                    });
-                }
-            }
-            if (packet.pes.dts) {
-                for (let i = 0; i < packet.pes.dts.length; i++) {
-                    byteMap.set(packet.pes.dts.offset + i, {
-                        packet,
-                        fieldName: 'DTS',
-                        color: colors.dts,
-                    });
-                }
-            }
-        }
-    });
-
-    return byteMap;
-}
diff --git a/js/ui/views/interactive-segment/components/vtt/index.js b/js/ui/views/interactive-segment/components/vtt/index.js
deleted file mode 100644
index 88a4105..0000000
--- a/js/ui/views/interactive-segment/components/vtt/index.js
+++ /dev/null
@@ -1,36 +0,0 @@
-import { html } from 'lit-html';
-import { unsafeHTML } from 'lit-html/directives/unsafe-html.js';
-import { highlightHls } from '../../../../shared/syntax-highlighter.js';
-
-/**
- * Renders the raw text content of a VTT file with line numbers.
- * @param {ArrayBuffer} buffer - The raw ArrayBuffer data of the VTT segment.
- * @returns {import('lit-html').TemplateResult}
- */
-export function getInteractiveVttTemplate(buffer) {
-    const decoder = new TextDecoder();
-    const vttString = decoder.decode(buffer);
-    const lines = vttString.split(/\r?\n/);
-
-    // VTT highlighting is very similar to HLS, so we can reuse the highlighter.
-    const highlightedLines = lines.map(
-        (line, index) =>
-            html`<div class="flex">
-                <span
-                    class="text-right text-gray-500 pr-4 select-none flex-shrink-0 w-10"
-                    >${index + 1}</span
-                >
-                <span class="flex-grow whitespace-pre-wrap break-all"
-                    >${unsafeHTML(highlightHls(line))}</span
-                >
-            </div>`
-    );
-
-    return html`
-        <div
-            class="bg-slate-800 rounded-lg p-4 font-mono text-sm leading-relaxed overflow-x-auto"
-        >
-            ${highlightedLines}
-        </div>
-    `;
-}
diff --git a/js/ui/views/interactive-segment/index.js b/js/ui/views/interactive-segment/index.js
deleted file mode 100644
index 4898aaa..0000000
--- a/js/ui/views/interactive-segment/index.js
+++ /dev/null
@@ -1,178 +0,0 @@
-import { html } from 'lit-html';
-import {
-    useStore,
-    storeActions,
-    useSegmentCacheStore,
-} from '../../../app/store.js';
-import {
-    getInteractiveIsobmffTemplate,
-    findBoxByOffset,
-} from './components/isobmff/index.js';
-import {
-    getInteractiveTsTemplate,
-    findPacketByOffset,
-} from './components/ts/index.js';
-import {
-    cleanupSegmentViewInteractivity,
-    initializeSegmentViewInteractivity,
-    getInspectorState,
-} from './components/interaction-logic.js';
-import { getInteractiveVttTemplate } from './components/vtt/index.js';
-import { getTooltipData as getIsobmffTooltipData } from '../../../infrastructure/segment/isobmff/index.js';
-import { getTooltipData as getTsTooltipData } from '../../../infrastructure/segment/ts/index.js';
-
-let lastProcessedSegmentUrl = null;
-const HEX_BYTES_PER_PAGE = 1024;
-
-const ALL_TOOLTIPS_DATA = {
-    ...getIsobmffTooltipData(),
-    ...getTsTooltipData(),
-};
-
-let isInitialized = false;
-
-function initializeAllInteractivity(dom, cachedSegment) {
-    if (isInitialized) return;
-
-    let byteMap, findFn, parsedDataForLogic;
-    if (cachedSegment.parsedData?.format === 'ts') {
-        const tsData = cachedSegment.parsedData;
-        byteMap = tsData.byteMap;
-        findFn = findPacketByOffset;
-        parsedDataForLogic = tsData;
-    } else if (cachedSegment.parsedData?.format === 'isobmff') {
-        const isobmffData = cachedSegment.parsedData;
-        byteMap = isobmffData.byteMap;
-        findFn = findBoxByOffset;
-        parsedDataForLogic = isobmffData.data;
-    }
-
-    if (byteMap && findFn && parsedDataForLogic) {
-        initializeSegmentViewInteractivity(
-            dom,
-            parsedDataForLogic,
-            byteMap,
-            findFn
-        );
-        isInitialized = true;
-    }
-}
-
-export function getInteractiveSegmentTemplate(dom) {
-    const { activeSegmentUrl, interactiveSegmentCurrentPage } =
-        useStore.getState();
-    const { get: getFromCache } = useSegmentCacheStore.getState();
-
-    if (activeSegmentUrl !== lastProcessedSegmentUrl) {
-        cleanupSegmentViewInteractivity(dom);
-        isInitialized = false; // Reset for the new segment
-        lastProcessedSegmentUrl = activeSegmentUrl;
-        // The page is now reset automatically by the `setActiveSegmentUrl` action.
-    }
-
-    if (!activeSegmentUrl) {
-        return html`
-            <div class="text-center py-12">
-                <div class="text-gray-400 text-lg mb-4">
-                    📄 Interactive Segment View
-                </div>
-                <p class="text-gray-500">
-                    Select a segment from the "Segment Explorer" tab and click
-                    "View Raw" to inspect its content here.
-                </p>
-            </div>
-        `;
-    }
-
-    const cachedSegment = getFromCache(activeSegmentUrl);
-
-    if (!cachedSegment || cachedSegment.status === -1) {
-        return html`
-            <div class="text-center py-12">
-                <div
-                    class="animate-spin inline-block w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full mb-4"
-                ></div>
-                <p class="text-gray-400">Loading and parsing segment data...</p>
-            </div>
-        `;
-    }
-
-    if (cachedSegment.status !== 200 || !cachedSegment.data) {
-        return html`
-            <div class="text-center py-12">
-                <div class="text-red-400 text-lg mb-2">❌ Failed to Load</div>
-                <p class="text-gray-400">
-                    Failed to fetch segment. Status:
-                    ${cachedSegment.status || 'Network Error'}.
-                </p>
-            </div>
-        `;
-    }
-
-    const onPageChange = (offset) => {
-        const totalPages = Math.ceil(
-            cachedSegment.data.byteLength / HEX_BYTES_PER_PAGE
-        );
-        const newPage = interactiveSegmentCurrentPage + offset;
-        if (newPage >= 1 && newPage <= totalPages) {
-            isInitialized = false;
-            storeActions.setInteractiveSegmentPage(newPage);
-        }
-    };
-
-    let contentTemplate;
-    const inspectorState = getInspectorState();
-
-    if (cachedSegment.parsedData?.format === 'vtt') {
-        contentTemplate = getInteractiveVttTemplate(cachedSegment.data);
-    } else if (cachedSegment.parsedData?.format === 'ts') {
-        contentTemplate = getInteractiveTsTemplate(
-            interactiveSegmentCurrentPage,
-            HEX_BYTES_PER_PAGE,
-            onPageChange,
-            ALL_TOOLTIPS_DATA,
-            inspectorState
-        );
-    } else if (cachedSegment.parsedData?.format === 'isobmff') {
-        contentTemplate = getInteractiveIsobmffTemplate(
-            interactiveSegmentCurrentPage,
-            HEX_BYTES_PER_PAGE,
-            onPageChange,
-            ALL_TOOLTIPS_DATA,
-            inspectorState
-        );
-    } else {
-        contentTemplate = html`<div class="text-yellow-400 p-4">
-            Interactive view not supported for this segment format.
-        </div>`;
-    }
-
-    // Defer initialization until after the first render of the new segment
-    setTimeout(() => initializeAllInteractivity(dom, cachedSegment), 0);
-
-    return html`
-        <div class="mb-6">
-            <div class="flex justify-between items-center mb-2">
-                <h3 class="text-xl font-bold text-white">
-                    🔍 Interactive Segment View
-                </h3>
-                <button
-                    @click=${() =>
-                        /** @type {HTMLElement} */ (
-                            document.querySelector('[data-tab="explorer"]')
-                        )?.click()}
-                    class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 text-sm"
-                >
-                    &larr; Back to Segment Explorer
-                </button>
-            </div>
-
-            <p
-                class="text-sm text-gray-400 mb-4 font-mono break-all bg-gray-800 p-2 rounded"
-            >
-                ${activeSegmentUrl}
-            </p>
-        </div>
-        ${contentTemplate}
-    `;
-}
diff --git a/js/ui/views/manifest-updates/index.js b/js/ui/views/manifest-updates/index.js
deleted file mode 100644
index 01d3853..0000000
--- a/js/ui/views/manifest-updates/index.js
+++ /dev/null
@@ -1,111 +0,0 @@
-import { html } from 'lit-html';
-import { unsafeHTML } from 'lit-html/directives/unsafe-html.js';
-import { useStore, storeActions } from '../../../app/store.js';
-import { copyTextToClipboard } from '../../../shared/utils/clipboard.js';
-
-export function navigateManifestUpdates(direction) {
-    const { activeStreamId } = useStore.getState();
-    storeActions.navigateManifestUpdate(activeStreamId, direction);
-}
-
-export const manifestUpdatesTemplate = (stream) => {
-    if (!stream) {
-        return html`<p class="warn">No active stream to monitor.</p>`;
-    }
-    if (stream.manifest.type !== 'dynamic') {
-        return html`<p class="info">
-            This is a VOD/static manifest. No updates are expected.
-        </p>`;
-    }
-
-    const { manifestUpdates, activeManifestUpdateIndex } = stream;
-    const updateCount = manifestUpdates.length;
-
-    if (updateCount === 0) {
-        return html`<div id="mpd-updates-content">
-            <p class="info">Awaiting first manifest update...</p>
-        </div>`;
-    }
-
-    const currentIndex = updateCount - activeManifestUpdateIndex;
-    const currentUpdate = manifestUpdates[activeManifestUpdateIndex];
-    const lines = currentUpdate.diffHtml.split('\n');
-    const updateLabel =
-        activeManifestUpdateIndex === manifestUpdates.length - 1
-            ? 'Initial Manifest loaded:'
-            : 'Update received at:';
-
-    const handleCopyClick = () => {
-        if (currentUpdate) {
-            copyTextToClipboard(
-                currentUpdate.rawManifest,
-                'Manifest version copied to clipboard!'
-            );
-        }
-    };
-
-    const currentDisplay = html` <div class="text-sm text-gray-400 mb-2">
-            ${updateLabel}
-            <span class="font-semibold text-gray-200"
-                >${currentUpdate.timestamp}</span
-            >
-        </div>
-        <div
-            class="bg-slate-800 rounded-lg p-4 font-mono text-sm leading-relaxed overflow-x-auto"
-        >
-            ${lines.map(
-                (line, i) => html`
-                    <div class="flex">
-                        <span
-                            class="text-right text-gray-500 pr-4 select-none flex-shrink-0 w-10"
-                            >${i + 1}</span
-                        >
-                        <span class="flex-grow whitespace-pre-wrap break-all"
-                            >${unsafeHTML(line)}</span
-                        >
-                    </div>
-                `
-            )}
-        </div>`;
-
-    return html` <div id="mpd-updates-content">
-        <div
-            class="flex flex-col sm:flex-row justify-between items-center mb-4 space-y-2 sm:space-y-0"
-        >
-            <button
-                @click=${handleCopyClick}
-                class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-3 rounded-md transition-colors"
-            >
-                Copy This Version
-            </button>
-            <div class="flex items-center space-x-2">
-                <button
-                    id="prev-manifest-btn"
-                    class="px-4 py-2 rounded-md font-bold transition duration-300 text-white bg-gray-600 hover:bg-gray-700 disabled:opacity-50"
-                    title="Previous Update (Right Arrow)"
-                    ?disabled=${activeManifestUpdateIndex >= updateCount - 1}
-                    @click=${() => navigateManifestUpdates(1)}
-                >
-                    &lt;
-                </button>
-                <span
-                    id="manifest-index-display"
-                    class="text-gray-400 font-semibold w-16 text-center"
-                    >${currentIndex}/${updateCount}</span
-                >
-                <button
-                    id="next-manifest-btn"
-                    class="px-4 py-2 rounded-md font-bold transition duration-300 text-white bg-gray-600 hover:bg-gray-700 disabled:opacity-50"
-                    title="Next Update (Left Arrow)"
-                    ?disabled=${activeManifestUpdateIndex <= 0}
-                    @click=${() => navigateManifestUpdates(-1)}
-                >
-                    &gt;
-                </button>
-            </div>
-        </div>
-        <div id="current-manifest-update" class="manifest-update-entry">
-            ${currentDisplay}
-        </div>
-    </div>`;
-};
diff --git a/js/ui/views/parser-coverage/index.js b/js/ui/views/parser-coverage/index.js
deleted file mode 100644
index e298b1c..0000000
--- a/js/ui/views/parser-coverage/index.js
+++ /dev/null
@@ -1,324 +0,0 @@
-import { html } from 'lit-html';
-import { unsafeHTML } from 'lit-html/directives/unsafe-html.js';
-import {
-    highlightDash,
-    highlightHls,
-} from '../../shared/syntax-highlighter.js';
-import { copyTextToClipboard } from '../../../shared/utils/clipboard.js';
-
-// --- Sidebar Logic ---
-
-function handleFindingHover(e) {
-    const card = /** @type {HTMLElement} */ (e.currentTarget);
-    const locationId = card.dataset.locationId;
-    document
-        .querySelectorAll('.coverage-highlight')
-        .forEach((el) => el.classList.remove('bg-purple-500/30'));
-    const target = document.getElementById(locationId);
-    if (target) {
-        target.classList.add('bg-purple-500/30');
-    }
-}
-
-function handleFindingLeave() {
-    document
-        .querySelectorAll('.coverage-highlight')
-        .forEach((el) => el.classList.remove('bg-purple-500/30'));
-}
-
-function handleFindingClick(e) {
-    const card = /** @type {HTMLElement} */ (e.currentTarget);
-    const locationId = card.dataset.locationId;
-    const target = document.getElementById(locationId);
-    if (target) {
-        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
-    }
-}
-
-const findingCard = (finding) => {
-    const isDrift = finding.status === 'drift';
-    const borderColor = isDrift ? 'border-orange-500' : 'border-yellow-500';
-    const textColor = isDrift ? 'text-orange-300' : 'text-yellow-300';
-    const locationId = `cov-loc-${finding.pathOrLine.replace(/[.[\]@]/g, '-')}`;
-    const typeText = isDrift
-        ? `Schema Drift: ${finding.type}`
-        : `Unparsed ${finding.type}`;
-
-    return html`
-        <div
-            class="bg-gray-800 p-3 rounded-lg border-l-4 ${borderColor} cursor-pointer hover:bg-gray-700/50"
-            data-location-id="${locationId}"
-            @mouseover=${handleFindingHover}
-            @mouseleave=${handleFindingLeave}
-            @click=${handleFindingClick}
-        >
-            <p class="font-semibold text-sm text-gray-200">
-                <span class="text-xs text-gray-500 mr-2"
-                    >${finding.lineNumber
-                        ? `L${finding.lineNumber}`
-                        : 'PATH'}</span
-                >
-                ${typeText}:
-                <span class="font-mono ${textColor}">${finding.name}</span>
-            </p>
-            <p class="text-xs text-gray-400 mt-1">${finding.details}</p>
-        </div>
-    `;
-};
-
-const sidebarTemplate = (coverageReport) => {
-    if (!coverageReport || coverageReport.length === 0) {
-        return html`<div
-            class="p-4 text-center text-sm text-green-400 bg-gray-800 rounded-lg"
-        >
-            <p class="font-bold">🎉 Full Parser Coverage!</p>
-            <p>No unparsed elements or parser drift were detected.</p>
-        </div>`;
-    }
-    return html`
-        <div
-            class="flex-shrink-0 p-2 bg-gray-900/50 rounded-md border-b border-gray-700"
-        >
-            <h4 class="font-bold text-gray-300">
-                Coverage Issues (${coverageReport.length})
-            </h4>
-        </div>
-        <div class="space-y-2 flex-grow min-h-0 overflow-y-auto p-1">
-            ${coverageReport.map(findingCard)}
-        </div>
-    `;
-};
-
-// --- Manifest Renderer Logic ---
-
-const renderDashNodeCoverage = (
-    tagName,
-    node,
-    coverageReport,
-    path,
-    depth,
-    lineCounter
-) => {
-    if (typeof node !== 'object' || node === null) {
-        return [];
-    }
-    const indent = '  '.repeat(depth);
-    const findingsForPath = coverageReport.filter((f) => f.pathOrLine === path);
-    const elementId = `cov-loc-${path.replace(/[.[\]@]/g, '-')}`;
-
-    let highlightClass = '';
-    if (findingsForPath.some((f) => f.status === 'drift')) {
-        highlightClass = 'bg-orange-900/60';
-    } else if (
-        findingsForPath.some(
-            (f) => f.status === 'unparsed' && f.type === 'element'
-        )
-    ) {
-        highlightClass = 'bg-yellow-900/60';
-    }
-
-    const attributes = node[':@'] || {};
-    const textContent = node['#text'] || null;
-    const childKeys = Object.keys(node).filter(
-        (key) => key !== ':@' && key !== '#text'
-    );
-    const hasChildren = childKeys.length > 0 || textContent;
-
-    const attrsString = Object.entries(attributes)
-        .map(([key, value]) => {
-            const attrFinding = findingsForPath.find(
-                (f) => f.type === 'attribute' && f.name === key
-            );
-            const attrHighlight = attrFinding ? 'bg-yellow-900/60' : '';
-            const highlightedKey = highlightDash(key);
-            const highlightedValue = highlightDash(`"${value}"`);
-            return ` <span class="${attrHighlight}">${highlightedKey}=${highlightedValue}</span>`;
-        })
-        .join('');
-
-    const openingTagString = `<span class="coverage-highlight ${highlightClass}" id="${elementId}">${highlightDash(
-        `<${tagName}`
-    )}${attrsString}${!hasChildren ? ' /' : ''}${highlightDash('>')}</span>`;
-    const templates = [];
-
-    templates.push(
-        html`<div class="flex">
-            <span
-                class="text-right text-gray-500 pr-4 select-none flex-shrink-0 w-12"
-                >${lineCounter.count++}</span
-            >
-            <span class="flex-grow whitespace-pre-wrap break-all"
-                >${unsafeHTML(indent)}${unsafeHTML(openingTagString)}</span
-            >
-        </div>`
-    );
-
-    if (hasChildren) {
-        if (textContent) {
-            templates.push(
-                html`<div class="flex">
-                    <span class="text-right text-gray-500 pr-4 select-none w-12"
-                        >${lineCounter.count++}</span
-                    >
-                    <span class="flex-grow whitespace-pre-wrap break-all"
-                        >${unsafeHTML(indent + '  ')}<span class="text-gray-200"
-                            >${textContent}</span
-                        ></span
-                    >
-                </div>`
-            );
-        }
-        let childCounts = {};
-        childKeys.forEach((childTagName) => {
-            const children = Array.isArray(node[childTagName])
-                ? node[childTagName]
-                : [node[childTagName]];
-            children.forEach((child) => {
-                const index = childCounts[childTagName] || 0;
-                templates.push(
-                    ...renderDashNodeCoverage(
-                        childTagName,
-                        child,
-                        coverageReport,
-                        `${path}.${childTagName}[${index}]`,
-                        depth + 1,
-                        lineCounter
-                    )
-                );
-                childCounts[childTagName] = index + 1;
-            });
-        });
-
-        const closingTagHtml = highlightDash(`</${tagName}>`);
-        templates.push(
-            html`<div class="flex">
-                <span
-                    class="text-right text-gray-500 pr-4 select-none flex-shrink-0 w-12"
-                    >${lineCounter.count++}</span
-                >
-                <span class="flex-grow whitespace-pre-wrap break-all"
-                    >${unsafeHTML(indent)}${unsafeHTML(closingTagHtml)}</span
-                >
-            </div>`
-        );
-    }
-    return templates;
-};
-
-const manifestViewTemplate = (stream, coverageReport) => {
-    const { rawManifest, protocol, manifest } = stream;
-
-    if (protocol === 'hls') {
-        const lines = rawManifest.split('\n');
-        const findingsByLine = (coverageReport || []).reduce((acc, finding) => {
-            const lineNum = finding.lineNumber;
-            if (lineNum) {
-                if (!acc[lineNum]) acc[lineNum] = [];
-                acc[lineNum].push(finding);
-            }
-            return acc;
-        }, {});
-
-        return html`${lines.map((line, index) => {
-            const lineNumber = index + 1;
-            const findings = findingsByLine[lineNumber] || [];
-            const hasDrift = findings.some((f) => f.status === 'drift');
-            const hasUnparsed = findings.some((f) => f.status === 'unparsed');
-
-            let highlightClass = '';
-            if (hasDrift) {
-                highlightClass = 'bg-orange-900/60';
-            } else if (hasUnparsed) {
-                highlightClass = 'bg-yellow-900/60';
-            }
-
-            const locationId = `cov-loc-${lineNumber}`;
-
-            return html`<div class="flex">
-                <span class="text-right text-gray-500 pr-4 select-none w-12"
-                    >${lineNumber}</span
-                >
-                <span
-                    id=${locationId}
-                    class="coverage-highlight flex-grow whitespace-pre-wrap break-all ${highlightClass}"
-                    >${unsafeHTML(highlightHls(line))}</span
-                >
-            </div>`;
-        })}`;
-    }
-
-    // DASH Rendering Logic
-    const serializedManifest = manifest?.serializedManifest;
-    if (!serializedManifest || typeof serializedManifest !== 'object') {
-        return html`<div class="text-red-400">
-            Error rendering DASH manifest object.
-        </div>`;
-    }
-
-    const lineCounter = { count: 1 };
-    const templates = renderDashNodeCoverage(
-        'MPD',
-        serializedManifest,
-        coverageReport,
-        'MPD[0]',
-        0,
-        lineCounter
-    );
-
-    return html`${templates}`;
-};
-
-// --- Main Template ---
-
-export function getParserCoverageTemplate(stream) {
-    if (!stream || !stream.manifest) return html``;
-
-    const handleDebugCopy = () => {
-        const report = stream.coverageReport || [];
-        const issueText = report
-            .map((finding) => {
-                return `[${finding.status.toUpperCase()}] ${finding.type}: ${
-                    finding.name
-                }\nLocation: ${finding.pathOrLine}\nDetails: ${
-                    finding.details
-                }\n---`;
-            })
-            .join('\n\n');
-
-        const debugString = `--- MANIFEST ---\n${stream.rawManifest}\n\n--- COVERAGE ISSUES (${report.length}) ---\n${issueText}`;
-
-        copyTextToClipboard(debugString, 'Debug report copied to clipboard!');
-    };
-
-    return html`
-        <div class="mb-4 flex-shrink-0 flex justify-between items-center">
-            <div>
-                <h3 class="text-xl font-bold">Parser Coverage Analysis</h3>
-                <p class="text-sm text-gray-400 mt-1">
-                    Highlights elements not parsed from the manifest (unparsed)
-                    and properties created by the parser but not in the schema
-                    (drift).
-                </p>
-            </div>
-            <button
-                @click=${handleDebugCopy}
-                class="bg-yellow-600 hover:bg-yellow-700 text-black font-bold py-2 px-3 rounded-md transition-colors flex-shrink-0"
-            >
-                Copy Debug Report
-            </button>
-        </div>
-
-        <div class="lg:grid lg:grid-cols-[1fr_450px] lg:gap-6 relative h-full">
-            <div
-                class="bg-slate-800 rounded-lg p-2 sm:p-4 font-mono text-sm leading-relaxed overflow-auto mb-6 lg:mb-0 h-full"
-            >
-                ${manifestViewTemplate(stream, stream.coverageReport)}
-            </div>
-            <div class="lg:sticky lg:top-4 h-fit">
-                <div class="flex flex-col h-96 lg:max-h-[calc(100vh-12rem)]">
-                    ${sidebarTemplate(stream.coverageReport)}
-                </div>
-            </div>
-        </div>
-    `;
-}
diff --git a/js/ui/views/segment-analysis/index.js b/js/ui/views/segment-analysis/index.js
deleted file mode 100644
index 7a93874..0000000
--- a/js/ui/views/segment-analysis/index.js
+++ /dev/null
@@ -1,169 +0,0 @@
-import { html } from 'lit-html';
-import { isobmffAnalysisTemplate } from './isobmff-analysis.js';
-import { tsAnalysisTemplate } from './ts-analysis.js';
-import { vttAnalysisTemplate } from './vtt-analysis.js';
-
-// --- UTILITY ---
-function diffObjects(obj1, obj2) {
-    const result = [];
-    const allKeys = new Set([...Object.keys(obj1), ...Object.keys(obj2)]);
-    for (const key of allKeys) {
-        const val1 = obj1[key];
-        const val2 = obj2[key];
-        const isDifferent = JSON.stringify(val1) !== JSON.stringify(val2);
-        result.push({
-            key,
-            val1: val1 !== undefined ? val1 : '---',
-            val2: val2 !== undefined ? val2 : '---',
-            isDifferent,
-        });
-    }
-    return result;
-}
-
-// --- TEMPLATES (COMPARISON) ---
-const segmentCompareTemplate = (analysisA, analysisB) => {
-    // This comparison is high-level and format-agnostic, so it can remain here.
-    // A more detailed comparison would require protocol-specific logic.
-    if (!analysisA.data.summary || !analysisB.data.summary) {
-        return html`<p class="fail">
-            Cannot compare segments; summary data is missing.
-        </p>`;
-    }
-    const diff = diffObjects(analysisA.data.summary, analysisB.data.summary);
-    return html`
-        <div class="grid grid-cols-[1fr_2fr_2fr] text-xs">
-            <div
-                class="font-semibold p-2 border-b border-r border-gray-700 bg-gray-900/50"
-            >
-                Property
-            </div>
-            <div
-                class="font-semibold p-2 border-b border-r border-gray-700 bg-gray-900/50"
-            >
-                Segment A
-            </div>
-            <div
-                class="font-semibold p-2 border-b border-r border-gray-700 bg-gray-900/50"
-            >
-                Segment B
-            </div>
-            ${diff.map(
-                (item) => html`
-                    <div
-                        class="p-2 border-b border-r border-gray-700 font-medium text-gray-400"
-                    >
-                        ${item.key}
-                    </div>
-                    <div
-                        class="p-2 border-b border-r border-gray-700 font-mono ${item.isDifferent
-                            ? 'bg-red-900/50 text-red-300'
-                            : ''}"
-                    >
-                        ${item.val1}
-                    </div>
-                    <div
-                        class="p-2 border-b border-r border-gray-700 font-mono ${item.isDifferent
-                            ? 'bg-red-900/50 text-red-300'
-                            : ''}"
-                    >
-                        ${item.val2}
-                    </div>
-                `
-            )}
-        </div>
-    `;
-};
-
-// --- DISPATCHER ---
-export function getSegmentAnalysisTemplate(parsedData, parsedDataB = null) {
-    if (parsedData?.error) {
-        return html`<p class="text-red-400 p-4">
-            Segment could not be parsed:
-            <span class="block font-mono bg-gray-900 p-2 mt-2 rounded"
-                >${parsedData.error}</span
-            >
-        </p>`;
-    }
-
-    if (!parsedData) {
-        return html`<p class="text-gray-400 p-4">
-            Segment data not available or is currently loading.
-        </p>`;
-    }
-
-    if (parsedDataB) {
-        return segmentCompareTemplate(parsedData, parsedDataB);
-    }
-
-    const format = parsedData.format;
-    const isSupported =
-        format === 'isobmff' || format === 'ts' || format === 'vtt';
-
-    const icon = isSupported
-        ? html`<svg
-              xmlns="http://www.w3.org/2000/svg"
-              class="h-5 w-5 text-green-400"
-              fill="none"
-              viewBox="0 0 24 24"
-              stroke="currentColor"
-              stroke-width="2"
-          >
-              <path
-                  stroke-linecap="round"
-                  stroke-linejoin="round"
-                  d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"
-              />
-          </svg>`
-        : html`<svg
-              xmlns="http://www.w3.org/2000/svg"
-              class="h-5 w-5 text-yellow-400"
-              fill="none"
-              viewBox="0 0 24 24"
-              stroke="currentColor"
-              stroke-width="2"
-          >
-              <path
-                  stroke-linecap="round"
-                  stroke-linejoin="round"
-                  d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
-              />
-          </svg>`;
-
-    const formatText =
-        {
-            isobmff: 'ISO Base Media File Format',
-            ts: 'MPEG-2 Transport Stream',
-            vtt: 'Web Video Text Tracks (WebVTT)',
-        }[format] || 'Unknown Format';
-
-    let contentTemplate;
-    switch (format) {
-        case 'isobmff':
-            contentTemplate = isobmffAnalysisTemplate(parsedData.data);
-            break;
-        case 'ts':
-            contentTemplate = tsAnalysisTemplate(parsedData);
-            break;
-        case 'vtt':
-            contentTemplate = vttAnalysisTemplate(parsedData.data);
-            break;
-        default:
-            contentTemplate = html`<p class="fail">
-                Analysis view for format '${format}' is not supported.
-            </p>`;
-            break;
-    }
-
-    return html`
-        <div
-            class="flex items-center gap-2 mb-4 p-2 bg-gray-900/50 rounded-md border border-gray-700"
-        >
-            ${icon}
-            <span class="font-semibold text-gray-300"
-                >Format: ${formatText}</span
-            >
-        </div>
-        ${contentTemplate}
-    `;
-}
diff --git a/js/ui/views/segment-analysis/isobmff-analysis.js b/js/ui/views/segment-analysis/isobmff-analysis.js
deleted file mode 100644
index a2dbcb8..0000000
--- a/js/ui/views/segment-analysis/isobmff-analysis.js
+++ /dev/null
@@ -1,225 +0,0 @@
-import { html } from 'lit-html';
-import { tooltipTriggerClasses } from '../../../shared/constants.js';
-import { getTooltipData as getIsobmffTooltipData } from '../../../infrastructure/segment/isobmff/index.js';
-
-const findBoxRecursive = (boxes, type) => {
-    for (const box of boxes) {
-        if (box.type === type) return box;
-        if (box.children?.length > 0) {
-            const found = findBoxRecursive(box.children, type);
-            if (found) return found;
-        }
-    }
-    return null;
-};
-
-const semanticCard = (title, box, fields) => {
-    if (!box) return '';
-    return html`
-        <div class="bg-gray-900/50 border border-gray-700 rounded-lg">
-            <h4
-                class="text-sm font-semibold p-2 border-b border-gray-700 text-gray-300"
-            >
-                ${title}
-            </h4>
-            <dl class="grid grid-cols-[auto_1fr] gap-x-2 p-2 text-xs font-mono">
-                ${fields.map((field) => {
-                    const value = box.details[field.key]?.value;
-                    return value !== undefined
-                        ? html`
-                              <dt class="text-gray-400">${field.label}:</dt>
-                              <dd class="text-white break-all">${value}</dd>
-                          `
-                        : '';
-                })}
-            </dl>
-        </div>
-    `;
-};
-
-const semanticSummaryTemplate = (boxes) => {
-    const tkhd = findBoxRecursive(boxes, 'tkhd');
-    const mdhd = findBoxRecursive(boxes, 'mdhd');
-    const trex = findBoxRecursive(boxes, 'trex');
-    const elst = findBoxRecursive(boxes, 'elst');
-
-    return html`
-        <div
-            class="grid gap-4 grid-cols-[repeat(auto-fill,minmax(300px,1fr))] mb-6"
-        >
-            ${semanticCard('Track Header (tkhd)', tkhd, [
-                { key: 'track_ID', label: 'Track ID' },
-                { key: 'duration', label: 'Duration' },
-                { key: 'width', label: 'Width' },
-                { key: 'height', label: 'Height' },
-            ])}
-            ${semanticCard('Media Header (mdhd)', mdhd, [
-                { key: 'timescale', label: 'Timescale' },
-                { key: 'duration', label: 'Duration' },
-                { key: 'language', label: 'Language' },
-            ])}
-            ${semanticCard('Track Extends (trex)', trex, [
-                { key: 'track_ID', label: 'Track ID' },
-                { key: 'default_sample_duration', label: 'Default Duration' },
-                { key: 'default_sample_size', label: 'Default Size' },
-            ])}
-            ${semanticCard('Edit List (elst)', elst, [
-                { key: 'entry_count', label: 'Entry Count' },
-                {
-                    key: 'entry_1_media_time',
-                    label: 'Media Time (Entry 1)',
-                },
-            ])}
-        </div>
-    `;
-};
-
-const samplesTableTemplate = (box) => {
-    if (!box.samples || box.samples.length === 0) return '';
-
-    const headers = Object.keys(box.samples[0]);
-
-    return html`
-        <div class="mt-2">
-            <h5
-                class="text-xs font-semibold text-gray-400 uppercase tracking-wider"
-            >
-                Sample Table
-            </h5>
-            <div
-                class="mt-1 overflow-y-auto max-h-64 border border-gray-700 rounded-md"
-            >
-                <table class="w-full text-left text-xs">
-                    <thead class="bg-gray-800 sticky top-0">
-                        <tr>
-                            <th class="p-2">#</th>
-                            ${headers.map(
-                                (h) => html`<th class="p-2">${h}</th>`
-                            )}
-                        </tr>
-                    </thead>
-                    <tbody class="divide-y divide-gray-700">
-                        ${box.samples.map(
-                            (sample, index) => html`
-                                <tr class="hover:bg-gray-700/50">
-                                    <td class="p-2">${index + 1}</td>
-                                    ${headers.map(
-                                        (h) =>
-                                            html`<td class="p-2 font-mono">
-                                                ${sample[h] !== undefined
-                                                    ? sample[h]
-                                                    : 'N/A'}
-                                            </td>`
-                                    )}
-                                </tr>
-                            `
-                        )}
-                    </tbody>
-                </table>
-            </div>
-        </div>
-    `;
-};
-
-const isoBoxTemplate = (box) => {
-    const tooltipData = getIsobmffTooltipData();
-    const boxInfo = tooltipData[box.type] || {};
-
-    const headerTemplate = html`<div
-        class="font-semibold font-mono p-2 bg-gray-900/50 rounded-t-md border-b border-gray-600 flex items-center gap-2"
-    >
-        ${box.issues && box.issues.length > 0
-            ? html`<svg
-                  xmlns="http://www.w3.org/2000/svg"
-                  class="h-5 w-5 text-yellow-400 flex-shrink-0"
-                  viewBox="0 0 20 20"
-                  fill="currentColor"
-                  title="${box.issues
-                      .map((i) => `[${i.type}] ${i.message}`)
-                      .join('\n')}"
-              >
-                  <path
-                      fill-rule="evenodd"
-                      d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM10 13a1 1 0 110-2 1 1 0 010 2zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z"
-                      clip-rule="evenodd"
-                  />
-              </svg>`
-            : ''}
-        <span
-            class="text-emerald-300 ${boxInfo.text
-                ? tooltipTriggerClasses
-                : ''}"
-            data-tooltip="${boxInfo.text || ''}"
-            data-iso="${boxInfo.ref || ''}"
-            >${box.type}</span
-        >
-        <span class="text-gray-500 text-xs"
-            >${boxInfo.name ? `(${boxInfo.name}) ` : ''}(${box.size}
-            bytes)</span
-        >
-    </div>`;
-
-    const detailsTemplate =
-        Object.keys(box.details).length > 0
-            ? html`<div class="p-2">
-                  <table class="text-xs border-collapse w-full table-auto">
-                      <tbody>
-                          ${Object.entries(box.details).map(([key, field]) => {
-                              const fieldTooltip =
-                                  tooltipData[`${box.type}@${key}`];
-                              return html`<tr>
-                                  <td
-                                      class="border border-gray-700 p-2 text-gray-400 w-1/3 ${fieldTooltip
-                                          ? tooltipTriggerClasses
-                                          : ''}"
-                                      data-tooltip="${fieldTooltip?.text || ''}"
-                                      data-iso="${fieldTooltip?.ref || ''}"
-                                  >
-                                      ${key}
-                                  </td>
-                                  <td
-                                      class="border border-gray-700 p-2 text-gray-200 font-mono break-all"
-                                  >
-                                      ${field.value}
-                                  </td>
-                              </tr>`;
-                          })}
-                      </tbody>
-                  </table>
-                  ${samplesTableTemplate(box)}
-              </div>`
-            : '';
-
-    const childrenTemplate =
-        box.children.length > 0
-            ? html`<div class="pl-4 mt-2 border-l-2 border-gray-600">
-                  <ul class="list-none space-y-2">
-                      ${box.children.map(
-                          (child) => html`<li>${isoBoxTemplate(child)}</li>`
-                      )}
-                  </ul>
-              </div>`
-            : '';
-
-    return html`<div class="border border-gray-700 rounded-md bg-gray-800">
-        ${headerTemplate}
-        <div class="space-y-2">${detailsTemplate}</div>
-        ${childrenTemplate}
-    </div>`;
-};
-
-export const isobmffAnalysisTemplate = (isobmffData) => {
-    return html`
-        <div>
-            <h3 class="text-xl font-bold mb-4">Semantic Summary</h3>
-            ${semanticSummaryTemplate(isobmffData.boxes)}
-
-            <h3 class="text-xl font-bold mb-4 mt-8">Full Box Tree</h3>
-            <ul class="list-none p-0 space-y-2">
-                ${isobmffData.boxes.map(
-                    (box) => html`<li>${isoBoxTemplate(box)}</li>`
-                )}
-            </ul>
-        </div>
-    `;
-};
diff --git a/js/ui/views/segment-analysis/ts-analysis.js b/js/ui/views/segment-analysis/ts-analysis.js
deleted file mode 100644
index 84038cb..0000000
--- a/js/ui/views/segment-analysis/ts-analysis.js
+++ /dev/null
@@ -1,156 +0,0 @@
-import { html } from 'lit-html';
-import { tooltipTriggerClasses } from '../../../shared/constants.js';
-import { getTooltipData as getTsTooltipData } from '../../../infrastructure/segment/ts/index.js';
-
-const tsTooltipData = getTsTooltipData();
-
-const dataItem = (label, value) => {
-    if (value === null || value === undefined) return '';
-    return html`
-        <div class="text-xs">
-            <span class="block text-gray-400 mb-0.5">${label}</span>
-            <span class="block font-semibold font-mono text-gray-200"
-                >${value}</span
-            >
-        </div>
-    `;
-};
-
-const descriptorTableTemplate = (descriptors) => {
-    if (!descriptors || descriptors.length === 0) {
-        return html`<p class="text-xs text-gray-500 italic px-2">
-            No descriptors present.
-        </p>`;
-    }
-    return html`
-        <table class="w-full text-left text-xs bg-gray-900/50 rounded-md my-2">
-            <thead>
-                <tr>
-                    <th class="p-2 font-semibold text-gray-400 w-1/4">
-                        Descriptor Name (Tag)
-                    </th>
-                    <th class="p-2 font-semibold text-gray-400">Details</th>
-                </tr>
-            </thead>
-            <tbody class="divide-y divide-gray-700/50">
-                ${descriptors.map(
-                    (desc) => html`
-                        <tr>
-                            <td
-                                class="p-2 font-medium text-gray-300 align-top ${tooltipTriggerClasses}"
-                                data-tooltip="${tsTooltipData[desc.name]
-                                    ?.text || 'No description available'}"
-                                data-iso="${tsTooltipData[desc.name]?.ref ||
-                                ''}"
-                            >
-                                ${desc.name}
-                                <span class="text-gray-500"
-                                    >(0x${desc.tag.toString(16)})</span
-                                >
-                            </td>
-                            <td class="p-2 font-mono">
-                                <dl class="grid grid-cols-[auto_1fr] gap-x-2">
-                                    ${Object.entries(desc.details).map(
-                                        ([key, field]) => html`
-                                            <dt class="text-gray-400">
-                                                ${key}:
-                                            </dt>
-                                            <dd class="text-white break-all">
-                                                ${field.value}
-                                            </dd>
-                                        `
-                                    )}
-                                </dl>
-                            </td>
-                        </tr>
-                    `
-                )}
-            </tbody>
-        </table>
-    `;
-};
-
-export const tsAnalysisTemplate = (analysis) => {
-    const { summary, packets } = analysis.data;
-    const pmtPid = [...summary.pmtPids][0];
-    const program = pmtPid ? summary.programMap[pmtPid] : null;
-
-    // Calculate PID counts for the new table
-
-    const pmtPacket = packets.find((p) => p.pid === pmtPid && p.psi);
-
-    return html`
-        <div
-            class="grid grid-cols-[repeat(auto-fit,minmax(180px,1fr))] gap-3 bg-gray-900 border border-gray-700 rounded p-3 mb-6"
-        >
-            ${dataItem('Total Packets', summary.totalPackets)}
-            ${dataItem('PCR PID', summary.pcrPid || 'N/A')}
-            ${program ? dataItem('Program #', program.programNumber) : ''}
-            ${summary.errors.length > 0
-                ? dataItem('Errors', summary.errors.join(', '))
-                : ''}
-        </div>
-
-        <h3 class="text-xl font-bold mb-4">Program Map Table (PMT) Details</h3>
-        ${pmtPacket
-            ? html`
-                  <div
-                      class="bg-gray-800 p-4 rounded-lg border border-gray-700"
-                  >
-                      <div
-                          class="grid grid-cols-[repeat(auto-fit,minmax(180px,1fr))] gap-3 mb-4"
-                      >
-                          ${dataItem('PMT PID', pmtPid)}
-                          ${dataItem('PCR PID', pmtPacket.psi.pcr_pid.value)}
-                      </div>
-
-                      <h4 class="text-md font-semibold mb-2 text-gray-300">
-                          Program Descriptors
-                      </h4>
-                      ${descriptorTableTemplate(
-                          pmtPacket.psi.program_descriptors
-                      )}
-
-                      <h4 class="text-md font-semibold mb-2 mt-4 text-gray-300">
-                          Elementary Streams
-                      </h4>
-                      <div class="space-y-4">
-                          ${pmtPacket.psi.streams.map(
-                              (stream) => html`
-                                  <div
-                                      class="border border-gray-700 rounded-lg p-3"
-                                  >
-                                      <div
-                                          class="flex items-baseline gap-4 font-mono text-sm"
-                                      >
-                                          <span
-                                              >PID:
-                                              <strong class="text-white"
-                                                  >${stream.elementary_PID
-                                                      .value}</strong
-                                              ></span
-                                          >
-                                          <span
-                                              >Stream Type:
-                                              <strong class="text-white"
-                                                  >${stream.stream_type
-                                                      .value}</strong
-                                              ></span
-                                          >
-                                      </div>
-                                      <div class="mt-2">
-                                          ${descriptorTableTemplate(
-                                              stream.es_descriptors
-                                          )}
-                                      </div>
-                                  </div>
-                              `
-                          )}
-                      </div>
-                  </div>
-              `
-            : html`<p class="text-sm text-gray-400">
-                  No PMT packet found in this segment.
-              </p>`}
-    `;
-};
diff --git a/js/ui/views/segment-analysis/vtt-analysis.js b/js/ui/views/segment-analysis/vtt-analysis.js
deleted file mode 100644
index 3a55572..0000000
--- a/js/ui/views/segment-analysis/vtt-analysis.js
+++ /dev/null
@@ -1,91 +0,0 @@
-import { html } from 'lit-html';
-import { unsafeHTML } from 'lit-html/directives/unsafe-html.js';
-
-const cueRowTemplate = (cue, index) => html`
-    <tr class="hover:bg-gray-700/50">
-        <td class="p-2 border-t border-gray-700 font-mono text-gray-400">
-            ${index + 1}
-        </td>
-        <td class="p-2 border-t border-gray-700 font-mono text-white">
-            ${cue.id || 'N/A'}
-        </td>
-        <td class="p-2 border-t border-gray-700 font-mono text-cyan-400">
-            ${cue.startTime?.toFixed(3)}s &rarr; ${cue.endTime?.toFixed(3)}s
-        </td>
-        <td class="p-2 border-t border-gray-700 font-mono text-yellow-300">
-            ${Object.entries(cue.settings)
-                .map(([key, value]) => `${key}:${value}`)
-                .join(' ')}
-        </td>
-        <td class="p-2 border-t border-gray-700 text-gray-200">
-            ${unsafeHTML(cue.payload.join('<br>'))}
-        </td>
-    </tr>
-`;
-
-export const vttAnalysisTemplate = (vttData) => {
-    return html`
-        <div class="space-y-6 text-xs">
-            ${vttData.errors.length > 0
-                ? html`
-                      <div
-                          class="bg-red-900/50 p-3 rounded-lg border border-red-700"
-                      >
-                          <h4 class="font-bold text-red-300 mb-2">
-                              Parsing Errors
-                          </h4>
-                          <ul class="list-disc pl-5 text-red-200">
-                              ${vttData.errors.map(
-                                  (err) => html`<li>${err}</li>`
-                              )}
-                          </ul>
-                      </div>
-                  `
-                : ''}
-            ${vttData.styles.length > 0
-                ? html`
-                      <div>
-                          <h4 class="font-semibold text-gray-300 mb-2">
-                              Embedded Styles
-                          </h4>
-                          <pre
-                              class="bg-gray-900/50 p-3 rounded-md border border-gray-700 text-cyan-400 overflow-x-auto"
-                          ><code>${vttData.styles.join('\n\n')}</code></pre>
-                      </div>
-                  `
-                : ''}
-
-            <div>
-                <h4 class="font-semibold text-gray-300 mb-2">Cues</h4>
-                <div
-                    class="bg-gray-900/50 rounded border border-gray-700/50 overflow-hidden"
-                >
-                    <table class="w-full text-left table-auto">
-                        <thead class="bg-gray-800/50">
-                            <tr>
-                                <th class="p-2 font-semibold text-gray-400">
-                                    #
-                                </th>
-                                <th class="p-2 font-semibold text-gray-400">
-                                    ID
-                                </th>
-                                <th class="p-2 font-semibold text-gray-400">
-                                    Timings
-                                </th>
-                                <th class="p-2 font-semibold text-gray-400">
-                                    Settings
-                                </th>
-                                <th class="p-2 font-semibold text-gray-400">
-                                    Payload
-                                </th>
-                            </tr>
-                        </thead>
-                        <tbody>
-                            ${vttData.cues.map(cueRowTemplate)}
-                        </tbody>
-                    </table>
-                </div>
-            </div>
-        </div>
-    `;
-};
diff --git a/js/ui/views/segment-explorer/components/dash/index.js b/js/ui/views/segment-explorer/components/dash/index.js
deleted file mode 100644
index 4715d71..0000000
--- a/js/ui/views/segment-explorer/components/dash/index.js
+++ /dev/null
@@ -1,129 +0,0 @@
-import { html } from 'lit-html';
-import { segmentRowTemplate } from '../../../../components/segment-row.js';
-
-const dashSegmentTableTemplate = (
-    stream,
-    period,
-    representation,
-    displayMode
-) => {
-    const compositeKey = `${period.id}-${representation.id}`;
-    const repState = stream.dashRepresentationState.get(compositeKey);
-
-    if (!repState) {
-        return html`<div class="text-red-400 p-2">
-            State not found for Representation ${representation.id} in Period
-            ${period.id}.
-        </div>`;
-    }
-
-    const { segments, freshSegmentUrls } = repState;
-
-    const SEGMENT_PAGE_SIZE = 10;
-    const segmentsToRender =
-        displayMode === 'first'
-            ? segments.slice(0, SEGMENT_PAGE_SIZE)
-            : segments.slice(-SEGMENT_PAGE_SIZE);
-
-    const header = html` <div
-        class="flex items-center p-2 bg-gray-900/50 border-b border-gray-700"
-    >
-        <div class="flex-grow flex items-center">
-            <span class="font-semibold text-gray-200"
-                >Representation: ${representation.id}</span
-            >
-            <span class="ml-3 text-xs text-gray-400 font-mono"
-                >(${(representation.bandwidth / 1000).toFixed(0)} kbps)</span
-            >
-        </div>
-    </div>`;
-
-    let content;
-    if (segments.length === 0) {
-        content = html`<div class="p-4 text-center text-gray-400 text-sm">
-            No segments found for this representation.
-        </div>`;
-    } else {
-        content = html`<div class="overflow-x-auto">
-            <table class="w-full text-left text-sm table-auto min-w-[600px]">
-                <thead class="sticky top-0 bg-gray-900 z-10">
-                    <tr>
-                        <th class="px-3 py-2 w-8"></th>
-                        <th class="px-3 py-2">Status / Type</th>
-                        <th class="px-3 py-2">Timing (s)</th>
-                        <th class="px-3 py-2">URL & Actions</th>
-                    </tr>
-                </thead>
-                <tbody>
-                    ${segmentsToRender.map((seg) => {
-                        const isFresh = freshSegmentUrls.has(seg.resolvedUrl);
-                        // Liveness state is now handled by the real-time highlighter, not at render time.
-                        return segmentRowTemplate(seg, isFresh);
-                    })}
-                </tbody>
-            </table>
-        </div>`;
-    }
-
-    return html`<div class="bg-gray-800 rounded-lg border border-gray-700 mt-2">
-        ${header} ${content}
-    </div>`;
-};
-
-/**
- * Creates the lit-html template for the DASH segment explorer content.
- * @param {import('../../../../../app/types.ts').Stream} stream
- * @param {string} displayMode - 'first' or 'last'
- * @returns {import('lit-html').TemplateResult}
- */
-export function getDashExplorerTemplate(stream, displayMode) {
-    if (!stream.manifest || !stream.manifest.periods) {
-        return html`<p class="text-gray-400">
-            No periods found in the manifest.
-        </p>`;
-    }
-
-    return html`
-        <div class="space-y-6">
-            ${stream.manifest.periods.map(
-                (period, index) => html`
-                    <div>
-                        <h3
-                            class="text-lg font-bold text-gray-300 border-b-2 border-gray-700 pb-1"
-                        >
-                            Period: ${period.id || `(index ${index})`}
-                            <span class="text-sm font-mono text-gray-500"
-                                >(Start: ${period.start}s)</span
-                            >
-                        </h3>
-                        <div class="space-y-4 mt-2">
-                            ${period.adaptationSets
-                                .filter((as) => as.representations.length > 0)
-                                .map(
-                                    (as) => html`
-                                        <div class="pl-4">
-                                            <h4
-                                                class="text-md font-semibold text-gray-400"
-                                            >
-                                                AdaptationSet
-                                                ${as.id ? `(ID: ${as.id})` : ''}
-                                                (${as.contentType || 'N/A'})
-                                            </h4>
-                                            ${as.representations.map((rep) =>
-                                                dashSegmentTableTemplate(
-                                                    stream,
-                                                    period,
-                                                    rep,
-                                                    displayMode
-                                                )
-                                            )}
-                                        </div>
-                                    `
-                                )}
-                        </div>
-                    </div>
-                `
-            )}
-        </div>
-    `;
-}
diff --git a/js/ui/views/segment-explorer/components/hls/index.js b/js/ui/views/segment-explorer/components/hls/index.js
deleted file mode 100644
index 7693e88..0000000
--- a/js/ui/views/segment-explorer/components/hls/index.js
+++ /dev/null
@@ -1,353 +0,0 @@
-import { html } from 'lit-html';
-import { segmentRowTemplate } from '../../../../components/segment-row.js';
-import { eventBus } from '../../../../../app/event-bus.js';
-
-let liveSegmentHighlighterInterval = null;
-
-export function startLiveSegmentHighlighter(container, stream) {
-    stopLiveSegmentHighlighter();
-
-    const updateHighlights = () => {
-        if (!container || container.offsetParent === null) {
-            stopLiveSegmentHighlighter();
-            return;
-        }
-
-        const now = Date.now();
-        const liveClass = 'bg-green-700/50';
-        const staleClass = 'text-gray-500',
-            opacityClass = 'opacity-50';
-
-        const rows = container.querySelectorAll('tr.segment-row');
-        rows.forEach((row) => {
-            const tr = /** @type {HTMLElement} */ (row);
-            const startTime = parseInt(tr.dataset.startTime, 10);
-            const endTime = parseInt(tr.dataset.endTime, 10);
-
-            // Remove all state classes first
-            tr.classList.remove(liveClass, staleClass, opacityClass);
-
-            if (!startTime || !endTime) return;
-
-            if (now >= startTime && now < endTime) {
-                tr.classList.add(liveClass);
-            } else if (now > endTime + 30000) {
-                // Mark as stale if it's more than 30s past its end time
-                tr.classList.add(staleClass, opacityClass);
-            }
-        });
-    };
-
-    liveSegmentHighlighterInterval = setInterval(updateHighlights, 1000);
-}
-
-export function stopLiveSegmentHighlighter() {
-    if (liveSegmentHighlighterInterval) {
-        clearInterval(liveSegmentHighlighterInterval);
-        liveSegmentHighlighterInterval = null;
-    }
-}
-
-const liveEdgeIndicatorTemplate = (stream, segments) => {
-    if (stream.manifest.type !== 'dynamic' || segments.length === 0) {
-        return '';
-    }
-
-    const totalDuration = segments.reduce(
-        (sum, seg) => sum + seg.duration / seg.timescale,
-        0
-    );
-    if (totalDuration <= 0) return '';
-
-    const _liveEdgeTime = totalDuration;
-    const partHoldBack = stream.manifest.summary.lowLatency?.partHoldBack;
-
-    let positionFromEnd;
-    let title;
-
-    if (partHoldBack != null) {
-        // LL-HLS: Position is based on PART-HOLD-BACK
-        positionFromEnd = (partHoldBack / totalDuration) * 100;
-        title = `Live Edge (Target: ${partHoldBack.toFixed(2)}s behind edge)`;
-    } else {
-        // Standard HLS: Position is at the very end
-        positionFromEnd = 0;
-        title = 'Live Edge';
-    }
-
-    return html`<div
-        class="absolute top-0 bottom-0 right-0 w-0.5 bg-red-500 rounded-full z-20"
-        style="right: ${positionFromEnd}%;"
-        title="${title}"
-    >
-        <div
-            class="absolute -top-1 -right-1.5 w-4 h-4 rounded-full bg-red-500 animate-ping"
-        ></div>
-    </div>`;
-};
-
-const renderVariant = (stream, variant, variantUri) => {
-    const variantState = stream.hlsVariantState.get(variantUri);
-    if (!variantState) return html``;
-
-    const {
-        segments: rawSegments,
-        error,
-        isLoading,
-        isExpanded,
-        displayMode,
-        isPolling,
-        freshSegmentUrls,
-    } = variantState;
-
-    // Transform raw parser segments into the view model the template expects
-    let pdtAnchorTime = 0;
-    let cumulativeDuration = 0;
-    const allSegments = (Array.isArray(rawSegments) ? rawSegments : []).map(
-        (seg, index) => {
-            if (seg.dateTime) {
-                pdtAnchorTime = new Date(seg.dateTime).getTime();
-                cumulativeDuration = 0; // Reset cumulative duration at each PDT tag
-            }
-
-            const startTimeUTC = pdtAnchorTime + cumulativeDuration * 1000;
-            const endTimeUTC = startTimeUTC + seg.duration * 1000;
-            const segmentTime = cumulativeDuration;
-            cumulativeDuration += seg.duration;
-
-            const transformedSeg = {
-                repId: 'hls-media',
-                type: seg.type || 'Media',
-                number: (stream.manifest.mediaSequence || 0) + index,
-                resolvedUrl: seg.resolvedUrl,
-                template: seg.uri,
-                time: segmentTime * 90000,
-                duration: seg.duration * 90000,
-                timescale: 90000,
-                gap: seg.gap || false,
-                startTimeUTC: startTimeUTC || 0,
-                endTimeUTC: endTimeUTC || 0,
-            };
-            return transformedSeg;
-        }
-    );
-
-    const segmentsToDisplay =
-        displayMode === 'last10' ? allSegments.slice(-10) : allSegments;
-
-    const onToggleExpand = (e) => {
-        e.preventDefault();
-        eventBus.dispatch('hls-explorer:toggle-variant', {
-            streamId: stream.id,
-            variantUri,
-        });
-    };
-    const onTogglePolling = (e) => {
-        e.stopPropagation();
-        eventBus.dispatch('hls-explorer:toggle-polling', {
-            streamId: stream.id,
-            variantUri,
-        });
-    };
-    const onSetDisplayMode = (e) => {
-        e.stopPropagation();
-        eventBus.dispatch('hls-explorer:set-display-mode', {
-            streamId: stream.id,
-            variantUri,
-            mode: displayMode === 'all' ? 'last10' : 'all',
-        });
-    };
-
-    let content;
-    if (isLoading) {
-        content = html`<div class="p-4 text-center text-gray-400">
-            Loading segments...
-        </div>`;
-    } else if (error) {
-        content = html`<div class="p-4 text-red-400">Error: ${error}</div>`;
-    } else if (allSegments.length === 0 && isExpanded) {
-        content = html`<div class="p-4 text-center text-gray-400">
-            No segments found in this playlist.
-        </div>`;
-    } else if (isExpanded) {
-        content = html`<div class="overflow-x-auto relative">
-            ${liveEdgeIndicatorTemplate(stream, segmentsToDisplay)}
-            <table class="w-full text-left text-sm table-auto min-w-[600px]">
-                <thead class="sticky top-0 bg-gray-900 z-10">
-                    <tr>
-                        <th class="px-3 py-2 w-8"></th>
-                        <th class="px-3 py-2">Status / Type</th>
-                        <th class="px-3 py-2">Timing (s)</th>
-                        <th class="px-3 py-2">URL & Actions</th>
-                    </tr>
-                </thead>
-                <tbody>
-                    ${segmentsToDisplay.map((seg) =>
-                        segmentRowTemplate(
-                            seg,
-                            freshSegmentUrls.has(seg.resolvedUrl)
-                        )
-                    )}
-                </tbody>
-            </table>
-        </div>`;
-    }
-
-    return html`
-        <style>
-            details > summary {
-                list-style: none;
-            }
-            details > summary::-webkit-details-marker {
-                display: none;
-            }
-            details[open] .chevron {
-                transform: rotate(90deg);
-            }
-        </style>
-        <details
-            class="bg-gray-800 rounded-lg border border-gray-700"
-            ?open=${isExpanded}
-        >
-            <summary
-                @click=${onToggleExpand}
-                class="flex items-center p-2 bg-gray-900/50 cursor-pointer list-none"
-            >
-                <div class="flex-grow font-semibold text-gray-200">
-                    ${variant.title}
-                </div>
-                <svg
-                    class="chevron w-5 h-5 text-gray-400 transition-transform duration-200"
-                    xmlns="http://www.w3.org/2000/svg"
-                    viewBox="0 0 20 20"
-                    fill="currentColor"
-                >
-                    <path
-                        fill-rule="evenodd"
-                        d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"
-                        clip-rule="evenodd"
-                    />
-                </svg>
-            </summary>
-            ${isExpanded
-                ? html`
-                      <div class="p-2 border-t border-gray-700">
-                          <div class="flex items-center gap-4 p-2">
-                              ${stream.manifest.type === 'dynamic'
-                                  ? html`
-                                        <button
-                                            @click=${onTogglePolling}
-                                            class="text-xs px-3 py-1 rounded ${isPolling
-                                                ? 'bg-red-600 hover:bg-red-700'
-                                                : 'bg-blue-600 hover:bg-blue-700'}"
-                                        >
-                                            ${isPolling
-                                                ? 'Stop Polling'
-                                                : 'Start Polling'}
-                                        </button>
-                                    `
-                                  : ''}
-                              <button
-                                  @click=${onSetDisplayMode}
-                                  class="text-xs px-3 py-1 rounded bg-gray-600 hover:bg-gray-700"
-                              >
-                                  Show
-                                  ${displayMode === 'all' ? 'Last 10' : 'All'}
-                              </button>
-                          </div>
-                          ${content}
-                      </div>
-                  `
-                : ''}
-        </details>
-    `;
-};
-
-/**
- * Creates the lit-html template for the HLS segment explorer content.
- * @param {import('../../../../../app/types.ts').Stream} stream
- * @returns {import('lit-html').TemplateResult}
- */
-export function getHlsExplorerTemplate(stream) {
-    if (stream.manifest.isMaster) {
-        // Group all playlists by their type (video, audio, subtitles)
-        const groupedPlaylists = {
-            VIDEO: [],
-            AUDIO: [],
-            SUBTITLES: [],
-        };
-
-        for (const uri of stream.hlsVariantState.keys()) {
-            // Find the original parsed tag (either variant or media) to get its metadata
-            const variant = (stream.manifest.variants || []).find(
-                (v) => v.resolvedUri === uri
-            );
-
-            const serialized = stream.manifest.serializedManifest;
-            const media =
-                serialized &&
-                'media' in serialized &&
-                Array.isArray(serialized.media)
-                    ? serialized.media.find(
-                          (m) =>
-                              m.URI &&
-                              new URL(m.URI, stream.baseUrl).href === uri
-                      )
-                    : null;
-
-            if (variant) {
-                groupedPlaylists.VIDEO.push({
-                    title: `Variant Stream (BW: ${(
-                        variant.attributes.BANDWIDTH / 1000
-                    ).toFixed(0)}k, Res: ${
-                        variant.attributes.RESOLUTION || 'N/A'
-                    })`,
-                    uri,
-                });
-            } else if (media) {
-                const type = media.TYPE || 'UNKNOWN';
-                if (!groupedPlaylists[type]) groupedPlaylists[type] = [];
-                groupedPlaylists[type].push({
-                    title: `${media.NAME || media.LANGUAGE || 'Rendition'} (${
-                        media.LANGUAGE || 'N/A'
-                    })`,
-                    uri,
-                });
-            }
-        }
-
-        const groupTemplate = (title, items) => {
-            if (items.length === 0) return '';
-            return html`
-                <div class="mt-4">
-                    <h4 class="text-md font-semibold text-gray-400 mb-2">
-                        ${title}
-                    </h4>
-                    <div class="space-y-1">
-                        ${items.map((item) =>
-                            renderVariant(stream, item, item.uri)
-                        )}
-                    </div>
-                </div>
-            `;
-        };
-
-        return html`
-            <div>
-                ${groupTemplate('Variant Streams', groupedPlaylists.VIDEO)}
-                ${groupTemplate('Audio Renditions', groupedPlaylists.AUDIO)}
-                ${groupTemplate(
-                    'Subtitle Renditions',
-                    groupedPlaylists.SUBTITLES
-                )}
-            </div>
-        `;
-    } else {
-        // This is a simple Media Playlist
-        const mediaVariant = {
-            title: 'Media Playlist Segments',
-            uri: stream.originalUrl,
-        };
-        return renderVariant(stream, mediaVariant, mediaVariant.uri);
-    }
-}
diff --git a/js/ui/views/segment-explorer/index.js b/js/ui/views/segment-explorer/index.js
deleted file mode 100644
index 7d51744..0000000
--- a/js/ui/views/segment-explorer/index.js
+++ /dev/null
@@ -1,115 +0,0 @@
-import { html, render } from 'lit-html';
-import { useStore } from '../../../app/store.js';
-import { eventBus } from '../../../app/event-bus.js';
-import { getDashExplorerTemplate } from './components/dash/index.js';
-import {
-    getHlsExplorerTemplate,
-    startLiveSegmentHighlighter,
-    stopLiveSegmentHighlighter,
-} from './components/hls/index.js';
-import { renderApp } from '../../mainRenderer.js';
-
-let dashDisplayMode = 'first';
-
-function handleCompareClick() {
-    const { segmentsForCompare } = useStore.getState();
-    if (segmentsForCompare.length !== 2) return;
-    eventBus.dispatch('ui:request-segment-comparison', {
-        urlA: segmentsForCompare[0],
-        urlB: segmentsForCompare[1],
-    });
-}
-
-function handleDashModeClick(mode) {
-    if (dashDisplayMode === mode) return;
-    dashDisplayMode = mode;
-    renderApp();
-}
-
-function updateCompareButton() {
-    const { segmentsForCompare } = useStore.getState();
-    const compareButton = document.getElementById('segment-compare-btn');
-    if (compareButton) {
-        compareButton.textContent = `Compare Selected (${segmentsForCompare.length}/2)`;
-        compareButton.toggleAttribute(
-            'disabled',
-            segmentsForCompare.length !== 2
-        );
-    }
-}
-
-function getSegmentExplorerTemplate(stream) {
-    const isDynamic = stream.manifest?.type === 'dynamic';
-
-    const controlsTemplate = html`
-        <div
-            id="segment-explorer-controls"
-            class="flex items-center flex-wrap gap-4"
-        >
-            ${stream.protocol === 'dash'
-                ? html`
-                      <button
-                          @click=${() => handleDashModeClick('first')}
-                          class="text-sm font-bold py-2 px-3 rounded-md transition-colors ${dashDisplayMode ===
-                          'first'
-                              ? 'bg-blue-600 text-white'
-                              : 'bg-gray-600 hover:bg-gray-700 text-white'}"
-                      >
-                          First 10
-                      </button>
-                      ${isDynamic
-                          ? html`<button
-                                @click=${() => handleDashModeClick('last')}
-                                class="text-sm font-bold py-2 px-3 rounded-md transition-colors ${dashDisplayMode ===
-                                'last'
-                                    ? 'bg-blue-600 text-white'
-                                    : 'bg-gray-600 hover:bg-gray-700 text-white'}"
-                            >
-                                Last 10
-                            </button>`
-                          : ''}
-                  `
-                : ''}
-            <button
-                id="segment-compare-btn"
-                @click=${handleCompareClick}
-                class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-3 rounded-md transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
-            >
-                Compare Selected (0/2)
-            </button>
-        </div>
-    `;
-
-    let contentTemplate;
-    if (stream.protocol === 'dash') {
-        contentTemplate = getDashExplorerTemplate(stream, dashDisplayMode);
-    } else {
-        contentTemplate = getHlsExplorerTemplate(stream);
-    }
-
-    // Defer the button update until after the render
-    setTimeout(updateCompareButton, 0);
-
-    return html`
-        <div class="flex flex-wrap justify-between items-center mb-4 gap-4">
-            <h3 class="text-xl font-bold">Segment Explorer</h3>
-            ${controlsTemplate}
-        </div>
-        <div
-            id="segment-explorer-content"
-            data-testid="segment-explorer-content"
-        >
-            ${contentTemplate}
-        </div>
-    `;
-}
-
-export function initializeSegmentExplorer(container, stream) {
-    stopLiveSegmentHighlighter();
-
-    if (stream.manifest.type === 'dynamic' && stream.protocol === 'hls') {
-        startLiveSegmentHighlighter(container, stream);
-    }
-
-    render(getSegmentExplorerTemplate(stream), container);
-}
diff --git a/js/ui/views/summary/components/cmaf.js b/js/ui/views/summary/components/cmaf.js
deleted file mode 100644
index ec3cf2d..0000000
--- a/js/ui/views/summary/components/cmaf.js
+++ /dev/null
@@ -1,143 +0,0 @@
-import { html } from 'lit-html';
-import { useStore, storeActions } from '../../../../app/store.js';
-
-const getOverallStatus = (results) => {
-    if (!results || results.length === 0) {
-        return {
-            text: 'Pending',
-            color: 'text-gray-400',
-            errors: 0,
-            warnings: 0,
-        };
-    }
-
-    const errors = results.filter((r) => r.status === 'fail').length;
-    const warnings = results.filter((r) => r.status === 'warn').length;
-
-    if (errors > 0) {
-        return { text: 'Fail', color: 'text-red-400', errors, warnings };
-    }
-    if (warnings > 0) {
-        return { text: 'Warning', color: 'text-yellow-400', errors, warnings };
-    }
-    return { text: 'Pass', color: 'text-green-400', errors, warnings };
-};
-
-const resultRowTemplate = (result) => {
-    const statusClasses = {
-        pass: 'text-green-400',
-        fail: 'text-red-400',
-        warn: 'text-yellow-400',
-        info: 'text-blue-400',
-    };
-    const icon = {
-        pass: '✓',
-        fail: '✗',
-        warn: '⚠️',
-        info: 'ℹ',
-    };
-    return html`
-        <tr class="hover:bg-gray-700/50">
-            <td class="p-2 border-t border-gray-700 w-16 text-center">
-                <span class="${statusClasses[result.status]} font-bold"
-                    >${icon[result.status]}</span
-                >
-            </td>
-            <td class="p-2 border-t border-gray-700 text-gray-300">
-                ${result.text}
-            </td>
-            <td class="p-2 border-t border-gray-700 text-gray-400 break-words">
-                ${result.details}
-            </td>
-        </tr>
-    `;
-};
-
-export const cmafValidationSummaryTemplate = (stream) => {
-    const results = stream.semanticData?.get('cmafValidation');
-    const overallStatus = getOverallStatus(results);
-    const { isCmafSummaryExpanded } = useStore.getState();
-
-    const toggleExpand = () => {
-        storeActions.toggleCmafSummary();
-    };
-
-    return html`
-        <div>
-            <h3 class="text-xl font-bold mb-4">CMAF Conformance</h3>
-            <div class="bg-gray-800 p-4 rounded-lg border border-gray-700">
-                <div class="flex justify-between items-center mb-4">
-                    <span class="text-sm font-medium text-gray-400"
-                        >Overall Status</span
-                    >
-                    <span class="text-lg font-bold ${overallStatus.color}"
-                        >${overallStatus.text}</span
-                    >
-                </div>
-
-                <div class="flex justify-around text-center mb-4">
-                    <div>
-                        <div class="text-2xl font-bold text-red-400">
-                            ${overallStatus.errors}
-                        </div>
-                        <div class="text-xs text-gray-400">Errors</div>
-                    </div>
-                    <div>
-                        <div class="text-2xl font-bold text-yellow-400">
-                            ${overallStatus.warnings}
-                        </div>
-                        <div class="text-xs text-gray-400">Warnings</div>
-                    </div>
-                </div>
-
-                ${results
-                    ? html`
-                          <button
-                              @click=${toggleExpand}
-                              class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-300"
-                          >
-                              ${isCmafSummaryExpanded
-                                  ? 'Hide Details'
-                                  : 'View Details'}
-                          </button>
-                      `
-                    : ''}
-                ${isCmafSummaryExpanded && results
-                    ? html` <div
-                          class="bg-gray-900/50 rounded border border-gray-700/50 overflow-hidden mt-4"
-                      >
-                          <table class="w-full text-left text-xs table-auto">
-                              <thead class="bg-gray-800/50">
-                                  <tr>
-                                      <th
-                                          class="p-2 font-semibold text-gray-400"
-                                      >
-                                          Status
-                                      </th>
-                                      <th
-                                          class="p-2 font-semibold text-gray-400"
-                                      >
-                                          Check
-                                      </th>
-                                      <th
-                                          class="p-2 font-semibold text-gray-400"
-                                      >
-                                          Details
-                                      </th>
-                                  </tr>
-                              </thead>
-                              <tbody>
-                                  ${results.map(resultRowTemplate)}
-                              </tbody>
-                          </table>
-                      </div>`
-                    : ''}
-                ${!results
-                    ? html`<div class="text-sm text-gray-500 text-center py-4">
-                          Running conformance checks...
-                      </div>`
-                    : ''}
-            </div>
-        </div>
-    `;
-};
diff --git a/js/ui/views/summary/components/dash-compliance.js b/js/ui/views/summary/components/dash-compliance.js
deleted file mode 100644
index 8193815..0000000
--- a/js/ui/views/summary/components/dash-compliance.js
+++ /dev/null
@@ -1,71 +0,0 @@
-import { html } from 'lit-html';
-import { storeActions } from '../../../../app/store.js';
-
-const getOverallStatus = (results) => {
-    if (!results || results.length === 0) {
-        return {
-            text: 'Not Run',
-            color: 'text-gray-400',
-            errors: 0,
-            warnings: 0,
-        };
-    }
-
-    const errors = results.filter((r) => r.status === 'fail').length;
-    const warnings = results.filter((r) => r.status === 'warn').length;
-
-    if (errors > 0) {
-        return { text: 'Fail', color: 'text-red-400', errors, warnings };
-    }
-    if (warnings > 0) {
-        return { text: 'Warning', color: 'text-yellow-400', errors, warnings };
-    }
-    return { text: 'Pass', color: 'text-green-400', errors, warnings };
-};
-
-export const dashComplianceSummaryTemplate = (stream) => {
-    const results = stream.manifestUpdates[0]?.complianceResults;
-    const overallStatus = getOverallStatus(results);
-
-    const handleViewReportClick = () => {
-        storeActions.setActiveTab('compliance');
-    };
-
-    return html`
-        <div>
-            <h3 class="text-xl font-bold mb-4">DASH-IF Compliance</h3>
-            <div class="bg-gray-800 p-4 rounded-lg border border-gray-700">
-                <div class="flex justify-between items-center mb-4">
-                    <span class="text-sm font-medium text-gray-400"
-                        >Overall Status</span
-                    >
-                    <span class="text-lg font-bold ${overallStatus.color}"
-                        >${overallStatus.text}</span
-                    >
-                </div>
-
-                <div class="flex justify-around text-center mb-4">
-                    <div>
-                        <div class="text-2xl font-bold text-red-400">
-                            ${overallStatus.errors}
-                        </div>
-                        <div class="text-xs text-gray-400">Errors</div>
-                    </div>
-                    <div>
-                        <div class="text-2xl font-bold text-yellow-400">
-                            ${overallStatus.warnings}
-                        </div>
-                        <div class="text-xs text-gray-400">Warnings</div>
-                    </div>
-                </div>
-
-                <button
-                    @click=${handleViewReportClick}
-                    class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-300"
-                >
-                    View Full Report
-                </button>
-            </div>
-        </div>
-    `;
-};
diff --git a/js/ui/views/summary/components/dash-structure.js b/js/ui/views/summary/components/dash-structure.js
deleted file mode 100644
index 8870267..0000000
--- a/js/ui/views/summary/components/dash-structure.js
+++ /dev/null
@@ -1,136 +0,0 @@
-import { html } from 'lit-html';
-import { trackTableTemplate } from './shared.js';
-
-const advancedPropertiesTemplate = (as) => {
-    const failover = as.representations[0]?.failoverContent;
-    const resyncs = as.resyncs || as.representations[0]?.resyncs;
-    const switchingProperty = (
-        as.serializedManifest.SupplementalProperty || []
-    ).find(
-        (p) =>
-            p[':@'].schemeIdUri ===
-            'urn:mpeg:dash:adaptation-set-switching:2016'
-    );
-
-    if (!failover && (!resyncs || resyncs.length === 0) && !switchingProperty)
-        return '';
-
-    return html`
-        <div class="mt-2 p-2 bg-gray-900/50 rounded-md">
-            <h6 class="text-xs font-semibold text-gray-400">
-                Advanced Properties
-            </h6>
-            <dl
-                class="grid grid-cols-[auto_1fr] gap-x-2 text-xs font-mono mt-1"
-            >
-                ${failover
-                    ? html`
-                          <dt class="text-gray-500">Failover:</dt>
-                          <dd class="text-gray-300">
-                              ${failover.valid ? 'Valid' : 'Not Valid'}
-                          </dd>
-                      `
-                    : ''}
-                ${resyncs && resyncs.length > 0
-                    ? html`
-                          <dt class="text-gray-500">Resync:</dt>
-                          <dd class="text-gray-300">
-                              Type ${resyncs[0].type}
-                              ${resyncs[0].dT ? `| dT=${resyncs[0].dT}` : ''}
-                          </dd>
-                      `
-                    : ''}
-                ${switchingProperty
-                    ? html`
-                          <dt class="text-gray-500">Switching:</dt>
-                          <dd class="text-gray-300">
-                              &#8660; ${switchingProperty[':@'].value}
-                          </dd>
-                      `
-                    : ''}
-            </dl>
-        </div>
-    `;
-};
-
-const adaptationSetTemplate = (as, type) => {
-    return html`
-        <div class="space-y-2">
-            <h5 class="font-semibold text-gray-300">
-                ${type.charAt(0).toUpperCase() + type.slice(1)} AdaptationSet:
-                <span class="font-mono text-sm">${as.id || 'N/A'}</span>
-            </h5>
-            <div class="pl-4">
-                ${trackTableTemplate(as.representations, type)}
-                ${advancedPropertiesTemplate(as)}
-            </div>
-        </div>
-    `;
-};
-
-const subsetTemplate = (period) => {
-    if (!period.subsets || period.subsets.length === 0) return '';
-    return html`
-        <div class="mt-4">
-            <h5 class="font-semibold text-gray-300">Subsets</h5>
-            <div class="text-xs font-mono text-gray-400 pl-4">
-                ${period.subsets.map(
-                    (s) =>
-                        html`<div>
-                            <strong>${s.id || 'default'}:</strong> contains
-                            [${s.contains.join(', ')}]
-                        </div>`
-                )}
-            </div>
-        </div>
-    `;
-};
-
-const periodTemplate = (period, index) => html`
-    <details class="bg-gray-800 rounded-lg border border-gray-700" open>
-        <summary
-            class="font-bold text-lg p-3 cursor-pointer hover:bg-gray-700/50"
-        >
-            Period: ${period.id || `(index ${index})`}
-            <span class="font-normal font-mono text-sm text-gray-400"
-                >(Start: ${period.start}s, Duration:
-                ${period.duration ? period.duration + 's' : 'N/A'})</span
-            >
-        </summary>
-        <div class="p-4 border-t border-gray-700 space-y-4">
-            ${period.videoTracks.length > 0
-                ? period.videoTracks.map((as) =>
-                      adaptationSetTemplate(as, 'video')
-                  )
-                : html`<p class="text-xs text-gray-500">
-                      No video Adaptation Sets in this period.
-                  </p>`}
-            ${period.audioTracks.length > 0
-                ? period.audioTracks.map((as) =>
-                      adaptationSetTemplate(as, 'audio')
-                  )
-                : ''}
-            ${period.textTracks.length > 0
-                ? period.textTracks.map((as) =>
-                      adaptationSetTemplate(as, 'text')
-                  )
-                : ''}
-            ${subsetTemplate(period)}
-        </div>
-    </details>
-`;
-
-export const dashStructureTemplate = (summary) => {
-    return summary.content.periods.length > 0
-        ? html`
-              <div>
-                  <h3 class="text-xl font-bold mb-4">Stream Structure</h3>
-                  <div class="space-y-4">
-                      ${summary.content.periods.map((p, i) =>
-                          periodTemplate(p, i)
-                      )}
-                  </div>
-              </div>
-          `
-        : '';
-};
diff --git a/js/ui/views/summary/components/delivery.js b/js/ui/views/summary/components/delivery.js
deleted file mode 100644
index b16f565..0000000
--- a/js/ui/views/summary/components/delivery.js
+++ /dev/null
@@ -1,104 +0,0 @@
-import { html } from 'lit-html';
-import { tooltipTriggerClasses } from '../../../../shared/constants.js';
-
-const steeringValidationResultTemplate = (result) => {
-    if (!result) {
-        return html`<p class="text-xs text-gray-400">Not validated.</p>`;
-    }
-    if (result.isValid) {
-        return html`<div class="flex items-center gap-2">
-            <svg
-                xmlns="http://www.w3.org/2000/svg"
-                class="h-4 w-4 text-green-400"
-                fill="none"
-                viewBox="0 0 24 24"
-                stroke="currentColor"
-                stroke-width="2"
-            >
-                <path
-                    stroke-linecap="round"
-                    stroke-linejoin="round"
-                    d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"
-                />
-            </svg>
-            <span class="text-xs text-green-300 font-semibold"
-                >Validation Passed</span
-            >
-        </div>`;
-    }
-    return html`<div class="flex items-start gap-2">
-        <svg
-            xmlns="http://www.w3.org/2000/svg"
-            class="h-4 w-4 text-red-400 flex-shrink-0 mt-0.5"
-            fill="none"
-            viewBox="0 0 24 24"
-            stroke="currentColor"
-            stroke-width="2"
-        >
-            <path
-                stroke-linecap="round"
-                stroke-linejoin="round"
-                d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"
-            />
-        </svg>
-        <div>
-            <span class="text-xs text-red-300 font-semibold"
-                >Validation Failed</span
-            >
-            <ul class="list-disc pl-4 mt-1 text-xs text-red-200">
-                ${result.errors.map((err) => html`<li>${err}</li>`)}
-            </ul>
-        </div>
-    </div>`;
-};
-
-export const deliveryInfoTemplate = (stream) => {
-    const steeringTag = stream.steeringInfo;
-    const validationResult = stream.semanticData.get('steeringValidation');
-
-    if (!steeringTag) {
-        return '';
-    }
-
-    return html`
-        <div>
-            <h3 class="text-xl font-bold mb-4">Delivery & Steering</h3>
-            <div class="bg-gray-800 p-4 rounded-lg border border-gray-700">
-                <dl class="grid gap-x-4 gap-y-2 grid-cols-[auto_1fr]">
-                    <dt
-                        class="text-sm font-medium text-gray-400 ${tooltipTriggerClasses}"
-                        data-tooltip="The URI of the Content Steering manifest."
-                        data-iso="HLS: 4.4.6.6"
-                    >
-                        Steering Server URI
-                    </dt>
-                    <dd class="text-sm font-mono text-white break-all">
-                        ${steeringTag.value['SERVER-URI']}
-                    </dd>
-
-                    <dt
-                        class="text-sm font-medium text-gray-400 ${tooltipTriggerClasses}"
-                        data-tooltip="The initial Pathway to apply until the steering manifest is loaded."
-                        data-iso="HLS: 4.4.6.6"
-                    >
-                        Default Pathway ID
-                    </dt>
-                    <dd class="text-sm font-mono text-white">
-                        ${steeringTag.value['PATHWAY-ID'] || '.(default)'}
-                    </dd>
-
-                    <dt
-                        class="text-sm font-medium text-gray-400 ${tooltipTriggerClasses}"
-                        data-tooltip="The result of fetching and validating the steering manifest against the HLS specification."
-                        data-iso="HLS: 7.2"
-                    >
-                        Validation Status
-                    </dt>
-                    <dd>
-                        ${steeringValidationResultTemplate(validationResult)}
-                    </dd>
-                </dl>
-            </div>
-        </div>
-    `;
-};
diff --git a/js/ui/views/summary/components/hls-compliance.js b/js/ui/views/summary/components/hls-compliance.js
deleted file mode 100644
index 626672f..0000000
--- a/js/ui/views/summary/components/hls-compliance.js
+++ /dev/null
@@ -1,71 +0,0 @@
-import { html } from 'lit-html';
-import { storeActions } from '../../../../app/store.js';
-
-const getOverallStatus = (results) => {
-    if (!results || results.length === 0) {
-        return {
-            text: 'Not Run',
-            color: 'text-gray-400',
-            errors: 0,
-            warnings: 0,
-        };
-    }
-
-    const errors = results.filter((r) => r.status === 'fail').length;
-    const warnings = results.filter((r) => r.status === 'warn').length;
-
-    if (errors > 0) {
-        return { text: 'Fail', color: 'text-red-400', errors, warnings };
-    }
-    if (warnings > 0) {
-        return { text: 'Warning', color: 'text-yellow-400', errors, warnings };
-    }
-    return { text: 'Pass', color: 'text-green-400', errors, warnings };
-};
-
-export const hlsComplianceSummaryTemplate = (stream) => {
-    const results = stream.manifestUpdates[0]?.complianceResults;
-    const overallStatus = getOverallStatus(results);
-
-    const handleViewReportClick = () => {
-        storeActions.setActiveTab('compliance');
-    };
-
-    return html`
-        <div>
-            <h3 class="text-xl font-bold mb-4">HLS Compliance</h3>
-            <div class="bg-gray-800 p-4 rounded-lg border border-gray-700">
-                <div class="flex justify-between items-center mb-4">
-                    <span class="text-sm font-medium text-gray-400"
-                        >Overall Status</span
-                    >
-                    <span class="text-lg font-bold ${overallStatus.color}"
-                        >${overallStatus.text}</span
-                    >
-                </div>
-
-                <div class="flex justify-around text-center mb-4">
-                    <div>
-                        <div class="text-2xl font-bold text-red-400">
-                            ${overallStatus.errors}
-                        </div>
-                        <div class="text-xs text-gray-400">Errors</div>
-                    </div>
-                    <div>
-                        <div class="text-2xl font-bold text-yellow-400">
-                            ${overallStatus.warnings}
-                        </div>
-                        <div class="text-xs text-gray-400">Warnings</div>
-                    </div>
-                </div>
-
-                <button
-                    @click=${handleViewReportClick}
-                    class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-300"
-                >
-                    View Full Report
-                </button>
-            </div>
-        </div>
-    `;
-};
diff --git a/js/ui/views/summary/components/hls-media-playlist.js b/js/ui/views/summary/components/hls-media-playlist.js
deleted file mode 100644
index 7bc21af..0000000
--- a/js/ui/views/summary/components/hls-media-playlist.js
+++ /dev/null
@@ -1,45 +0,0 @@
-import { html } from 'lit-html';
-import { statCardTemplate } from './shared.js';
-
-export const hlsMediaPlaylistTemplate = (summary) => {
-    const mediaPlaylistDetails = summary.hls?.mediaPlaylistDetails;
-
-    if (!mediaPlaylistDetails) {
-        return '';
-    }
-
-    return html`
-        <div>
-            <h3 class="text-xl font-bold mb-4">Media Playlist Details</h3>
-            <dl
-                class="grid gap-4 grid-cols-[repeat(auto-fit,minmax(280px,1fr))]"
-            >
-                ${statCardTemplate(
-                    'Segment Count',
-                    mediaPlaylistDetails.segmentCount,
-                    'Total number of media segments in this playlist.',
-                    'HLS: 4.3.2.1'
-                )}
-                ${statCardTemplate(
-                    'Avg. Segment Duration',
-                    mediaPlaylistDetails.averageSegmentDuration?.toFixed(2) +
-                        's',
-                    'The average duration of all segments.',
-                    'HLS: 4.3.2.1'
-                )}
-                ${statCardTemplate(
-                    'Discontinuities Present',
-                    mediaPlaylistDetails.hasDiscontinuity ? 'Yes' : 'No',
-                    'Indicates if the playlist contains discontinuity tags, often used for ad insertion.',
-                    'HLS: 4.3.2.3'
-                )}
-                ${statCardTemplate(
-                    'I-Frame Only',
-                    mediaPlaylistDetails.isIFrameOnly ? 'Yes' : 'No',
-                    'Indicates if all segments in this playlist are I-Frame only.',
-                    'HLS: 4.3.3.6'
-                )}
-            </dl>
-        </div>
-    `;
-};
diff --git a/js/ui/views/summary/components/hls-structure.js b/js/ui/views/summary/components/hls-structure.js
deleted file mode 100644
index d1c5b0b..0000000
--- a/js/ui/views/summary/components/hls-structure.js
+++ /dev/null
@@ -1,69 +0,0 @@
-import { html } from 'lit-html';
-import { trackTableTemplate } from './shared.js';
-
-export const hlsStructureTemplate = (summary) => {
-    const hasVideo = summary.videoTracks.length > 0;
-    const hasAudio = summary.audioTracks.length > 0;
-    const hasText = summary.textTracks.length > 0;
-
-    const iFramePlaylists =
-        summary.hls.iFramePlaylists > 0
-            ? summary.hlsParsed.tags
-                  .filter((t) => t.name === 'EXT-X-I-FRAME-STREAM-INF')
-                  .map((t) => ({
-                      id: 'I-Frame',
-                      bitrateRange: t.value.BANDWIDTH,
-                      resolutions: [t.value.RESOLUTION],
-                      codecs: [t.value.CODECS],
-                      roles: [],
-                  }))
-            : [];
-    const hasIFrame = iFramePlaylists.length > 0;
-
-    if (!hasVideo && !hasAudio && !hasText && !hasIFrame) {
-        return html`<div>
-            <h3 class="text-xl font-bold mb-4">Stream Structure</h3>
-            <p class="text-xs text-gray-500">
-                This media playlist does not contain explicit track information.
-            </p>
-        </div>`;
-    }
-
-    return html`
-        <div>
-            <h3 class="text-xl font-bold mb-4">Stream Structure</h3>
-            <div class="space-y-4">
-                ${hasVideo
-                    ? html`<div>
-                          <h4 class="text-lg font-bold mb-2">Video Tracks</h4>
-                          ${trackTableTemplate(summary.videoTracks, 'video')}
-                      </div>`
-                    : ''}
-                ${hasAudio
-                    ? html`<div class="mt-4">
-                          <h4 class="text-lg font-bold mb-2">
-                              Audio Renditions
-                          </h4>
-                          ${trackTableTemplate(summary.audioTracks, 'audio')}
-                      </div>`
-                    : ''}
-                ${hasText
-                    ? html`<div class="mt-4">
-                          <h4 class="text-lg font-bold mb-2">
-                              Text Renditions
-                          </h4>
-                          ${trackTableTemplate(summary.textTracks, 'text')}
-                      </div>`
-                    : ''}
-                ${hasIFrame
-                    ? html`<div class="mt-4">
-                          <h4 class="text-lg font-bold mb-2">
-                              I-Frame Playlists (for Trick Play)
-                          </h4>
-                          ${trackTableTemplate(iFramePlaylists, 'video')}
-                      </div>`
-                    : ''}
-            </div>
-        </div>
-    `;
-};
diff --git a/js/ui/views/summary/components/shared.js b/js/ui/views/summary/components/shared.js
deleted file mode 100644
index 3deec06..0000000
--- a/js/ui/views/summary/components/shared.js
+++ /dev/null
@@ -1,140 +0,0 @@
-import { html } from 'lit-html';
-import { tooltipTriggerClasses } from '../../../../shared/constants.js';
-
-export const statCardTemplate = (
-    label,
-    value,
-    tooltipText,
-    isoRef,
-    customClasses = ''
-) => {
-    if (
-        value === null ||
-        value === undefined ||
-        value === '' ||
-        (Array.isArray(value) && value.length === 0)
-    )
-        return '';
-    const testId = `stat-card-${label.toLowerCase().replace(/[\s/]+/g, '-')}`;
-    return html`
-        <div
-            data-testid="${testId}"
-            class="bg-gray-800 p-3 rounded-lg border border-gray-700 ${customClasses}"
-        >
-            <dt
-                class="text-xs font-medium text-gray-400 ${tooltipTriggerClasses}"
-                data-tooltip="${tooltipText}"
-                data-iso="${isoRef}"
-            >
-                ${label}
-            </dt>
-            <dd
-                class="text-base text-left font-mono text-white mt-1 break-words"
-            >
-                ${value}
-            </dd>
-        </div>
-    `;
-};
-
-export const trackTableTemplate = (tracks, type) => {
-    if (!tracks || tracks.length === 0) return '';
-    let headers;
-    let rows;
-
-    const formatBitrate = (bps) => {
-        if (typeof bps === 'string' && bps.includes('bps')) return bps;
-        if (!bps || isNaN(bps)) return 'N/A';
-        if (bps >= 1000000) return `${(bps / 1000000).toFixed(2)} Mbps`;
-        return `${(bps / 1000).toFixed(0)} kbps`;
-    };
-
-    if (type === 'video') {
-        headers = ['ID', 'Bitrate', 'Resolution', 'Codecs', 'Roles'];
-        rows = tracks.map(
-            (track) => html`
-                <tr>
-                    <td class="p-2 font-mono">${track.id}</td>
-                    <td class="p-2 font-mono">
-                        ${track.bitrateRange || formatBitrate(track.bandwidth)}
-                    </td>
-                    <td class="p-2 font-mono">
-                        ${track.resolutions?.join(', ') ||
-                        `${track.width}x${track.height}`}
-                    </td>
-                    <td class="p-2 font-mono">
-                        ${track.codecs?.join
-                            ? track.codecs.join(', ')
-                            : track.codecs || 'N/A'}
-                    </td>
-                    <td class="p-2 font-mono">
-                        ${track.roles?.join(', ') || 'N/A'}
-                    </td>
-                </tr>
-            `
-        );
-    } else if (type === 'audio') {
-        headers = ['ID', 'Language', 'Codecs', 'Channels', 'Roles'];
-        rows = tracks.map(
-            (track) => html`
-                <tr>
-                    <td class="p-2 font-mono">${track.id}</td>
-                    <td class="p-2 font-mono">${track.lang || 'N/A'}</td>
-                    <td class="p-2 font-mono">
-                        ${track.codecs?.join
-                            ? track.codecs.join(', ')
-                            : track.codecs || 'N/A'}
-                    </td>
-                    <td class="p-2 font-mono">${track.channels || 'N/A'}</td>
-                    <td class="p-2 font-mono">
-                        ${track.roles?.join(', ') || 'N/A'}
-                    </td>
-                </tr>
-            `
-        );
-    } else {
-        // text
-        headers = ['ID', 'Language', 'Format', 'Roles'];
-        rows = tracks.map(
-            (track) => html`
-                <tr>
-                    <td class="p-2 font-mono">${track.id}</td>
-                    <td class="p-2 font-mono">${track.lang || 'N/A'}</td>
-                    <td class="p-2 font-mono">
-                        ${track.codecsOrMimeTypes?.join(', ') ||
-                        track.codecs ||
-                        track.mimeType ||
-                        'N/A'}
-                    </td>
-                    <td class="p-2 font-mono">
-                        ${track.roles?.join(', ') || 'N/A'}
-                    </td>
-                </tr>
-            `
-        );
-    }
-
-    return html`
-        <div
-            class="bg-gray-900/50 rounded border border-gray-700/50 overflow-x-auto"
-        >
-            <table class="w-full text-left text-xs min-w-[600px]">
-                <thead class="bg-gray-800/50">
-                    <tr>
-                        ${headers.map(
-                            (h) =>
-                                html`<th
-                                    class="p-2 font-semibold text-gray-400"
-                                >
-                                    ${h}
-                                </th>`
-                        )}
-                    </tr>
-                </thead>
-                <tbody class="divide-y divide-gray-700/50">
-                    ${rows}
-                </tbody>
-            </table>
-        </div>
-    `;
-};
diff --git a/js/ui/views/summary/dash.js b/js/ui/views/summary/dash.js
deleted file mode 100644
index 36b5aca..0000000
--- a/js/ui/views/summary/dash.js
+++ /dev/null
@@ -1,328 +0,0 @@
-import { html } from 'lit-html';
-import { cmafValidationSummaryTemplate } from './components/cmaf.js';
-import { dashComplianceSummaryTemplate } from './components/dash-compliance.js';
-import { dashStructureTemplate } from './components/dash-structure.js';
-import { statCardTemplate } from './components/shared.js';
-import { tooltipTriggerClasses } from '../../../shared/constants.js';
-
-const profilesCardTemplate = (stream) => {
-    const { manifest } = stream;
-    const summary = manifest.summary;
-    const profileString = summary.dash.profiles || '';
-    const profiles = profileString.split(',').map((p) => p.trim());
-    const supportedKeywords = ['isoff', 'mp2t', 'isobmff', 'ts'];
-    let overallSupported = true;
-
-    const profileDetails = profiles.map((profile) => {
-        let isProfileSupported = supportedKeywords.some((keyword) =>
-            profile.toLowerCase().includes(keyword)
-        );
-        let explanation =
-            'This is a standard MPEG-DASH profile based on a supported container format (ISOBMFF or MPEG-2 TS).';
-
-        if (
-            profile.toLowerCase().includes('hbbtv') ||
-            profile.toLowerCase().includes('dash-if')
-        ) {
-            isProfileSupported = false; // Mark as partial
-            explanation =
-                'This is a known extension profile. While the base format is supported, HbbTV or DASH-IF specific rules are not validated.';
-        }
-
-        if (!isProfileSupported) {
-            overallSupported = false;
-        }
-
-        return { profile, isSupported: isProfileSupported, explanation };
-    });
-
-    const overallIcon = overallSupported
-        ? html`<svg
-              xmlns="http://www.w3.org/2000/svg"
-              class="h-5 w-5 text-green-400"
-              fill="none"
-              viewBox="0 0 24 24"
-              stroke="currentColor"
-              stroke-width="2"
-          >
-              <path
-                  stroke-linecap="round"
-                  stroke-linejoin="round"
-                  d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"
-              />
-          </svg>`
-        : html`<svg
-              xmlns="http://www.w3.org/2000/svg"
-              class="h-5 w-5 text-yellow-400"
-              fill="none"
-              viewBox="0 0 24 24"
-              stroke="currentColor"
-              stroke-width="2"
-          >
-              <path
-                  stroke-linecap="round"
-                  stroke-linejoin="round"
-                  d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
-              />
-          </svg>`;
-    const overallStatusText = overallSupported
-        ? 'Supported'
-        : 'Partial/Unsupported';
-    const overallStatusColor = overallSupported
-        ? 'text-green-400'
-        : 'text-yellow-400';
-    const overallExplanation = overallSupported
-        ? 'All declared profiles are supported for analysis.'
-        : 'One or more profiles have constraints not validated by this tool.';
-
-    return html`
-        <div class="bg-gray-800 p-4 rounded-lg border border-gray-700">
-            <dt
-                class="flex justify-between items-center text-sm font-medium text-gray-400 ${tooltipTriggerClasses}"
-                data-tooltip="Indicates the set of features used in the manifest."
-                data-iso="DASH: 8.1"
-            >
-                Declared Profiles
-                <div
-                    class="flex items-center gap-2 ${tooltipTriggerClasses}"
-                    data-tooltip="${overallExplanation}"
-                >
-                    ${overallIcon}
-                    <span class="text-sm font-semibold ${overallStatusColor}"
-                        >${overallStatusText}</span
-                    >
-                </div>
-            </dt>
-            <dd class="text-base text-left font-mono text-white mt-2 space-y-2">
-                ${profileDetails.map(
-                    (item) =>
-                        html` <div
-                            class="flex items-center gap-2 text-xs p-1 bg-gray-900/50 rounded"
-                        >
-                            <span
-                                class="flex-shrink-0 ${tooltipTriggerClasses}"
-                                data-tooltip="${item.explanation}"
-                            >
-                                <!-- Icons omitted for brevity -->
-                            </span>
-                            <span class="break-all">${item.profile}</span>
-                        </div>`
-                )}
-            </dd>
-        </div>
-    `;
-};
-
-const serviceDescriptionTemplate = (stream) => {
-    const serviceDescriptions = [
-        ...(stream.manifest.serviceDescriptions || []),
-        ...stream.manifest.periods.flatMap((p) => p.serviceDescriptions || []),
-    ];
-    const latency = serviceDescriptions.flatMap((sd) => sd.latencies)[0];
-    if (!latency) return '';
-
-    return html`
-        <div>
-            <h3 class="text-xl font-bold mb-4">
-                Low-Latency Service Description
-            </h3>
-            <dl
-                class="grid gap-4 grid-cols-[repeat(auto-fit,minmax(200px,1fr))]"
-            >
-                ${statCardTemplate(
-                    'Target Latency',
-                    latency.target ? `${latency.target}ms` : 'N/A',
-                    'The service provider’s preferred presentation latency.',
-                    'DASH: K.3.2'
-                )}
-                ${statCardTemplate(
-                    'Min Latency',
-                    latency.min ? `${latency.min}ms` : 'N/A',
-                    'The service provider’s indicated minimum presentation latency.',
-                    'DASH: K.3.2'
-                )}
-                ${statCardTemplate(
-                    'Max Latency',
-                    latency.max ? `${latency.max}ms` : 'N/A',
-                    'The service provider’s indicated maximum presentation latency.',
-                    'DASH: K.3.2'
-                )}
-            </dl>
-        </div>
-    `;
-};
-
-const outputProtectionTemplate = (stream) => {
-    // Find the first OutputProtection descriptor available on any AdaptationSet or Representation
-    const firstProtection = stream.manifest.periods
-        .flatMap((p) => p.adaptationSets)
-        .map(
-            (as) =>
-                as.outputProtection ||
-                as.representations.find((r) => r.outputProtection)
-                    ?.outputProtection
-        )
-        .find(Boolean);
-
-    if (!firstProtection) return '';
-
-    return statCardTemplate(
-        'Output Protection',
-        firstProtection.value || firstProtection.schemeIdUri,
-        'Minimum required output protection level (e.g., HDCP version).',
-        'DASH: 5.8.4.12'
-    );
-};
-
-const preselectionTemplate = (stream) => {
-    const preselections = stream.manifest.periods.flatMap(
-        (p) => p.preselections || []
-    );
-    if (preselections.length === 0) return '';
-
-    return html`
-        <div>
-            <h3 class="text-xl font-bold mb-4">Preselections</h3>
-            <div class="space-y-2">
-                ${preselections.map(
-                    (p) => html`
-                        <div
-                            class="bg-gray-800 p-3 rounded-lg border border-gray-700"
-                        >
-                            <div class="font-semibold text-gray-300">
-                                ID: ${p.id} ${p.lang ? `(Lang: ${p.lang})` : ''}
-                            </div>
-                            <div class="text-xs text-gray-400 mt-1">
-                                Components:
-                                <span class="font-mono"
-                                    >${p.preselectionComponents.join(
-                                        ', '
-                                    )}</span
-                                >
-                            </div>
-                        </div>
-                    `
-                )}
-            </div>
-        </div>
-    `;
-};
-
-const initializationSetsTemplate = (stream) => {
-    const initSets = stream.manifest.initializationSets || [];
-    if (initSets.length === 0) return '';
-
-    return html`
-        <div>
-            <h3 class="text-xl font-bold mb-4">Initialization Sets</h3>
-            <div class="space-y-2">
-                ${initSets.map(
-                    (is) => html`
-                        <div
-                            class="bg-gray-800 p-3 rounded-lg border border-gray-700"
-                        >
-                            <div class="font-semibold text-gray-300">
-                                ID: ${is.id}
-                            </div>
-                            <div class="text-xs text-gray-400 mt-1">
-                                Codecs:
-                                <span class="font-mono">${is.codecs}</span>
-                            </div>
-                        </div>
-                    `
-                )}
-            </div>
-        </div>
-    `;
-};
-
-export function getDashSummaryTemplate(stream) {
-    const summary = stream.manifest.summary;
-
-    return html`
-        <div class="space-y-8">
-            <!-- General Section -->
-            <div>
-                <h3 class="text-xl font-bold mb-4">General Properties</h3>
-                <dl
-                    class="grid gap-4 grid-cols-[repeat(auto-fit,minmax(280px,1fr))]"
-                >
-                    ${statCardTemplate(
-                        'Stream Type',
-                        summary.general.streamType,
-                        'Indicates if the stream is live or on-demand.',
-                        'DASH: 5.3.1.2',
-                        `border-l-4 ${
-                            summary.general.streamTypeColor === 'text-red-400'
-                                ? 'border-red-500'
-                                : 'border-blue-500'
-                        }`
-                    )}
-                    ${statCardTemplate(
-                        'Container Format',
-                        summary.general.segmentFormat,
-                        'The container format for media segments.',
-                        'DASH: 5.3.7'
-                    )}
-                    ${statCardTemplate(
-                        'Media Duration',
-                        summary.general.duration
-                            ? `${summary.general.duration.toFixed(2)}s`
-                            : 'N/A',
-                        'The total duration of the content.',
-                        'DASH: 5.3.1.2'
-                    )}
-                </dl>
-                <div class="mt-4">${profilesCardTemplate(stream)}</div>
-            </div>
-
-            <!-- Low Latency Section -->
-            ${serviceDescriptionTemplate(stream)}
-
-            <!-- Compliance and Conformance Section -->
-            <div class="space-y-8">
-                <div>${dashComplianceSummaryTemplate(stream)}</div>
-                <div>${cmafValidationSummaryTemplate(stream)}</div>
-            </div>
-
-            <!-- Content & Security Section -->
-            <div>
-                <h3 class="text-xl font-bold mb-4">Content & Security</h3>
-                <dl
-                    class="grid gap-4 grid-cols-[repeat(auto-fit,minmax(280px,1fr))]"
-                >
-                    ${statCardTemplate(
-                        'Total Periods',
-                        summary.content.totalPeriods,
-                        'Number of distinct content periods.',
-                        'DASH: 5.3.2'
-                    )}
-                    ${statCardTemplate(
-                        'Encryption',
-                        summary.security.isEncrypted
-                            ? summary.security.systems.join(', ')
-                            : 'No',
-                        'Detected DRM Systems or encryption methods.',
-                        'DASH: 5.8.4.1'
-                    )}
-                    ${summary.security?.kids.length > 0
-                        ? statCardTemplate(
-                              'Key IDs (KIDs)',
-                              summary.security.kids.join(', '),
-                              'Key IDs found in the manifest.',
-                              'ISO/IEC 23001-7'
-                          )
-                        : ''}
-                    ${outputProtectionTemplate(stream)}
-                </dl>
-            </div>
-
-            <!-- Advanced Structures -->
-            ${preselectionTemplate(stream)}
-            ${initializationSetsTemplate(stream)}
-
-            <!-- Stream Structure Section -->
-            ${dashStructureTemplate(summary)}
-        </div>
-    `;
-}
diff --git a/js/ui/views/summary/hls.js b/js/ui/views/summary/hls.js
deleted file mode 100644
index df7add3..0000000
--- a/js/ui/views/summary/hls.js
+++ /dev/null
@@ -1,130 +0,0 @@
-import { html } from 'lit-html';
-import { deliveryInfoTemplate } from './components/delivery.js';
-import { hlsComplianceSummaryTemplate } from './components/hls-compliance.js';
-import { hlsStructureTemplate } from './components/hls-structure.js';
-import { hlsMediaPlaylistTemplate } from './components/hls-media-playlist.js';
-import { statCardTemplate } from './components/shared.js';
-
-export function getHlsSummaryTemplate(stream) {
-    const summary = stream.manifest.summary;
-
-    return html`
-        <div class="space-y-8">
-            <!-- General Section -->
-            <div>
-                <h3 class="text-xl font-bold mb-4">General Properties</h3>
-                <dl
-                    class="grid gap-4 grid-cols-[repeat(auto-fit,minmax(280px,1fr))]"
-                >
-                    ${statCardTemplate(
-                        'Stream Type',
-                        summary.general.streamType,
-                        'Indicates if the stream is live (EVENT) or on-demand (VOD).',
-                        'HLS: 4.3.3.5',
-                        `border-l-4 ${
-                            summary.general.streamTypeColor === 'text-red-400'
-                                ? 'border-red-500'
-                                : 'border-blue-500'
-                        }`
-                    )}
-                    ${statCardTemplate(
-                        'HLS Version',
-                        summary.hls.version,
-                        'Indicates the compatibility version of the Playlist file.',
-                        'HLS: 4.3.1.2'
-                    )}
-                    ${statCardTemplate(
-                        'Container Format',
-                        summary.general.segmentFormat,
-                        'The container format for media segments.',
-                        'HLS: 4.3.2.5'
-                    )}
-                    ${statCardTemplate(
-                        'Target Duration',
-                        summary.hls.targetDuration
-                            ? `${summary.hls.targetDuration}s`
-                            : 'N/A',
-                        'The maximum Media Segment duration.',
-                        'HLS: 4.3.3.1'
-                    )}
-                </dl>
-            </div>
-
-            <!-- Low Latency Section -->
-            <div>
-                <h3 class="text-xl font-bold mb-4">Low-Latency Status</h3>
-                <dl
-                    class="grid gap-4 grid-cols-[repeat(auto-fit,minmax(280px,1fr))]"
-                >
-                    ${statCardTemplate(
-                        'Part Target',
-                        summary.lowLatency.partTargetDuration
-                            ? `${summary.lowLatency.partTargetDuration}s`
-                            : 'Not Detected',
-                        'Target duration for LL-HLS Partial Segments.',
-                        'HLS 2nd Ed: 4.4.3.7'
-                    )}
-                    ${statCardTemplate(
-                        'Part Hold Back',
-                        summary.lowLatency.partHoldBack
-                            ? `${summary.lowLatency.partHoldBack}s`
-                            : 'Not Detected',
-                        'Server-recommended distance from the live edge for LL-HLS.',
-                        'HLS 2nd Ed: 4.4.3.8'
-                    )}
-                    ${statCardTemplate(
-                        'Can Block Reload',
-                        summary.lowLatency.isLowLatency
-                            ? summary.lowLatency.canBlockReload
-                                ? 'Yes'
-                                : 'No'
-                            : 'N/A',
-                        'Indicates server support for blocking playlist reload requests for LL-HLS.',
-                        'HLS 2nd Ed: 4.4.3.8'
-                    )}
-                </dl>
-            </div>
-
-            <!-- Compliance Section -->
-            <div>${hlsComplianceSummaryTemplate(stream)}</div>
-
-            <!-- Content & Security Section -->
-            <div>
-                <h3 class="text-xl font-bold mb-4">Content & Security</h3>
-                <dl
-                    class="grid gap-4 grid-cols-[repeat(auto-fit,minmax(280px,1fr))]"
-                >
-                    ${statCardTemplate(
-                        'I-Frame Playlists',
-                        summary.hls.iFramePlaylists,
-                        'Number of I-Frame only playlists for trick-play modes.',
-                        'HLS: 4.3.4.3'
-                    )}
-                    ${statCardTemplate(
-                        'Media Playlists',
-                        summary.content.mediaPlaylists,
-                        'Number of variant stream media playlists.',
-                        'HLS: 4.3.4.2'
-                    )}
-                    ${statCardTemplate(
-                        'Encryption',
-                        summary.security.isEncrypted
-                            ? summary.security.systems.join(', ')
-                            : 'No',
-                        'Detected encryption methods.',
-                        'HLS: 4.3.2.4'
-                    )}
-                </dl>
-            </div>
-
-            <!-- Media Playlist Details (if applicable) -->
-            ${hlsMediaPlaylistTemplate(summary)}
-
-            <!-- Stream Structure -->
-            ${hlsStructureTemplate(summary)}
-
-            <!-- Delivery Info (Steering) -->
-            ${deliveryInfoTemplate(stream)}
-        </div>
-    `;
-}
diff --git a/js/ui/views/summary/index.js b/js/ui/views/summary/index.js
deleted file mode 100644
index 82aaa37..0000000
--- a/js/ui/views/summary/index.js
+++ /dev/null
@@ -1,27 +0,0 @@
-import { html } from 'lit-html';
-import { getDashSummaryTemplate } from './dash.js';
-import { getHlsSummaryTemplate } from './hls.js';
-
-/**
- * Main dispatcher for the Global Summary view.
- * It selects the appropriate protocol-specific template to render.
- * @param {import('../../../app/types.js').Stream} stream The active stream.
- * @returns {import('lit-html').TemplateResult} The rendered template for the summary.
- */
-export function getGlobalSummaryTemplate(stream) {
-    if (!stream || !stream.manifest || !stream.manifest.summary) {
-        return html`<p class="warn">No manifest summary data to display.</p>`;
-    }
-
-    if (stream.protocol === 'dash') {
-        return getDashSummaryTemplate(stream);
-    }
-
-    if (stream.protocol === 'hls') {
-        return getHlsSummaryTemplate(stream);
-    }
-
-    return html`<p class="warn">
-        Summary view not available for unknown protocol.
-    </p>`;
-}
diff --git a/js/ui/views/timeline-visuals/components/dash/index.js b/js/ui/views/timeline-visuals/components/dash/index.js
deleted file mode 100644
index ea82934..0000000
--- a/js/ui/views/timeline-visuals/components/dash/index.js
+++ /dev/null
@@ -1,190 +0,0 @@
-import { html } from 'lit-html';
-import { eventBus } from '../../../../../app/event-bus.js';
-
-const renderEvents = (events, totalDuration, timelineStart = 0) => {
-    if (!events || events.length === 0) return '';
-    return events.map((event) => {
-        const startTime = event.startTime;
-        const duration = event.duration;
-
-        const left = ((startTime - timelineStart) / totalDuration) * 100;
-        const width = (duration / totalDuration) * 100;
-
-        if (left < 0 || left > 100) return '';
-
-        let tooltipContent;
-        let eventClasses = 'bg-yellow-500/50 border-l-2 border-yellow-400';
-        let clickHandler = () => {};
-
-        if (event.scte35 && !event.scte35.error) {
-            const cmd = event.scte35.splice_command;
-            const desc = event.scte35.descriptors?.[0];
-            eventClasses =
-                'bg-purple-500/60 border-l-4 border-purple-400 cursor-pointer hover:ring-2 hover:ring-purple-300';
-            let details = '';
-            if (cmd.type === 'Splice Insert' && cmd.break_duration) {
-                details = `Break Duration: ${(
-                    cmd.break_duration.duration / 90000
-                ).toFixed(3)}s`;
-            } else if (cmd.type === 'Time Signal' && desc) {
-                details = `Type: ${desc.segmentation_type_id}\nUPID: ${desc.segmentation_upid || 'N/A'}`;
-            }
-
-            tooltipContent = `SCTE-35: ${cmd.type}\nTime: ${startTime.toFixed(
-                3
-            )}s\n${details}\n(Click for full details)`;
-            clickHandler = () =>
-                eventBus.dispatch('ui:show-scte35-details', {
-                    scte35: event.scte35,
-                    startTime,
-                });
-        } else {
-            tooltipContent = `Event: ${event.message}\nTime: ${startTime.toFixed(
-                2
-            )}s\nDuration: ${duration.toFixed(2)}s`;
-        }
-
-        return html`<div
-            class="absolute top-0 h-full ${eventClasses} z-10"
-            style="left: ${left}%; width: ${Math.max(0.2, width)}%;"
-            data-tooltip="${tooltipContent}"
-            @click=${clickHandler}
-        ></div>`;
-    });
-};
-
-const dashAbrLadderTemplate = (representations) => {
-    if (representations.length === 0) return '';
-
-    const reps = [...representations].sort((a, b) => a.bandwidth - b.bandwidth);
-    const maxBw = Math.max(...reps.map((r) => r.bandwidth || 0));
-
-    return html`
-        <div class="bg-gray-900 p-4 rounded-md mt-4">
-            <div class="space-y-2">
-                ${reps.map((rep) => {
-                    const widthPercentage =
-                        ((rep.bandwidth || 0) / maxBw) * 100;
-                    return html` <div class="flex items-center">
-                        <div
-                            class="w-28 text-xs text-gray-400 font-mono flex-shrink-0"
-                            title="Resolution: ${rep.resolution}"
-                        >
-                            ID: ${rep.id}
-                        </div>
-                        <div class="w-full bg-gray-700 rounded-full h-5">
-                            <div
-                                class="bg-blue-600 h-5 rounded-full text-xs font-medium text-blue-100 text-center p-0.5 leading-none"
-                                style="width: ${widthPercentage}%"
-                            >
-                                ${rep.bandwidth
-                                    ? (rep.bandwidth / 1000).toFixed(0) +
-                                      ' kbps'
-                                    : 'N/A'}
-                            </div>
-                        </div>
-                    </div>`;
-                })}
-            </div>
-        </div>
-    `;
-};
-
-const timelineGridTemplate = (switchingSet) => {
-    const { totalDuration, representations } = switchingSet;
-    if (totalDuration === 0)
-        return html`<p class="text-gray-400 text-sm">
-            Cannot render timeline: Total duration is zero or unknown.
-        </p>`;
-
-    const allEvents = representations.flatMap((r) => r.events || []);
-    const allFragments = representations.flatMap((r) => r.fragments || []);
-    const utcTimes = allFragments.map((f) => f.startTimeUTC).filter((t) => t);
-    const hasUtcTimes = utcTimes.length > 0;
-    const minUtcTime = hasUtcTimes ? Math.min(...utcTimes) : 0;
-    const maxUtcTime = hasUtcTimes ? Math.max(...utcTimes) : 0;
-
-    return html`
-        <div class="mt-8">
-            <h4 class="text-lg font-bold">Switching Set: ${switchingSet.id}</h4>
-            <div class="bg-gray-900 rounded-lg p-4 mt-2 relative">
-                ${renderEvents(allEvents, totalDuration)}
-                ${representations.map(
-                    (rep) => html`
-                        <div class="flex items-center mb-1">
-                            <div
-                                class="w-32 text-xs text-gray-400 font-mono flex-shrink-0 pr-2 text-right"
-                                title="Resolution: ${rep.resolution}"
-                            >
-                                Rep ID: ${rep.id}
-                            </div>
-                            <div
-                                class="w-full h-8 bg-gray-700/50 rounded flex items-center relative"
-                            >
-                                ${rep.fragments
-                                    ? rep.fragments.map(
-                                          (frag) => html`
-                                              <div
-                                                  class="h-full bg-gray-600 border-r border-gray-800"
-                                                  style="width: ${(frag.duration /
-                                                      totalDuration) *
-                                                  100}%;"
-                                                  data-tooltip="Segment #${frag.number}
-Start: ${frag.startTime.toFixed(2)}s
-Duration: ${frag.duration.toFixed(2)}s
-End: ${(frag.startTime + frag.duration).toFixed(2)}s${frag.startTimeUTC
-                                                      ? `\nAvailable (UTC): ${new Date(
-                                                            frag.startTimeUTC
-                                                        ).toLocaleTimeString()}`
-                                                      : ''}"
-                                              ></div>
-                                          `
-                                      )
-                                    : html`<div
-                                          class="w-full h-full bg-red-900/50 text-red-300 text-xs flex items-center justify-center p-2"
-                                      >
-                                          ${rep.error}
-                                      </div>`}
-                            </div>
-                        </div>
-                    `
-                )}
-            </div>
-            <div class="text-xs text-gray-400 mt-2 flex justify-between">
-                <span>0.00s</span>
-                <span>Media Time - Total: ${totalDuration.toFixed(2)}s</span>
-            </div>
-            ${hasUtcTimes
-                ? html`<div
-                      class="text-xs text-gray-500 mt-1 flex justify-between"
-                  >
-                      <span>${new Date(minUtcTime).toLocaleTimeString()}</span>
-                      <span>Wall-Clock Time (UTC)</span>
-                      <span>${new Date(maxUtcTime).toLocaleTimeString()}</span>
-                  </div>`
-                : ''}
-            ${dashAbrLadderTemplate(representations)}
-        </div>
-    `;
-};
-
-export function dashTimelineTemplate(timelineViewModel) {
-    if (!timelineViewModel) {
-        return html`<div class="text-center py-8 text-gray-400">
-            Loading timeline data...
-        </div>`;
-    }
-    if (timelineViewModel.length === 0) {
-        return html`<div class="text-center py-8 text-gray-400">
-            No video switching sets with segment indexes found to build
-            timeline.
-        </div>`;
-    }
-
-    return html`
-        <h3 class="text-xl font-bold mb-4">
-            CMAF Timeline & Fragment Alignment
-        </h3>
-        ${timelineViewModel.map(timelineGridTemplate)}
-    `;
-}
diff --git a/js/ui/views/timeline-visuals/components/hls/index.js b/js/ui/views/timeline-visuals/components/hls/index.js
deleted file mode 100644
index 76a9ea0..0000000
--- a/js/ui/views/timeline-visuals/components/hls/index.js
+++ /dev/null
@@ -1,304 +0,0 @@
-import { html } from 'lit-html';
-import { eventBus } from '../../../../../app/event-bus.js';
-
-const renderEvents = (events, totalDuration) => {
-    if (!events || events.length === 0) return '';
-    return events.map((event) => {
-        const left = (event.startTime / totalDuration) * 100;
-        const width = (event.duration / totalDuration) * 100;
-        const isInterstitial = event.message
-            .toLowerCase()
-            .includes('interstitial');
-
-        let eventClasses = isInterstitial
-            ? 'bg-purple-500/60 border-l-4 border-purple-400'
-            : 'bg-yellow-500/50 border-l-2 border-yellow-400';
-
-        let tooltipContent;
-        let clickHandler = () => {};
-
-        if (event.scte35 && !event.scte35.error) {
-            const cmd = event.scte35.splice_command;
-            const desc = event.scte35.descriptors?.[0];
-            eventClasses =
-                'bg-purple-500/60 border-l-4 border-purple-400 cursor-pointer hover:ring-2 hover:ring-purple-300';
-
-            let details = `Cue: ${event.cue || 'N/A'}`;
-            if (cmd.type === 'Splice Insert' && cmd.break_duration) {
-                details = `Break Duration: ${(
-                    cmd.break_duration.duration / 90000
-                ).toFixed(3)}s`;
-            } else if (cmd.type === 'Time Signal' && desc) {
-                details = `Type: ${desc.segmentation_type_id}\nUPID: ${desc.segmentation_upid || 'N/A'}`;
-            }
-
-            tooltipContent = `SCTE-35: ${cmd.type}\nStart: ${event.startTime.toFixed(
-                3
-            )}s\n${details}\n(Click for full details)`;
-            clickHandler = () =>
-                eventBus.dispatch('ui:show-scte35-details', {
-                    scte35: event.scte35,
-                    startTime: event.startTime,
-                });
-        } else {
-            const title = isInterstitial
-                ? `Interstitial Ad: ${event.message}`
-                : event.message;
-
-            tooltipContent = `${title}\nStart: ${event.startTime.toFixed(
-                2
-            )}s\nDuration: ${event.duration.toFixed(2)}s${
-                event.cue ? `\nCue: ${event.cue}` : ''
-            }`;
-        }
-
-        return html`<div
-            class="absolute top-0 bottom-0 ${eventClasses}"
-            style="left: ${left}%; width: ${width}%;"
-            data-tooltip="${tooltipContent}"
-            @click=${clickHandler}
-        ></div>`;
-    });
-};
-
-const hlsAbrLadderTemplate = (manifest) => {
-    const videoReps = manifest.periods
-        .flatMap((p) => p.adaptationSets)
-        .filter((as) => as.contentType === 'video')
-        .flatMap((as) => as.representations)
-        .sort((a, b) => a.bandwidth - b.bandwidth);
-
-    if (videoReps.length === 0) return html``;
-
-    const maxBw = Math.max(...videoReps.map((r) => r.bandwidth));
-
-    const repTemplate = videoReps.map((rep) => {
-        const bw = rep.bandwidth;
-        const widthPercentage = (bw / maxBw) * 100;
-        const resolutionText =
-            rep.width && rep.height
-                ? `${rep.width}x${rep.height}`
-                : 'Audio Only';
-        const codecs = rep.codecs || 'N/A';
-
-        return html`
-            <div class="flex items-center" title="Codecs: ${codecs}">
-                <div class="w-28 text-xs text-gray-400 font-mono flex-shrink-0">
-                    ${resolutionText}
-                </div>
-                <div class="w-full bg-gray-700 rounded-full h-5">
-                    <div
-                        class="bg-blue-600 h-5 rounded-full text-xs font-medium text-blue-100 text-center p-0.5 leading-none"
-                        style="width: ${widthPercentage}%"
-                    >
-                        ${(bw / 1000).toFixed(0)} kbps
-                    </div>
-                </div>
-            </div>
-        `;
-    });
-
-    return html`
-        <div class="mt-6">
-            <h4 class="text-lg font-bold">ABR Bitrate Ladder</h4>
-            <div class="bg-gray-900 p-4 rounded-md mt-4 space-y-2">
-                ${repTemplate}
-            </div>
-        </div>
-    `;
-};
-
-const masterPlaylistSummaryTemplate = (manifest) => {
-    const { periods } = manifest;
-    const adaptationSets = periods.flatMap((p) => p.adaptationSets);
-    const videoVariants = adaptationSets
-        .filter((as) => as.contentType === 'video')
-        .reduce((sum, as) => sum + as.representations.length, 0);
-    const audioRenditions = adaptationSets.filter(
-        (as) => as.contentType === 'audio'
-    ).length;
-    const subtitleRenditions = adaptationSets.filter(
-        (as) => as.contentType === 'text' || as.contentType === 'application'
-    ).length;
-
-    const statCard = (label, value) => html`
-        <div class="bg-gray-900 p-3 rounded-lg border border-gray-700">
-            <dt class="text-sm font-medium text-gray-400">${label}</dt>
-            <dd class="text-lg font-mono text-white mt-1">${value}</dd>
-        </div>
-    `;
-
-    return html`
-        <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-6">
-            ${statCard('Variant Streams', videoVariants)}
-            ${statCard('Audio Renditions', audioRenditions)}
-            ${statCard('Subtitle Renditions', subtitleRenditions)}
-        </div>
-    `;
-};
-
-const vodTimelineTemplate = (manifest) => {
-    const segments = manifest.segments || [];
-    const totalDuration = manifest.duration;
-
-    if (totalDuration === 0 || segments.length === 0)
-        return html`<p class="info">
-            No segments found or total duration is zero.
-        </p>`;
-
-    const gridTemplateColumns = segments
-        .map((s) => `${(s.duration / totalDuration) * 100}%`)
-        .join(' ');
-
-    const timelineSegments = segments.map((seg, index) => {
-        const isDiscontinuity = seg.discontinuity;
-        const tooltipContent = `Segment #${
-            (manifest.mediaSequence || 0) + index
-        }\nDuration: ${seg.duration.toFixed(3)}s${
-            isDiscontinuity ? '\n(Discontinuity)' : ''
-        }${
-            seg.dateTime ? `\nPDT: ${new Date(seg.dateTime).toISOString()}` : ''
-        }`;
-
-        return html`
-            <div
-                class="bg-gray-700 rounded h-10 border-r-2 ${isDiscontinuity
-                    ? 'border-l-4 border-l-yellow-400'
-                    : 'border-gray-900'} last:border-r-0"
-                data-tooltip="${tooltipContent}"
-            ></div>
-        `;
-    });
-
-    return html`
-        <h3 class="text-xl font-bold mb-4">Timeline Visualization</h3>
-        <div class="bg-gray-900 rounded-lg p-2 relative">
-            <div
-                class="grid grid-flow-col auto-cols-fr"
-                style="grid-template-columns: ${gridTemplateColumns}"
-            >
-                ${timelineSegments}
-            </div>
-            ${renderEvents(manifest.events, totalDuration)}
-        </div>
-        <div class="text-xs text-gray-400 mt-2 text-right">
-            Total Duration: ${totalDuration.toFixed(2)}s
-        </div>
-    `;
-};
-
-const liveTimelineTemplate = (manifest) => {
-    const segments = manifest.segments || [];
-    const targetDuration = manifest.targetDuration || 10;
-    const liveWindowSegments = segments.slice(-3 * targetDuration); // Show roughly 3x target duration
-    const windowDuration = liveWindowSegments.reduce(
-        (sum, seg) => sum + seg.duration,
-        0
-    );
-
-    const partHoldBack = manifest.serverControl?.['PART-HOLD-BACK'];
-    const holdBackPosition =
-        partHoldBack != null && windowDuration > 0
-            ? 100 - (partHoldBack / windowDuration) * 100
-            : null;
-
-    const preloadHint = manifest.preloadHints?.find((h) => h.TYPE === 'PART');
-    const preloadDuration = preloadHint?.DURATION || 0;
-    const preloadWidth = (preloadDuration / windowDuration) * 100;
-
-    return html`
-        <h3 class="text-xl font-bold mb-4">Live Timeline Visualization</h3>
-        <div class="bg-gray-900 rounded-lg p-4 text-center">
-            <div
-                class="flex items-center justify-between text-sm text-gray-400 mb-2"
-            >
-                <span
-                    >Segments in Playlist:
-                    <strong>${segments.length}</strong></span
-                >
-                <span
-                    >Target Duration: <strong>${targetDuration}s</strong></span
-                >
-                <span
-                    >Current Window Duration:
-                    <strong>${windowDuration.toFixed(2)}s</strong></span
-                >
-            </div>
-            <div class="bg-gray-800 p-2 rounded relative">
-                <div
-                    class="grid grid-flow-col auto-cols-fr h-10"
-                    style="grid-template-columns: ${liveWindowSegments
-                        .map((s) => `${(s.duration / windowDuration) * 100}%`)
-                        .join(' ')}"
-                >
-                    ${liveWindowSegments.map(
-                        (seg, i) =>
-                            html`<div
-                                class="bg-gray-700/50 border-r border-gray-900 flex"
-                                data-tooltip="Segment Duration: ${seg.duration.toFixed(
-                                    2
-                                )}s"
-                            >
-                                ${seg.parts.map(
-                                    (part) => html`
-                                        <div
-                                            class="h-full bg-blue-800/60 border-r border-gray-700"
-                                            style="width: ${(part.DURATION /
-                                                seg.duration) *
-                                            100}%"
-                                            data-tooltip="Partial Segment
-Duration: ${part.DURATION.toFixed(3)}s
-Independent: ${part.INDEPENDENT === 'YES' ? 'Yes' : 'No'}"
-                                        ></div>
-                                    `
-                                )}
-                            </div>`
-                    )}
-                </div>
-                ${renderEvents(manifest.events, windowDuration)}
-                ${preloadHint
-                    ? html`
-                          <div
-                              class="absolute top-0 right-0 h-full bg-blue-500/20 border-l-2 border-dashed border-blue-400"
-                              style="width: ${preloadWidth}%; transform: translateX(100%);"
-                              data-tooltip="Preload Hint: ${preloadHint.URI}
-Duration: ${preloadDuration}s"
-                          ></div>
-                      `
-                    : ''}
-                ${holdBackPosition !== null
-                    ? html`<div
-                          class="absolute top-0 bottom-0 w-0.5 bg-cyan-400"
-                          style="left: ${holdBackPosition}%;"
-                          data-tooltip="Server Recommended Playback Position (PART-HOLD-BACK: ${partHoldBack}s)"
-                      ></div>`
-                    : ''}
-                <div
-                    class="absolute right-0 top-0 bottom-0 w-1 bg-red-500 rounded-full"
-                    data-tooltip="Approximate Live Edge"
-                ></div>
-            </div>
-        </div>
-    `;
-};
-
-export function hlsTimelineTemplate(manifest) {
-    if (manifest.isMaster) {
-        return html`
-            <h3 class="text-xl font-bold mb-4">HLS Master Playlist</h3>
-            <p class="text-sm text-gray-400 mb-4">
-                A master playlist defines available variants but does not have a
-                monolithic timeline.
-            </p>
-            ${masterPlaylistSummaryTemplate(manifest)}
-            ${hlsAbrLadderTemplate(manifest)}
-        `;
-    }
-
-    if (manifest.type === 'dynamic') {
-        return liveTimelineTemplate(manifest);
-    }
-
-    // Fallback to VOD Media Playlist
-    return vodTimelineTemplate(manifest);
-}
diff --git a/js/ui/views/timeline-visuals/index.js b/js/ui/views/timeline-visuals/index.js
deleted file mode 100644
index 6a0de46..0000000
--- a/js/ui/views/timeline-visuals/index.js
+++ /dev/null
@@ -1,90 +0,0 @@
-import { html, render } from 'lit-html';
-import { dashTimelineTemplate } from './components/dash/index.js';
-import { hlsTimelineTemplate } from './components/hls/index.js';
-import { createDashTimelineViewModel } from './view-model.js';
-
-/**
- * Renders the timeline view based on the provided state.
- * @param {object} manifest - The stream's manifest.
- * @param {string} protocol - The stream's protocol.
- * @param {object | null} viewModel - The calculated view model data.
- * @param {boolean} isLoading - A flag indicating if data is being loaded.
- * @returns {import('lit-html').TemplateResult}
- */
-export function getTimelineAndVisualsTemplate(
-    manifest,
-    protocol,
-    viewModel,
-    isLoading
-) {
-    if (protocol === 'hls') {
-        return hlsTimelineTemplate(manifest);
-    }
-
-    if (isLoading) {
-        return html`<div class="text-center py-8 text-gray-400">
-            Loading timeline data...
-        </div>`;
-    }
-
-    return dashTimelineTemplate(viewModel);
-}
-
-/**
- * Controller function to orchestrate the rendering of the timeline view.
- * It handles the asynchronous loading of the view model.
- * @param {HTMLElement} container - The DOM element to render into.
- * @param {import('../../../app/types.js').Stream} stream - The stream data.
- */
-export function initializeTimelineView(container, stream) {
-    if (stream.protocol === 'hls') {
-        render(
-            getTimelineAndVisualsTemplate(
-                stream.manifest,
-                stream.protocol,
-                null,
-                false
-            ),
-            container
-        );
-        return;
-    }
-
-    // For DASH, we need to build the view model asynchronously.
-    // 1. Render the initial loading state immediately.
-    render(
-        getTimelineAndVisualsTemplate(
-            stream.manifest,
-            stream.protocol,
-            null,
-            true
-        ),
-        container
-    );
-
-    // 2. Kick off the asynchronous view model creation.
-    createDashTimelineViewModel(stream)
-        .then((viewModel) => {
-            // 3. Once data is ready, re-render with the complete view model.
-            render(
-                getTimelineAndVisualsTemplate(
-                    stream.manifest,
-                    stream.protocol,
-                    viewModel,
-                    false
-                ),
-                container
-            );
-        })
-        .catch((err) => {
-            // 4. If an error occurs, render an error state.
-            console.error('Failed to create DASH timeline view model:', err);
-            const errorTemplate = html`<div
-                class="text-red-400 p-4 text-center"
-            >
-                <p class="font-bold">Error loading timeline visualization.</p>
-                <p class="text-sm font-mono mt-2">${err.message}</p>
-            </div>`;
-            render(errorTemplate, container);
-        });
-}
diff --git a/js/ui/views/timeline-visuals/view-model.js b/js/ui/views/timeline-visuals/view-model.js
deleted file mode 100644
index 26c9cae..0000000
--- a/js/ui/views/timeline-visuals/view-model.js
+++ /dev/null
@@ -1,88 +0,0 @@
-import { useSegmentCacheStore } from '../../../app/store.js';
-import { parseAllSegmentUrls } from '../../../infrastructure/manifest/dash/segment-parser.js';
-
-/**
- * Creates a view model for the DASH timeline visualization by leveraging the central segment parser.
- * @param {import('../../../app/types.ts').Stream} stream
- * @returns {Promise<object[]>} A promise that resolves to an array of switching set view models.
- */
-export async function createDashTimelineViewModel(stream) {
-    if (!stream || !stream.manifest) return [];
-
-    // Use the single source of truth for segment parsing. This function is synchronous
-    // and does not perform any network requests for this type of manifest.
-    const segmentsByRepId = parseAllSegmentUrls(
-        stream.manifest.serializedManifest,
-        stream.baseUrl
-    );
-
-    const switchingSets = stream.manifest.periods.flatMap((period) =>
-        period.adaptationSets
-            .filter((as) => as.contentType === 'video')
-            .map((as) => {
-                const representations = as.representations.map((rep) => {
-                    const compositeKey = `${period.id}-${rep.id}`;
-                    const segments = segmentsByRepId[compositeKey] || [];
-                    const mediaSegments = segments.filter(
-                        (s) => /** @type {any} */ (s).type === 'Media'
-                    );
-
-                    if (mediaSegments.length === 0) {
-                        return {
-                            id: rep.id,
-                            bandwidth: rep.bandwidth,
-                            resolution: `${rep.width}x${rep.height}`,
-                            error: 'No media segments could be parsed for this Representation.',
-                            fragments: [],
-                            events: [],
-                        };
-                    }
-
-                    const fragments = mediaSegments.map((seg) => ({
-                        number: /** @type {any} */ (seg).number,
-                        startTime:
-                            /** @type {any} */ (seg).time /
-                            /** @type {any} */ (seg).timescale,
-                        duration:
-                            /** @type {any} */ (seg).duration /
-                            /** @type {any} */ (seg).timescale,
-                        startTimeUTC: /** @type {any} */ (seg).startTimeUTC,
-                    }));
-
-                    const events = [];
-                    useSegmentCacheStore.getState().cache.forEach((entry) => {
-                        if (entry.parsedData?.data?.events) {
-                            events.push(...entry.parsedData.data.events);
-                        }
-                    });
-
-                    return {
-                        id: rep.id,
-                        bandwidth: rep.bandwidth,
-                        resolution: `${rep.width}x${rep.height}`,
-                        fragments,
-                        events,
-                    };
-                });
-
-                const totalDuration =
-                    stream.manifest.duration ??
-                    period.duration ??
-                    (representations[0]?.fragments
-                        ? representations[0].fragments
-                              .map((f) => f.duration)
-                              .reduce((acc, f) => acc + f, 0)
-                        : 0);
-
-                return {
-                    id: as.id || 'video-set',
-                    totalDuration,
-                    representations,
-                };
-            })
-    );
-
-    // This function is now effectively synchronous for this manifest type,
-    // so we can wrap the result in a resolved promise.
-    return Promise.resolve(switchingSets);
-}
diff --git a/js/worker.js b/js/worker.js
deleted file mode 100644
index 078e30f..0000000
--- a/js/worker.js
+++ /dev/null
@@ -1,706 +0,0 @@
-import { parseISOBMFF } from './infrastructure/segment/isobmff/parser.js';
-import { parse as parseTsSegment } from './infrastructure/segment/ts/index.js';
-import { parseManifest as parseDashManifestString } from './infrastructure/manifest/dash/parser.js';
-import { parseManifest as parseHlsManifest } from './infrastructure/manifest/hls/parser.js';
-import { parseAllSegmentUrls as parseDashSegments } from './infrastructure/manifest/dash/segment-parser.js';
-import { runChecks } from './domain/compliance/engine.js';
-import { validateSteeringManifest } from './domain/hls/steering-validator.js';
-import {
-    analyzeDashCoverage,
-    analyzeParserDrift,
-} from './domain/debug/coverage-analyzer.js';
-import { DOMParser, XMLSerializer } from 'xmldom';
-import xpath from 'xpath';
-import { parseVTT } from './infrastructure/segment/vtt/parser.js';
-
-/** @typedef {import('./app/types.ts').SerializedStream} SerializedStream */
-
-// --- XML Patch Logic ---
-/**
- * Applies an RFC 5261 XML patch to a source XML document.
- * @param {string} sourceXml - The original XML string.
- * @param {string} patchXml - The patch XML string.
- * @returns {string} The new, patched XML string.
- */
-function applyXmlPatch(sourceXml, patchXml) {
-    const domParser = new DOMParser();
-    const serializer = new XMLSerializer();
-
-    const sourceDoc = domParser.parseFromString(sourceXml, 'application/xml');
-    const patchDoc = domParser.parseFromString(patchXml, 'application/xml');
-
-    const patchOps = Array.from(patchDoc.documentElement.childNodes).filter(
-        (n) => n.nodeType === 1
-    ); // Only element nodes
-
-    const select = xpath.useNamespaces({ d: 'urn:mpeg:dash:schema:mpd:2011' });
-
-    for (const op of patchOps) {
-        const selector = /** @type {Element} */ (op).getAttribute('sel');
-        if (!selector) continue;
-
-        const targets = select(selector, sourceDoc);
-        if (!Array.isArray(targets)) {
-            continue;
-        }
-
-        for (const target of targets) {
-            // Ensure target is a Node with expected methods
-            if (typeof target !== 'object' || !target.nodeType) {
-                continue;
-            }
-            const targetNode = /** @type {Node} */ (target);
-
-            switch (op.nodeName) {
-                case 'add': {
-                    const content = op.firstChild;
-                    if (
-                        content &&
-                        targetNode.nodeType === 1 /* ELEMENT_NODE */
-                    ) {
-                        /** @type {Element} */ (targetNode).appendChild(
-                            content.cloneNode(true)
-                        );
-                    }
-                    break;
-                }
-                case 'replace': {
-                    const content = op.firstChild;
-                    if (content && targetNode.parentNode) {
-                        targetNode.parentNode.replaceChild(
-                            content.cloneNode(true),
-                            targetNode
-                        );
-                    }
-                    break;
-                }
-                case 'remove': {
-                    if (targetNode.parentNode) {
-                        targetNode.parentNode.removeChild(targetNode);
-                    }
-                    break;
-                }
-            }
-        }
-    }
-
-    return serializer.serializeToString(sourceDoc);
-}
-
-// --- HLS Delta Update Logic (moved from delta-updater.js) ---
-
-/**
- * Applies a delta update to an old HLS playlist object.
- * @param {object} oldParsedHls The fully parsed object of the previous manifest.
- * @param {object} deltaParsedHls The fully parsed object of the new delta update manifest.
- * @returns {object} A new, fully resolved parsed HLS object.
- */
-function applyDeltaUpdate(oldParsedHls, deltaParsedHls) {
-    const skipTag = deltaParsedHls.tags.find((t) => t.name === 'EXT-X-SKIP');
-    if (!skipTag) {
-        // This isn't a delta update, return the new playlist as-is.
-        return deltaParsedHls;
-    }
-
-    const skippedSegments = skipTag.value['SKIPPED-SEGMENTS'];
-
-    // Deep clone the old playlist to avoid mutation
-    const resolvedHls = JSON.parse(JSON.stringify(oldParsedHls));
-
-    // Update sequences and playlist type from the delta manifest
-    resolvedHls.mediaSequence = deltaParsedHls.mediaSequence;
-    resolvedHls.discontinuitySequence = deltaParsedHls.discontinuitySequence;
-    resolvedHls.playlistType = deltaParsedHls.playlistType;
-
-    // Filter out the skipped segments from the old playlist
-    const oldSegmentCount = resolvedHls.segments.length;
-    resolvedHls.segments = resolvedHls.segments.slice(
-        oldSegmentCount - (oldSegmentCount - skippedSegments)
-    );
-
-    // Append new segments from the delta playlist
-    resolvedHls.segments.push(...deltaParsedHls.segments);
-
-    // Replace all top-level tags with tags from the delta manifest, except for EXT-X-SKIP itself.
-    resolvedHls.tags = deltaParsedHls.tags.filter(
-        (t) => t.name !== 'EXT-X-SKIP'
-    );
-
-    // Update other properties from the delta
-    resolvedHls.targetDuration = deltaParsedHls.targetDuration;
-    resolvedHls.partInf = deltaParsedHls.partInf;
-    resolvedHls.serverControl = deltaParsedHls.serverControl;
-    resolvedHls.isLive = deltaParsedHls.isLive;
-
-    return resolvedHls;
-}
-
-/**
- * Serializes a parsed HLS object back into a manifest string.
- * @param {object} parsedHls The parsed HLS object.
- * @returns {string} The manifest string.
- */
-function serializeHls(parsedHls) {
-    const lines = ['#EXTM3U'];
-    if (parsedHls.version > 1) {
-        lines.push(`#EXT-X-VERSION:${parsedHls.version}`);
-    }
-    if (parsedHls.targetDuration) {
-        lines.push(`#EXT-X-TARGETDURATION:${parsedHls.targetDuration}`);
-    }
-    if (parsedHls.mediaSequence) {
-        lines.push(`#EXT-X-MEDIA-SEQUENCE:${parsedHls.mediaSequence}`);
-    }
-    // Add other header tags...
-    if (parsedHls.partInf) {
-        lines.push(
-            `#EXT-X-PART-INF:PART-TARGET=${parsedHls.partInf['PART-TARGET']}`
-        );
-    }
-    if (parsedHls.serverControl) {
-        const attrs = Object.entries(parsedHls.serverControl)
-            .map(([k, v]) => `${k}=${v}`)
-            .join(',');
-        lines.push(`#EXT-X-SERVER-CONTROL:${attrs}`);
-    }
-
-    let lastKey = null;
-
-    parsedHls.segments.forEach((segment) => {
-        if (segment.discontinuity) {
-            lines.push('#EXT-X-DISCONTINUITY');
-        }
-        if (
-            segment.key &&
-            JSON.stringify(segment.key) !== JSON.stringify(lastKey)
-        ) {
-            const attrs = Object.entries(segment.key)
-                .map(([k, v]) => `${k}="${v}"`)
-                .join(',');
-            lines.push(`#EXT-X-KEY:${attrs}`);
-            lastKey = segment.key;
-        }
-        if (segment.dateTime) {
-            lines.push(`#EXT-X-PROGRAM-DATE-TIME:${segment.dateTime}`);
-        }
-        lines.push(
-            `#EXTINF:${segment.duration.toFixed(5)},${segment.title || ''}`
-        );
-        if (segment.uri) {
-            lines.push(segment.uri);
-        }
-        segment.parts.forEach((part) => {
-            const attrs = Object.entries(part)
-                .map(([k, v]) => `${k}="${v}"`)
-                .join(',');
-            lines.push(`#EXT-X-PART:${attrs}`);
-        });
-    });
-
-    if (!parsedHls.isLive) {
-        lines.push('#EXT-X-ENDLIST');
-    }
-
-    return lines.join('\n');
-}
-
-// --- MODULARIZED ANALYSIS PIPELINE ---
-
-async function preProcessInput(input) {
-    const trimmedManifest = input.manifestString.trim();
-    let protocol;
-    if (trimmedManifest.startsWith('#EXTM3U')) {
-        protocol = 'hls';
-    } else if (trimmedManifest.includes('<MPD')) {
-        protocol = 'dash';
-    } else {
-        protocol = (input.url || input.file.name)
-            .toLowerCase()
-            .includes('.m3u8')
-            ? 'hls'
-            : 'dash';
-    }
-
-    self.postMessage({
-        type: 'status-update',
-        payload: { message: `Parsing (${protocol.toUpperCase()})...` },
-    });
-
-    return { ...input, protocol };
-}
-
-async function parseManifest(input) {
-    let manifestIR, serializedManifestObject, finalBaseUrl;
-
-    if (input.protocol === 'hls') {
-        const { manifest, definedVariables, baseUrl } = await parseHlsManifest(
-            input.manifestString,
-            input.url
-        );
-        manifestIR = manifest;
-        serializedManifestObject = manifest.serializedManifest;
-        manifestIR.hlsDefinedVariables = definedVariables;
-        finalBaseUrl = baseUrl;
-
-        // Determine liveness for master playlists by checking the first variant
-        if (manifestIR.isMaster && manifestIR.variants.length > 0) {
-            try {
-                const firstVariantUrl = manifestIR.variants[0].resolvedUri;
-                const response = await fetch(firstVariantUrl);
-                const mediaPlaylistString = await response.text();
-                manifestIR.type = mediaPlaylistString.includes('#EXT-X-ENDLIST')
-                    ? 'static'
-                    : 'dynamic';
-            } catch (_e) {
-                manifestIR.type = 'static'; // Default to VOD on error
-            }
-        }
-    } else {
-        // DASH
-        const { manifest, serializedManifest, baseUrl } =
-            await parseDashManifestString(input.manifestString, input.url);
-        manifestIR = manifest;
-        serializedManifestObject = serializedManifest;
-        finalBaseUrl = baseUrl;
-    }
-    return { input, manifestIR, serializedManifestObject, finalBaseUrl };
-}
-
-async function runAllAnalyses({
-    input,
-    manifestIR,
-    serializedManifestObject,
-    finalBaseUrl,
-}) {
-    const { generateFeatureAnalysis } = await import(
-        './domain/feature-analysis/analyzer.js'
-    );
-    const rawInitialAnalysis = generateFeatureAnalysis(
-        manifestIR,
-        input.protocol,
-        serializedManifestObject
-    );
-    const featureAnalysisResults = new Map(Object.entries(rawInitialAnalysis));
-    const semanticData = new Map();
-
-    // Content Steering Validation for HLS
-    const steeringTag =
-        input.protocol === 'hls' && manifestIR.isMaster
-            ? (manifestIR.tags || []).find(
-                  (t) => t.name === 'EXT-X-CONTENT-STEERING'
-              )
-            : null;
-    if (steeringTag) {
-        const steeringUri = new URL(
-            steeringTag.value['SERVER-URI'],
-            finalBaseUrl
-        ).href;
-        const validationResult = await validateSteeringManifest(steeringUri);
-        semanticData.set('steeringValidation', validationResult);
-    }
-
-    const manifestObjectForChecks =
-        input.protocol === 'hls' ? manifestIR : serializedManifestObject;
-    const complianceResults = runChecks(
-        manifestObjectForChecks,
-        input.protocol
-    );
-
-    let coverageReport = [];
-    if (input.isDebug) {
-        let findings =
-            input.protocol === 'dash'
-                ? analyzeDashCoverage(serializedManifestObject)
-                : [];
-        const drift = analyzeParserDrift(manifestIR);
-        coverageReport = [...findings, ...drift];
-    }
-
-    return {
-        featureAnalysisResults,
-        semanticData,
-        steeringTag,
-        complianceResults,
-        coverageReport,
-    };
-}
-
-async function buildStreamObject(
-    { input, manifestIR, serializedManifestObject, finalBaseUrl },
-    analysisResults
-) {
-    const {
-        featureAnalysisResults,
-        semanticData,
-        steeringTag,
-        complianceResults,
-        coverageReport,
-    } = analysisResults;
-
-    const streamObject = {
-        id: input.id,
-        name: input.url ? new URL(input.url).hostname : input.file.name,
-        originalUrl: input.url,
-        baseUrl: finalBaseUrl,
-        protocol: input.protocol,
-        isPolling: manifestIR.type === 'dynamic',
-        manifest: manifestIR,
-        rawManifest: input.manifestString,
-        steeringInfo: steeringTag,
-        manifestUpdates: [],
-        activeManifestUpdateIndex: 0,
-        mediaPlaylists: new Map(),
-        activeMediaPlaylistUrl: null,
-        featureAnalysis: {
-            results: featureAnalysisResults,
-            manifestCount: 1,
-        },
-        hlsVariantState: new Map(),
-        dashRepresentationState: new Map(),
-        hlsDefinedVariables: manifestIR.hlsDefinedVariables,
-        semanticData: semanticData,
-        coverageReport,
-    };
-
-    // Initialize states
-    if (input.protocol === 'hls' && manifestIR.isMaster) {
-        // Add video variants
-        (manifestIR.variants || []).forEach((v, index) => {
-            streamObject.hlsVariantState.set(v.resolvedUri, {
-                segments: [],
-                freshSegmentUrls: new Set(),
-                isLoading: false,
-                isPolling: manifestIR.type === 'dynamic',
-                isExpanded: index === 0,
-                displayMode: 'last10',
-                error: null,
-            });
-        });
-        // Add media renditions (audio, subtitles)
-        /** @type {any} */ (serializedManifestObject.media || []).forEach(
-            (media) => {
-                if (media.URI) {
-                    const resolvedUri = new URL(media.URI, finalBaseUrl).href;
-                    streamObject.hlsVariantState.set(resolvedUri, {
-                        segments: [],
-                        freshSegmentUrls: new Set(),
-                        isLoading: false,
-                        isPolling: manifestIR.type === 'dynamic',
-                        isExpanded: false, // Collapse non-video tracks by default
-                        displayMode: 'last10',
-                        error: null,
-                    });
-                }
-            }
-        );
-    } else if (input.protocol === 'dash') {
-        const segmentsByCompositeKey = parseDashSegments(
-            serializedManifestObject,
-            streamObject.baseUrl
-        );
-        Object.entries(segmentsByCompositeKey).forEach(([key, segments]) => {
-            streamObject.dashRepresentationState.set(key, {
-                segments,
-                freshSegmentUrls: new Set(segments.map((s) => s.resolvedUrl)),
-            });
-        });
-    }
-
-    // Add initial manifest to updates list
-    const { diffManifest } = await import('./shared/utils/diff.js');
-    const xmlFormatter = (await import('xml-formatter')).default;
-    let formattedInitial = streamObject.rawManifest;
-    if (streamObject.protocol === 'dash') {
-        formattedInitial = xmlFormatter(streamObject.rawManifest, {
-            indentation: '  ',
-            lineSeparator: '\n',
-        });
-    }
-    streamObject.manifestUpdates.push({
-        timestamp: new Date().toLocaleTimeString(),
-        diffHtml: diffManifest('', formattedInitial, streamObject.protocol),
-        rawManifest: streamObject.rawManifest,
-        complianceResults,
-        hasNewIssues: false,
-        serializedManifest: serializedManifestObject,
-    });
-
-    return streamObject;
-}
-
-function serializeStreamForTransport(streamObject) {
-    const serialized = { ...streamObject };
-    serialized.hlsVariantState = Array.from(
-        streamObject.hlsVariantState.entries()
-    );
-    serialized.dashRepresentationState = Array.from(
-        streamObject.dashRepresentationState.entries()
-    );
-    serialized.featureAnalysis.results = Array.from(
-        streamObject.featureAnalysis.results.entries()
-    );
-    serialized.semanticData = Array.from(streamObject.semanticData.entries());
-    serialized.mediaPlaylists = Array.from(
-        streamObject.mediaPlaylists.entries()
-    );
-    // Ensure manifest.serializedManifest is serializable for transport
-    streamObject.manifest.serializedManifest = JSON.parse(
-        JSON.stringify(streamObject.manifest.serializedManifest)
-    );
-
-    return /** @type {SerializedStream} */ (/** @type {any} */ (serialized));
-}
-
-async function processSingleStream(input) {
-    const preProcessed = await preProcessInput(input);
-    const parsed = await parseManifest(preProcessed);
-    const analysisResults = await runAllAnalyses(parsed);
-    const streamObject = await buildStreamObject(parsed, analysisResults);
-    return serializeStreamForTransport(streamObject);
-}
-
-// --- Worker Message Handlers ---
-
-async function handleStartAnalysis(inputs) {
-    try {
-        self.postMessage({
-            type: 'status-update',
-            payload: {
-                message: `Starting analysis of ${inputs.length} stream(s)...`,
-            },
-        });
-        const results = await Promise.all(inputs.map(processSingleStream));
-        self.postMessage({
-            type: 'analysis-complete',
-            payload: { streams: results.filter(Boolean) },
-        });
-    } catch (error) {
-        self.postMessage({
-            type: 'analysis-error',
-            payload: {
-                message: error.message,
-                error: { message: error.message, stack: error.stack },
-            },
-        });
-    }
-}
-
-async function handleFetchHlsMediaPlaylistInWorker({
-    streamId,
-    variantUri,
-    hlsDefinedVariables,
-}) {
-    try {
-        const response = await fetch(variantUri);
-        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
-        const manifestString = await response.text();
-        const { manifest } = await parseHlsManifest(
-            manifestString,
-            variantUri,
-            hlsDefinedVariables
-        );
-
-        const freshSegmentUrls = new Set(
-            (manifest.segments || []).map((s) => s.resolvedUrl)
-        );
-
-        self.postMessage({
-            type: 'hls-media-playlist-fetched',
-            payload: {
-                streamId,
-                variantUri,
-                manifest, // Send the full manifest IR
-                manifestString, // Send the raw string
-                segments: manifest.segments,
-                freshSegmentUrls,
-            },
-        });
-    } catch (e) {
-        self.postMessage({
-            type: 'hls-media-playlist-error',
-            payload: { streamId, variantUri, error: e.message },
-        });
-    }
-}
-
-async function handleParseLiveUpdate({
-    streamId,
-    newManifestString,
-    oldRawManifest,
-    patchString, // New optional parameter
-    protocol,
-    baseUrl,
-    hlsDefinedVariables,
-    oldManifestObjectForDelta,
-}) {
-    try {
-        let finalManifestString;
-        let newManifestObject;
-        let newSerializedObject;
-
-        if (patchString) {
-            // Apply the XML patch to get the new manifest string
-            finalManifestString = applyXmlPatch(oldRawManifest, patchString);
-        } else {
-            finalManifestString = newManifestString;
-        }
-
-        if (protocol === 'dash') {
-            const { manifest, serializedManifest } =
-                await parseDashManifestString(finalManifestString, baseUrl);
-            newManifestObject = manifest;
-            newSerializedObject = serializedManifest;
-        } else {
-            // HLS: Check for Delta Update
-            if (finalManifestString.includes('#EXT-X-SKIP')) {
-                const { manifest: deltaManifest } = await parseHlsManifest(
-                    finalManifestString,
-                    baseUrl,
-                    hlsDefinedVariables
-                );
-                const resolvedParsedHls = applyDeltaUpdate(
-                    oldManifestObjectForDelta,
-                    deltaManifest.serializedManifest
-                );
-
-                // Re-adapt and re-serialize to get the final state
-                finalManifestString = serializeHls(resolvedParsedHls);
-                const { manifest: resolvedManifest } = await parseHlsManifest(
-                    finalManifestString,
-                    baseUrl,
-                    hlsDefinedVariables
-                );
-                newManifestObject = resolvedManifest;
-                newSerializedObject = resolvedParsedHls;
-            } else {
-                const { manifest } = await parseHlsManifest(
-                    finalManifestString,
-                    baseUrl,
-                    hlsDefinedVariables
-                );
-                newManifestObject = manifest;
-                newSerializedObject = manifest.serializedManifest;
-            }
-        }
-
-        const manifestObjectForChecks =
-            protocol === 'hls' ? newManifestObject : newSerializedObject;
-        const complianceResults = runChecks(manifestObjectForChecks, protocol);
-
-        // Attach the serializable object to the IR before sending back
-        newManifestObject.serializedManifest = newSerializedObject;
-
-        self.postMessage({
-            type: 'live-update-parsed',
-            payload: {
-                streamId,
-                newManifestObject,
-                finalManifestString,
-                oldRawManifest,
-                complianceResults,
-                // Add the pristine object for the compliance view
-                serializedManifest: newSerializedObject,
-            },
-        });
-    } catch (e) {
-        self.postMessage({
-            type: 'live-update-error',
-            payload: { streamId, error: e.message },
-        });
-    }
-}
-
-async function handleGetManifestMetadata({ id, manifestString }) {
-    try {
-        const trimmed = manifestString.trim();
-        let protocol = 'unknown';
-        let type = 'vod'; // Default to VOD
-
-        if (trimmed.startsWith('#EXTM3U')) {
-            protocol = 'hls';
-            if (
-                !trimmed.includes('#EXT-X-ENDLIST') &&
-                !trimmed.includes('EXT-X-PLAYLIST-TYPE:VOD')
-            ) {
-                type = 'live';
-            }
-        } else if (trimmed.includes('<MPD')) {
-            protocol = 'dash';
-            // Use a simple regex to avoid full parsing for this quick check
-            if (/<MPD[^>]*type\s*=\s*["']dynamic["']/.test(trimmed)) {
-                type = 'live';
-            }
-        } else {
-            throw new Error('Could not determine manifest protocol.');
-        }
-
-        self.postMessage({
-            type: 'manifest-metadata-result',
-            payload: { id, metadata: { protocol, type } },
-        });
-    } catch (e) {
-        self.postMessage({
-            type: 'manifest-metadata-result',
-            payload: { id, error: e.message },
-        });
-    }
-}
-
-async function handleMessage(event) {
-    const { type, payload } = event.data;
-
-    switch (type) {
-        case 'start-analysis':
-            await handleStartAnalysis(payload.inputs);
-            break;
-        case 'fetch-hls-media-playlist':
-            await handleFetchHlsMediaPlaylistInWorker(payload);
-            break;
-        case 'parse-live-update':
-            await handleParseLiveUpdate(payload);
-            break;
-        case 'get-manifest-metadata':
-            await handleGetManifestMetadata(payload);
-            break;
-        case 'parse-segment': {
-            const { url, data } = payload;
-            let parsedData = null;
-            try {
-                // Check for VTT signature
-                const decoder = new TextDecoder();
-                const text = decoder.decode(data.slice(0, 10));
-                if (text.startsWith('WEBVTT')) {
-                    const vttString = decoder.decode(data);
-                    parsedData = {
-                        format: 'vtt',
-                        data: parseVTT(vttString),
-                    };
-                } else {
-                    const isLikelyTS =
-                        data.byteLength > 188 &&
-                        new DataView(data).getUint8(0) === 0x47 &&
-                        new DataView(data).getUint8(188) === 0x47;
-                    if (isLikelyTS || url.toLowerCase().endsWith('.ts')) {
-                        parsedData = parseTsSegment(data);
-                    } else {
-                        const { boxes, issues, events } = parseISOBMFF(data);
-                        parsedData = {
-                            format: 'isobmff',
-                            data: { boxes, issues, events },
-                        };
-                    }
-                }
-                self.postMessage({ url, parsedData, error: null });
-            } catch (e) {
-                self.postMessage({
-                    url,
-                    parsedData: { error: e.message },
-                    error: e.message,
-                });
-            }
-            break;
-        }
-    }
-}
-
-self.addEventListener('message', handleMessage);
diff --git a/jsconfig.json b/jsconfig.json
deleted file mode 100644
index 69215cc..0000000
--- a/jsconfig.json
+++ /dev/null
@@ -1,20 +0,0 @@
-{
-    "compilerOptions": {
-        "target": "es2022",
-        "module": "es2022",
-        "moduleResolution": "node",
-        "checkJs": true,
-        "noEmit": true,
-        "types": ["node"],
-        "baseUrl": ".",
-        "paths": {
-            "@js/*": ["js/*"],
-            "@tests/*": ["tests/*"]
-        },
-        "skipLibCheck": true,
-        "allowJs": true,
-        "maxNodeModuleJsDepth": 0
-    },
-    "include": ["js/**/*.js", "tests/**/*.js", "js/**/*.ts"],
-    "exclude": ["node_modules", "dist"]
-}
diff --git a/package.json b/package.json
index f439e6b..fcfb2bc 100644
--- a/package.json
+++ b/package.json
@@ -4,11 +4,11 @@
     "main": "index.js",
     "scripts": {
         "start": "serve .",
-        "typecheck": "tsc --noEmit -p jsconfig.json",
+        "typecheck": "tsc --noEmit -p tsconfig.json",
         "lint": "eslint . --ext .js",
         "format": "prettier --write .",
         "build:css": "tailwindcss -i css/main.css -o dist/main.css --minify",
-        "build:js": "esbuild js/app/main.js --bundle --minify --outfile=dist/main.js && esbuild js/worker.js --bundle --minify --outfile=dist/worker.js",
+        "build:js": "esbuild src/application/main.js --bundle --minify --outfile=dist/main.js && esbuild src/infrastructure/worker/main.js --bundle --minify --outfile=dist/worker.js",
         "build": "npm run build:css && npm run build:js"
     },
     "keywords": [],
@@ -44,4 +44,4 @@
             "public"
         ]
     }
-}
+}
\ No newline at end of file
diff --git a/tailwind.config.js b/tailwind.config.js
index 1909c39..d071f3a 100644
--- a/tailwind.config.js
+++ b/tailwind.config.js
@@ -1,6 +1,6 @@
 /** @type {import('tailwindcss').Config} */
 module.exports = {
-    content: ['./index.html', './js/**/*.js'],
+    content: ['./index.html', './src/**/*.js'],
     theme: {
         extend: {
             fontFamily: {
